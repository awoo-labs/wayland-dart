// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland/-/raw/main/protocol/wayland.xml
//
// wayland Protocol Copyright: 
/// 
/// Copyright © 2008-2011 Kristian Høgsberg
/// Copyright © 2010-2011 Intel Corporation
/// Copyright © 2012-2013 Collabora, Ltd.
/// 
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files
/// (the "Software"), to deal in the Software without restriction,
/// including without limitation the rights to use, copy, modify, merge,
/// publish, distribute, sublicense, and/or sell copies of the Software,
/// and to permit persons to whom the Software is furnished to do so,
/// subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the
/// next paragraph) shall be included in all copies or substantial
/// portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
/// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
/// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'dart:typed_data';
/// core global object
/// 
/// The core global object.  This is a special singleton object.  It
/// is used for internal Wayland protocol features.
/// 
class Display extends Proxy implements Dispatcher{
  final Context context;

  Display(this.context) : super(context.allocateClientId());

  Future<void> sync() async {
  var callback =  Display(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        callback,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getRegistry() async {
  var registry =  Display(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        registry,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

 /// fatal error event
/// 
/// The error event is sent out when a fatal (non-recoverable)
/// error has occurred.  The object_id argument is the object
/// where the error occurred, most often in response to a request
/// to that object.  The code identifies the error and is defined
/// by the object interface.  As such, each interface defines its
/// own set of error codes.  The message is a brief description
/// of the error, for (debugging) convenience.
/// 
 void onerror(void Function(int objectId, int code, String message) handler) {
   _errorHandler = handler;
 }

 void Function(int objectId, int code, String message)? _errorHandler;

 /// acknowledge object ID deletion
/// 
/// This event is used internally by the object ID management
/// logic. When a client deletes an object that it had created,
/// the server will send this event to acknowledge that it has
/// seen the delete request. When the client receives this event,
/// it will know that it can safely reuse the object ID.
/// 
 void ondeleteId(void Function(int id) handler) {
   _deleteIdHandler = handler;
 }

 void Function(int id)? _deleteIdHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_errorHandler != null) {
         _errorHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           getString(data, 8),
         );
       }
       break;
     case 1:
       if (_deleteIdHandler != null) {
         _deleteIdHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// global error values
/// 
/// These errors are global and can be emitted in response to any
/// server request.
/// 

enum Displayerror {
  /// server couldn't find object
  invalidObject,
  /// method doesn't exist on the specified interface or malformed request
  invalidMethod,
  /// server is out of memory
  noMemory,
  /// implementation error in compositor
  implementation,
}

/// global registry object
/// 
/// The singleton global registry object.  The server has a number of
/// global objects that are available to all clients.  These objects
/// typically represent an actual object in the server (for example,
/// an input device) or they are singleton objects that provide
/// extension functionality.
/// 
/// When a client creates a registry object, the registry object
/// will emit a global event for each global currently in the
/// registry.  Globals come and go as a result of device or
/// monitor hotplugs, reconfiguration or other events, and the
/// registry will send out global and global_remove events to
/// keep the client up to date with the changes.  To mark the end
/// of the initial burst of events, the client can use the
/// wl_display.sync request immediately after calling
/// wl_display.get_registry.
/// 
/// A client can bind to a global object by using the bind
/// request.  This creates a client-side handle that lets the object
/// emit events to the client and lets the client invoke requests on
/// the object.
/// 
class Registry extends Proxy implements Dispatcher{
  final Context context;

  Registry(this.context) : super(context.allocateClientId());

  Future<void> bind(int name) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        name,
        id,
      ],
      [
        WaylandType.uint,
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

 /// announce global object
/// 
/// Notify the client of global objects.
/// 
/// The event notifies the client that a global object with
/// the given name is now available, and it implements the
/// given version of the given interface.
/// 
 void onglobal(void Function(int name, String interface, int version) handler) {
   _globalHandler = handler;
 }

 void Function(int name, String interface, int version)? _globalHandler;

 /// announce removal of global object
/// 
/// Notify the client of removed global objects.
/// 
/// This event notifies the client that the global identified
/// by name is no longer available.  If the client bound to
/// the global using the bind request, the client should now
/// destroy that object.
/// 
/// The object remains valid and requests to the object will be
/// ignored until the client destroys it, to avoid races between
/// the global going away and a client sending a request to it.
/// 
 void onglobalRemove(void Function(int name) handler) {
   _globalRemoveHandler = handler;
 }

 void Function(int name)? _globalRemoveHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_globalHandler != null) {
         _globalHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           getString(data, 4),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 1:
       if (_globalRemoveHandler != null) {
         _globalRemoveHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// callback object
/// 
/// Clients can handle the 'done' event to get notified when
/// the related request is done.
/// 
/// Note, because wl_callback objects are created from multiple independent
/// factory interfaces, the wl_callback interface is frozen at version 1.
/// 
class Callback extends Proxy implements Dispatcher{
  final Context context;

  Callback(this.context) : super(context.allocateClientId());

 /// done event
/// 
/// Notify the client when the related request is done.
/// 
 void ondone(void Function(int callbackData) handler) {
   _doneHandler = handler;
 }

 void Function(int callbackData)? _doneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_doneHandler != null) {
         _doneHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// the compositor singleton
/// 
/// A compositor.  This object is a singleton global.  The
/// compositor is in charge of combining the contents of multiple
/// surfaces into one displayable output.
/// 
class Compositor extends Proxy{
  final Context context;

  Compositor(this.context) : super(context.allocateClientId());

  Future<void> createSurface() async {
  var id =  Compositor(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> createRegion() async {
  var id =  Compositor(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

}

/// a shared memory pool
/// 
/// The wl_shm_pool object encapsulates a piece of memory shared
/// between the compositor and client.  Through the wl_shm_pool
/// object, the client can allocate shared memory wl_buffer objects.
/// All objects created through the same pool share the same
/// underlying mapped memory. Reusing the mapped memory avoids the
/// setup/teardown overhead and is useful when interactively resizing
/// a surface or for many small buffers.
/// 
class ShmPool extends Proxy{
  final Context context;

  ShmPool(this.context) : super(context.allocateClientId());

  Future<void> createBuffer(int offset, int width, int height, int stride, int format) async {
  var id =  ShmPool(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
        offset,
        width,
        height,
        stride,
        format,
      ],
      [
        WaylandType.newId,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> resize(int size) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        size,
      ],
      [
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

}

/// shared memory support
/// 
/// A singleton global object that provides support for shared
/// memory.
/// 
/// Clients can create wl_shm_pool objects using the create_pool
/// request.
/// 
/// On binding the wl_shm object one or more format events
/// are emitted to inform clients about the valid pixel formats
/// that can be used for buffers.
/// 
class Shm extends Proxy implements Dispatcher{
  final Context context;

  Shm(this.context) : super(context.allocateClientId());

  Future<void> createPool(int fd, int size) async {
  var id =  Shm(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
        fd,
        size,
      ],
      [
        WaylandType.newId,
        WaylandType.fd,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// pixel format description
/// 
/// Informs the client about a valid pixel format that
/// can be used for buffers. Known formats include
/// argb8888 and xrgb8888.
/// 
 void onformat(void Function(int format) handler) {
   _formatHandler = handler;
 }

 void Function(int format)? _formatHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_formatHandler != null) {
         _formatHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// wl_shm error values
/// 
/// These errors can be emitted in response to wl_shm requests.
/// 

enum Shmerror {
  /// buffer format is not known
  invalidFormat,
  /// invalid size or stride during pool or buffer creation
  invalidStride,
  /// mmapping the file descriptor failed
  invalidFd,
}

/// pixel formats
/// 
/// This describes the memory layout of an individual pixel.
/// 
/// All renderers should support argb8888 and xrgb8888 but any other
/// formats are optional and may not be supported by the particular
/// renderer in use.
/// 
/// The drm format codes match the macros defined in drm_fourcc.h, except
/// argb8888 and xrgb8888. The formats actually supported by the compositor
/// will be reported by the format event.
/// 
/// For all wl_shm formats and unless specified in another protocol
/// extension, pre-multiplied alpha is used for pixel values.
/// 

enum Shmformat {
  /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
  argb8888,
  /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
  xrgb8888,
  /// 8-bit color index format, [7:0] C
  c8,
  /// 8-bit RGB format, [7:0] R:G:B 3:3:2
  rgb332,
  /// 8-bit BGR format, [7:0] B:G:R 2:3:3
  bgr233,
  /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
  xrgb4444,
  /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
  xbgr4444,
  /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
  rgbx4444,
  /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
  bgrx4444,
  /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
  argb4444,
  /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
  abgr4444,
  /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
  rgba4444,
  /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
  bgra4444,
  /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
  xrgb1555,
  /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
  xbgr1555,
  /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
  rgbx5551,
  /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
  bgrx5551,
  /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
  argb1555,
  /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
  abgr1555,
  /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
  rgba5551,
  /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
  bgra5551,
  /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
  rgb565,
  /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
  bgr565,
  /// 24-bit RGB format, [23:0] R:G:B little endian
  rgb888,
  /// 24-bit BGR format, [23:0] B:G:R little endian
  bgr888,
  /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
  xbgr8888,
  /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
  rgbx8888,
  /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
  bgrx8888,
  /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
  abgr8888,
  /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
  rgba8888,
  /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
  bgra8888,
  /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
  xrgb2101010,
  /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
  xbgr2101010,
  /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
  rgbx1010102,
  /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
  bgrx1010102,
  /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
  argb2101010,
  /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
  abgr2101010,
  /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
  rgba1010102,
  /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
  bgra1010102,
  /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
  yuyv,
  /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
  yvyu,
  /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
  uyvy,
  /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
  vyuy,
  /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
  ayuv,
  /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
  nv12,
  /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
  nv21,
  /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
  nv16,
  /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
  nv61,
  /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
  yuv410,
  /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
  yvu410,
  /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
  yuv411,
  /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
  yvu411,
  /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
  yuv420,
  /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
  yvu420,
  /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
  yuv422,
  /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
  yvu422,
  /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
  yuv444,
  /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
  yvu444,
  /// [7:0] R
  r8,
  /// [15:0] R little endian
  r16,
  /// [15:0] R:G 8:8 little endian
  rg88,
  /// [15:0] G:R 8:8 little endian
  gr88,
  /// [31:0] R:G 16:16 little endian
  rg1616,
  /// [31:0] G:R 16:16 little endian
  gr1616,
  /// [63:0] x:R:G:B 16:16:16:16 little endian
  xrgb16161616f,
  /// [63:0] x:B:G:R 16:16:16:16 little endian
  xbgr16161616f,
  /// [63:0] A:R:G:B 16:16:16:16 little endian
  argb16161616f,
  /// [63:0] A:B:G:R 16:16:16:16 little endian
  abgr16161616f,
  /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
  xyuv8888,
  /// [23:0] Cr:Cb:Y 8:8:8 little endian
  vuy888,
  /// Y followed by U then V, 10:10:10. Non-linear modifier only
  vuy101010,
  /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
  y210,
  /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
  y212,
  /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
  y216,
  /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
  y410,
  /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
  y412,
  /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
  y416,
  /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
  xvyu2101010,
  /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
  xvyu1216161616,
  /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
  xvyu16161616,
  /// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
  y0l0,
  /// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
  x0l0,
  /// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
  y0l2,
  /// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
  x0l2,
  /// 
  yuv4208bit,
  /// 
  yuv42010bit,
  /// 
  xrgb8888A8,
  /// 
  xbgr8888A8,
  /// 
  rgbx8888A8,
  /// 
  bgrx8888A8,
  /// 
  rgb888A8,
  /// 
  bgr888A8,
  /// 
  rgb565A8,
  /// 
  bgr565A8,
  /// non-subsampled Cr:Cb plane
  nv24,
  /// non-subsampled Cb:Cr plane
  nv42,
  /// 2x1 subsampled Cr:Cb plane, 10 bit per channel
  p210,
  /// 2x2 subsampled Cr:Cb plane 10 bits per channel
  p010,
  /// 2x2 subsampled Cr:Cb plane 12 bits per channel
  p012,
  /// 2x2 subsampled Cr:Cb plane 16 bits per channel
  p016,
  /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
  axbxgxrx106106106106,
  /// 2x2 subsampled Cr:Cb plane
  nv15,
  /// 
  q410,
  /// 
  q401,
  /// [63:0] x:R:G:B 16:16:16:16 little endian
  xrgb16161616,
  /// [63:0] x:B:G:R 16:16:16:16 little endian
  xbgr16161616,
  /// [63:0] A:R:G:B 16:16:16:16 little endian
  argb16161616,
  /// [63:0] A:B:G:R 16:16:16:16 little endian
  abgr16161616,
  /// [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
  c1,
  /// [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
  c2,
  /// [7:0] C0:C1 4:4 two pixels/byte
  c4,
  /// [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
  d1,
  /// [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
  d2,
  /// [7:0] D0:D1 4:4 two pixels/byte
  d4,
  /// [7:0] D
  d8,
  /// [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
  r1,
  /// [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
  r2,
  /// [7:0] R0:R1 4:4 two pixels/byte
  r4,
  /// [15:0] x:R 6:10 little endian
  r10,
  /// [15:0] x:R 4:12 little endian
  r12,
  /// [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
  avuy8888,
  /// [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
  xvuy8888,
  /// 2x2 subsampled Cr:Cb plane 10 bits per channel packed
  p030,
}

/// content for a wl_surface
/// 
/// A buffer provides the content for a wl_surface. Buffers are
/// created through factory interfaces such as wl_shm, wp_linux_buffer_params
/// (from the linux-dmabuf protocol extension) or similar. It has a width and
/// a height and can be attached to a wl_surface, but the mechanism by which a
/// client provides and updates the contents is defined by the buffer factory
/// interface.
/// 
/// Color channels are assumed to be electrical rather than optical (in other
/// words, encoded with a transfer function) unless otherwise specified. If
/// the buffer uses a format that has an alpha channel, the alpha channel is
/// assumed to be premultiplied into the electrical color channel values
/// (after transfer function encoding) unless otherwise specified.
/// 
/// Note, because wl_buffer objects are created from multiple independent
/// factory interfaces, the wl_buffer interface is frozen at version 1.
/// 
class Buffer extends Proxy implements Dispatcher{
  final Context context;

  Buffer(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// compositor releases buffer
/// 
/// Sent when this wl_buffer is no longer used by the compositor.
/// The client is now free to reuse or destroy this buffer and its
/// backing storage.
/// 
/// If a client receives a release event before the frame callback
/// requested in the same wl_surface.commit that attaches this
/// wl_buffer to a surface, then the client is immediately free to
/// reuse the buffer and its backing storage, and does not need a
/// second buffer for the next surface content update. Typically
/// this is possible, when the compositor maintains a copy of the
/// wl_surface contents, e.g. as a GL texture. This is an important
/// optimization for GL(ES) compositors with wl_shm clients.
/// 
 void onrelease(void Function() handler) {
   _releaseHandler = handler;
 }

 void Function()? _releaseHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_releaseHandler != null) {
         _releaseHandler!(
         );
       }
       break;
   }
 }
}

/// offer to transfer data
/// 
/// A wl_data_offer represents a piece of data offered for transfer
/// by another client (the source client).  It is used by the
/// copy-and-paste and drag-and-drop mechanisms.  The offer
/// describes the different mime types that the data can be
/// converted to and provides the mechanism for transferring the
/// data directly from the source client.
/// 
class DataOffer extends Proxy implements Dispatcher{
  final Context context;

  DataOffer(this.context) : super(context.allocateClientId());

  Future<void> accept(int serial, String mimeType) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        serial,
        mimeType,
      ],
      [
        WaylandType.uint,
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> receive(String mimeType, int fd) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        mimeType,
        fd,
      ],
      [
        WaylandType.string,
        WaylandType.fd,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> finish() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setActions(int dndActions, int preferredAction) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        dndActions,
        preferredAction,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// advertise offered mime type
/// 
/// Sent immediately after creating the wl_data_offer object.  One
/// event per offered mime type.
/// 
 void onoffer(void Function(String mimeType) handler) {
   _offerHandler = handler;
 }

 void Function(String mimeType)? _offerHandler;

 /// notify the source-side available actions
/// 
/// This event indicates the actions offered by the data source. It
/// will be sent immediately after creating the wl_data_offer object,
/// or anytime the source side changes its offered actions through
/// wl_data_source.set_actions.
/// 
 void onsourceActions(void Function(int sourceActions) handler) {
   _sourceActionsHandler = handler;
 }

 void Function(int sourceActions)? _sourceActionsHandler;

 /// notify the selected action
/// 
/// This event indicates the action selected by the compositor after
/// matching the source/destination side actions. Only one action (or
/// none) will be offered here.
/// 
/// This event can be emitted multiple times during the drag-and-drop
/// operation in response to destination side action changes through
/// wl_data_offer.set_actions.
/// 
/// This event will no longer be emitted after wl_data_device.drop
/// happened on the drag-and-drop destination, the client must
/// honor the last action received, or the last preferred one set
/// through wl_data_offer.set_actions when handling an "ask" action.
/// 
/// Compositors may also change the selected action on the fly, mainly
/// in response to keyboard modifier changes during the drag-and-drop
/// operation.
/// 
/// The most recent action received is always the valid one. Prior to
/// receiving wl_data_device.drop, the chosen action may change (e.g.
/// due to keyboard modifiers being pressed). At the time of receiving
/// wl_data_device.drop the drag-and-drop destination must honor the
/// last action received.
/// 
/// Action changes may still happen after wl_data_device.drop,
/// especially on "ask" actions, where the drag-and-drop destination
/// may choose another action afterwards. Action changes happening
/// at this stage are always the result of inter-client negotiation, the
/// compositor shall no longer be able to induce a different action.
/// 
/// Upon "ask" actions, it is expected that the drag-and-drop destination
/// may potentially choose a different action and/or mime type,
/// based on wl_data_offer.source_actions and finally chosen by the
/// user (e.g. popping up a menu with the available options). The
/// final wl_data_offer.set_actions and wl_data_offer.accept requests
/// must happen before the call to wl_data_offer.finish.
/// 
 void onaction(void Function(int dndAction) handler) {
   _actionHandler = handler;
 }

 void Function(int dndAction)? _actionHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_offerHandler != null) {
         _offerHandler!(
           getString(data, 0),
         );
       }
       break;
     case 1:
       if (_sourceActionsHandler != null) {
         _sourceActionsHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 2:
       if (_actionHandler != null) {
         _actionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum DataOffererror {
  /// finish request was called untimely
  invalidFinish,
  /// action mask contains invalid values
  invalidActionMask,
  /// action argument has an invalid value
  invalidAction,
  /// offer doesn't accept this request
  invalidOffer,
}

/// offer to transfer data
/// 
/// The wl_data_source object is the source side of a wl_data_offer.
/// It is created by the source client in a data transfer and
/// provides a way to describe the offered data and a way to respond
/// to requests to transfer the data.
/// 
class DataSource extends Proxy implements Dispatcher{
  final Context context;

  DataSource(this.context) : super(context.allocateClientId());

  Future<void> offer(String mimeType) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        mimeType,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setActions(int dndActions) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        dndActions,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// a target accepts an offered mime type
/// 
/// Sent when a target accepts pointer_focus or motion events.  If
/// a target does not accept any of the offered types, type is NULL.
/// 
/// Used for feedback during drag-and-drop.
/// 
 void ontarget(void Function(String mimeType) handler) {
   _targetHandler = handler;
 }

 void Function(String mimeType)? _targetHandler;

 /// send the data
/// 
/// Request for data from the client.  Send the data as the
/// specified mime type over the passed file descriptor, then
/// close it.
/// 
 void onsend(void Function(String mimeType, int fd) handler) {
   _sendHandler = handler;
 }

 void Function(String mimeType, int fd)? _sendHandler;

 /// selection was cancelled
/// 
/// This data source is no longer valid. There are several reasons why
/// this could happen:
/// 
/// - The data source has been replaced by another data source.
/// - The drag-and-drop operation was performed, but the drop destination
/// did not accept any of the mime types offered through
/// wl_data_source.target.
/// - The drag-and-drop operation was performed, but the drop destination
/// did not select any of the actions present in the mask offered through
/// wl_data_source.action.
/// - The drag-and-drop operation was performed but didn't happen over a
/// surface.
/// - The compositor cancelled the drag-and-drop operation (e.g. compositor
/// dependent timeouts to avoid stale drag-and-drop transfers).
/// 
/// The client should clean up and destroy this data source.
/// 
/// For objects of version 2 or older, wl_data_source.cancelled will
/// only be emitted if the data source was replaced by another data
/// source.
/// 
 void oncancelled(void Function() handler) {
   _cancelledHandler = handler;
 }

 void Function()? _cancelledHandler;

 /// the drag-and-drop operation physically finished
/// 
/// The user performed the drop action. This event does not indicate
/// acceptance, wl_data_source.cancelled may still be emitted afterwards
/// if the drop destination does not accept any mime type.
/// 
/// However, this event might however not be received if the compositor
/// cancelled the drag-and-drop operation before this event could happen.
/// 
/// Note that the data_source may still be used in the future and should
/// not be destroyed here.
/// 
 void ondndDropPerformed(void Function() handler) {
   _dndDropPerformedHandler = handler;
 }

 void Function()? _dndDropPerformedHandler;

 /// the drag-and-drop operation concluded
/// 
/// The drop destination finished interoperating with this data
/// source, so the client is now free to destroy this data source and
/// free all associated data.
/// 
/// If the action used to perform the operation was "move", the
/// source can now delete the transferred data.
/// 
 void ondndFinished(void Function() handler) {
   _dndFinishedHandler = handler;
 }

 void Function()? _dndFinishedHandler;

 /// notify the selected action
/// 
/// This event indicates the action selected by the compositor after
/// matching the source/destination side actions. Only one action (or
/// none) will be offered here.
/// 
/// This event can be emitted multiple times during the drag-and-drop
/// operation, mainly in response to destination side changes through
/// wl_data_offer.set_actions, and as the data device enters/leaves
/// surfaces.
/// 
/// It is only possible to receive this event after
/// wl_data_source.dnd_drop_performed if the drag-and-drop operation
/// ended in an "ask" action, in which case the final wl_data_source.action
/// event will happen immediately before wl_data_source.dnd_finished.
/// 
/// Compositors may also change the selected action on the fly, mainly
/// in response to keyboard modifier changes during the drag-and-drop
/// operation.
/// 
/// The most recent action received is always the valid one. The chosen
/// action may change alongside negotiation (e.g. an "ask" action can turn
/// into a "move" operation), so the effects of the final action must
/// always be applied in wl_data_offer.dnd_finished.
/// 
/// Clients can trigger cursor surface changes from this point, so
/// they reflect the current action.
/// 
 void onaction(void Function(int dndAction) handler) {
   _actionHandler = handler;
 }

 void Function(int dndAction)? _actionHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_targetHandler != null) {
         _targetHandler!(
           getString(data, 0),
         );
       }
       break;
     case 1:
       if (_sendHandler != null) {
         _sendHandler!(
           getString(data, 0),
           fd,
         );
       }
       break;
     case 2:
       if (_cancelledHandler != null) {
         _cancelledHandler!(
         );
       }
       break;
     case 3:
       if (_dndDropPerformedHandler != null) {
         _dndDropPerformedHandler!(
         );
       }
       break;
     case 4:
       if (_dndFinishedHandler != null) {
         _dndFinishedHandler!(
         );
       }
       break;
     case 5:
       if (_actionHandler != null) {
         _actionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum DataSourceerror {
  /// action mask contains invalid values
  invalidActionMask,
  /// source doesn't accept this request
  invalidSource,
}

/// data transfer device
/// 
/// There is one wl_data_device per seat which can be obtained
/// from the global wl_data_device_manager singleton.
/// 
/// A wl_data_device provides access to inter-client data transfer
/// mechanisms such as copy-and-paste and drag-and-drop.
/// 
class DataDevice extends Proxy implements Dispatcher{
  final Context context;

  DataDevice(this.context) : super(context.allocateClientId());

  Future<void> startDrag(DataSource source, Surface origin, Surface icon, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        source,
        origin,
        icon,
        serial,
      ],
      [
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setSelection(DataSource source, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        source,
        serial,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// introduce a new wl_data_offer
/// 
/// The data_offer event introduces a new wl_data_offer object,
/// which will subsequently be used in either the
/// data_device.enter event (for drag-and-drop) or the
/// data_device.selection event (for selections).  Immediately
/// following the data_device.data_offer event, the new data_offer
/// object will send out data_offer.offer events to describe the
/// mime types it offers.
/// 
 void ondataOffer(void Function(int id) handler) {
   _dataOfferHandler = handler;
 }

 void Function(int id)? _dataOfferHandler;

 /// initiate drag-and-drop session
/// 
/// This event is sent when an active drag-and-drop pointer enters
/// a surface owned by the client.  The position of the pointer at
/// enter time is provided by the x and y arguments, in surface-local
/// coordinates.
/// 
 void onenter(void Function(int serial, int surface, double x, double y, int id) handler) {
   _enterHandler = handler;
 }

 void Function(int serial, int surface, double x, double y, int id)? _enterHandler;

 /// end drag-and-drop session
/// 
/// This event is sent when the drag-and-drop pointer leaves the
/// surface and the session ends.  The client must destroy the
/// wl_data_offer introduced at enter time at this point.
/// 
 void onleave(void Function() handler) {
   _leaveHandler = handler;
 }

 void Function()? _leaveHandler;

 /// drag-and-drop session motion
/// 
/// This event is sent when the drag-and-drop pointer moves within
/// the currently focused surface. The new position of the pointer
/// is provided by the x and y arguments, in surface-local
/// coordinates.
/// 
 void onmotion(void Function(int time, double x, double y) handler) {
   _motionHandler = handler;
 }

 void Function(int time, double x, double y)? _motionHandler;

 /// end drag-and-drop session successfully
/// 
/// The event is sent when a drag-and-drop operation is ended
/// because the implicit grab is removed.
/// 
/// The drag-and-drop destination is expected to honor the last action
/// received through wl_data_offer.action, if the resulting action is
/// "copy" or "move", the destination can still perform
/// wl_data_offer.receive requests, and is expected to end all
/// transfers with a wl_data_offer.finish request.
/// 
/// If the resulting action is "ask", the action will not be considered
/// final. The drag-and-drop destination is expected to perform one last
/// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
/// to cancel the operation.
/// 
 void ondrop(void Function() handler) {
   _dropHandler = handler;
 }

 void Function()? _dropHandler;

 /// advertise new selection
/// 
/// The selection event is sent out to notify the client of a new
/// wl_data_offer for the selection for this device.  The
/// data_device.data_offer and the data_offer.offer events are
/// sent out immediately before this event to introduce the data
/// offer object.  The selection event is sent to a client
/// immediately before receiving keyboard focus and when a new
/// selection is set while the client has keyboard focus.  The
/// data_offer is valid until a new data_offer or NULL is received
/// or until the client loses keyboard focus.  Switching surface with
/// keyboard focus within the same client doesn't mean a new selection
/// will be sent.  The client must destroy the previous selection
/// data_offer, if any, upon receiving this event.
/// 
 void onselection(void Function(int id) handler) {
   _selectionHandler = handler;
 }

 void Function(int id)? _selectionHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_dataOfferHandler != null) {
         _dataOfferHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_enterHandler != null) {
         _enterHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(12, Endian.host)),
           context.getProxy(ByteData.view(data.buffer).getUint32(16, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_leaveHandler != null) {
         _leaveHandler!(
         );
       }
       break;
     case 3:
       if (_motionHandler != null) {
         _motionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
         );
       }
       break;
     case 4:
       if (_dropHandler != null) {
         _dropHandler!(
         );
       }
       break;
     case 5:
       if (_selectionHandler != null) {
         _selectionHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
   }
 }
}

/// 
/// 

enum DataDeviceerror {
  /// given wl_surface has another role
  role,
  /// source has already been used
  usedSource,
}

/// data transfer interface
/// 
/// The wl_data_device_manager is a singleton global object that
/// provides access to inter-client data transfer mechanisms such as
/// copy-and-paste and drag-and-drop.  These mechanisms are tied to
/// a wl_seat and this interface lets a client get a wl_data_device
/// corresponding to a wl_seat.
/// 
/// Depending on the version bound, the objects created from the bound
/// wl_data_device_manager object will have different requirements for
/// functioning properly. See wl_data_source.set_actions,
/// wl_data_offer.accept and wl_data_offer.finish for details.
/// 
class DataDeviceManager extends Proxy{
  final Context context;

  DataDeviceManager(this.context) : super(context.allocateClientId());

  Future<void> createDataSource() async {
  var id =  DataDeviceManager(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getDataDevice(Seat seat) async {
  var id =  DataDeviceManager(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        seat,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// drag and drop actions
/// 
/// This is a bitmask of the available/preferred actions in a
/// drag-and-drop operation.
/// 
/// In the compositor, the selected action is a result of matching the
/// actions offered by the source and destination sides.  "action" events
/// with a "none" action will be sent to both source and destination if
/// there is no match. All further checks will effectively happen on
/// (source actions ∩ destination actions).
/// 
/// In addition, compositors may also pick different actions in
/// reaction to key modifiers being pressed. One common design that
/// is used in major toolkits (and the behavior recommended for
/// compositors) is:
/// 
/// - If no modifiers are pressed, the first match (in bit order)
/// will be used.
/// - Pressing Shift selects "move", if enabled in the mask.
/// - Pressing Control selects "copy", if enabled in the mask.
/// 
/// Behavior beyond that is considered implementation-dependent.
/// Compositors may for example bind other modifiers (like Alt/Meta)
/// or drags initiated with other buttons than BTN_LEFT to specific
/// actions (e.g. "ask").
/// 

enum DataDeviceManagerdndAction {
  /// no action
  none,
  /// copy action
  copy,
  /// move action
  move,
  /// ask action
  ask,
}

/// create desktop-style surfaces
/// 
/// This interface is implemented by servers that provide
/// desktop-style user interfaces.
/// 
/// It allows clients to associate a wl_shell_surface with
/// a basic surface.
/// 
/// Note! This protocol is deprecated and not intended for production use.
/// For desktop-style user interfaces, use xdg_shell. Compositors and clients
/// should not implement this interface.
/// 
class Shell extends Proxy{
  final Context context;

  Shell(this.context) : super(context.allocateClientId());

  Future<void> getShellSurface(Surface surface) async {
  var id =  Shell(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum Shellerror {
  /// given wl_surface has another role
  role,
}

/// desktop-style metadata interface
/// 
/// An interface that may be implemented by a wl_surface, for
/// implementations that provide a desktop-style user interface.
/// 
/// It provides requests to treat surfaces like toplevel, fullscreen
/// or popup windows, move, resize or maximize them, associate
/// metadata like title and class, etc.
/// 
/// On the server side the object is automatically destroyed when
/// the related wl_surface is destroyed. On the client side,
/// wl_shell_surface_destroy() must be called before destroying
/// the wl_surface object.
/// 
class ShellSurface extends Proxy implements Dispatcher{
  final Context context;

  ShellSurface(this.context) : super(context.allocateClientId());

  Future<void> pong(int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        serial,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> move(Seat seat, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        seat,
        serial,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> resize(Seat seat, int serial, int edges) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        seat,
        serial,
        edges,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setToplevel() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setTransient(Surface parent, int x, int y, int flags) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        parent,
        x,
        y,
        flags,
      ],
      [
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setFullscreen(int method, int framerate, Output output) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      5,
      [
        method,
        framerate,
        output,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setPopup(Seat seat, int serial, Surface parent, int x, int y, int flags) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      6,
      [
        seat,
        serial,
        parent,
        x,
        y,
        flags,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setMaximized(Output output) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      7,
      [
        output,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setTitle(String title) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      8,
      [
        title,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setClass(String clazz) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      9,
      [
        clazz,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

 /// ping client
/// 
/// Ping a client to check if it is receiving events and sending
/// requests. A client is expected to reply with a pong request.
/// 
 void onping(void Function(int serial) handler) {
   _pingHandler = handler;
 }

 void Function(int serial)? _pingHandler;

 /// suggest resize
/// 
/// The configure event asks the client to resize its surface.
/// 
/// The size is a hint, in the sense that the client is free to
/// ignore it if it doesn't resize, pick a smaller size (to
/// satisfy aspect ratio or resize in steps of NxM pixels).
/// 
/// The edges parameter provides a hint about how the surface
/// was resized. The client may use this information to decide
/// how to adjust its content to the new size (e.g. a scrolling
/// area might adjust its content position to leave the viewable
/// content unmoved).
/// 
/// The client is free to dismiss all but the last configure
/// event it received.
/// 
/// The width and height arguments specify the size of the window
/// in surface-local coordinates.
/// 
 void onconfigure(void Function(int edges, int width, int height) handler) {
   _configureHandler = handler;
 }

 void Function(int edges, int width, int height)? _configureHandler;

 /// popup interaction is done
/// 
/// The popup_done event is sent out when a popup grab is broken,
/// that is, when the user clicks a surface that doesn't belong
/// to the client owning the popup surface.
/// 
 void onpopupDone(void Function() handler) {
   _popupDoneHandler = handler;
 }

 void Function()? _popupDoneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_pingHandler != null) {
         _pingHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_configureHandler != null) {
         _configureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 2:
       if (_popupDoneHandler != null) {
         _popupDoneHandler!(
         );
       }
       break;
   }
 }
}

/// edge values for resizing
/// 
/// These values are used to indicate which edge of a surface
/// is being dragged in a resize operation. The server may
/// use this information to adapt its behavior, e.g. choose
/// an appropriate cursor image.
/// 

enum ShellSurfaceresize {
  /// no edge
  none,
  /// top edge
  top,
  /// bottom edge
  bottom,
  /// left edge
  left,
  /// top and left edges
  topLeft,
  /// bottom and left edges
  bottomLeft,
  /// right edge
  right,
  /// top and right edges
  topRight,
  /// bottom and right edges
  bottomRight,
}

/// details of transient behaviour
/// 
/// These flags specify details of the expected behaviour
/// of transient surfaces. Used in the set_transient request.
/// 

enum ShellSurfacetransient {
  /// do not set keyboard focus
  inactive,
}

/// different method to set the surface fullscreen
/// 
/// Hints to indicate to the compositor how to deal with a conflict
/// between the dimensions of the surface and the dimensions of the
/// output. The compositor is free to ignore this parameter.
/// 

enum ShellSurfacefullscreenMethod {
  /// no preference, apply default policy
  defaulted,
  /// scale, preserve the surface's aspect ratio and center on output
  scale,
  /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
  driver,
  /// no upscaling, center on output and add black borders to compensate size mismatch
  fill,
}

/// an onscreen surface
/// 
/// A surface is a rectangular area that may be displayed on zero
/// or more outputs, and shown any number of times at the compositor's
/// discretion. They can present wl_buffers, receive user input, and
/// define a local coordinate system.
/// 
/// The size of a surface (and relative positions on it) is described
/// in surface-local coordinates, which may differ from the buffer
/// coordinates of the pixel content, in case a buffer_transform
/// or a buffer_scale is used.
/// 
/// A surface without a "role" is fairly useless: a compositor does
/// not know where, when or how to present it. The role is the
/// purpose of a wl_surface. Examples of roles are a cursor for a
/// pointer (as set by wl_pointer.set_cursor), a drag icon
/// (wl_data_device.start_drag), a sub-surface
/// (wl_subcompositor.get_subsurface), and a window as defined by a
/// shell protocol (e.g. wl_shell.get_shell_surface).
/// 
/// A surface can have only one role at a time. Initially a
/// wl_surface does not have a role. Once a wl_surface is given a
/// role, it is set permanently for the whole lifetime of the
/// wl_surface object. Giving the current role again is allowed,
/// unless explicitly forbidden by the relevant interface
/// specification.
/// 
/// Surface roles are given by requests in other interfaces such as
/// wl_pointer.set_cursor. The request should explicitly mention
/// that this request gives a role to a wl_surface. Often, this
/// request also creates a new protocol object that represents the
/// role and adds additional functionality to wl_surface. When a
/// client wants to destroy a wl_surface, they must destroy this role
/// object before the wl_surface, otherwise a defunct_role_object error is
/// sent.
/// 
/// Destroying the role object does not remove the role from the
/// wl_surface, but it may stop the wl_surface from "playing the role".
/// For instance, if a wl_subsurface object is destroyed, the wl_surface
/// it was created for will be unmapped and forget its position and
/// z-order. It is allowed to create a wl_subsurface for the same
/// wl_surface again, but it is not allowed to use the wl_surface as
/// a cursor (cursor is a different role than sub-surface, and role
/// switching is not allowed).
/// 
class Surface extends Proxy implements Dispatcher{
  final Context context;

  Surface(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> attach(Buffer buffer, int x, int y) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        buffer,
        x,
        y,
      ],
      [
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> damage(int x, int y, int width, int height) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        x,
        y,
        width,
        height,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> frame() async {
  var callback =  Surface(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        callback,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setOpaqueRegion(Region region) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setInputRegion(Region region) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      5,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> commit() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      6,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setBufferTransform(int transform) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      7,
      [
        transform,
      ],
      [
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setBufferScale(int scale) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      8,
      [
        scale,
      ],
      [
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> damageBuffer(int x, int y, int width, int height) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      9,
      [
        x,
        y,
        width,
        height,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> offset(int x, int y) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      10,
      [
        x,
        y,
      ],
      [
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

 /// surface enters an output
/// 
/// This is emitted whenever a surface's creation, movement, or resizing
/// results in some part of it being within the scanout region of an
/// output.
/// 
/// Note that a surface may be overlapping with zero or more outputs.
/// 
 void onenter(void Function(int output) handler) {
   _enterHandler = handler;
 }

 void Function(int output)? _enterHandler;

 /// surface leaves an output
/// 
/// This is emitted whenever a surface's creation, movement, or resizing
/// results in it no longer having any part of it within the scanout region
/// of an output.
/// 
/// Clients should not use the number of outputs the surface is on for frame
/// throttling purposes. The surface might be hidden even if no leave event
/// has been sent, and the compositor might expect new surface content
/// updates even if no enter event has been sent. The frame event should be
/// used instead.
/// 
 void onleave(void Function(int output) handler) {
   _leaveHandler = handler;
 }

 void Function(int output)? _leaveHandler;

 /// preferred buffer scale for the surface
/// 
/// This event indicates the preferred buffer scale for this surface. It is
/// sent whenever the compositor's preference changes.
/// 
/// Before receiving this event the preferred buffer scale for this surface
/// is 1.
/// 
/// It is intended that scaling aware clients use this event to scale their
/// content and use wl_surface.set_buffer_scale to indicate the scale they
/// have rendered with. This allows clients to supply a higher detail
/// buffer.
/// 
/// The compositor shall emit a scale value greater than 0.
/// 
 void onpreferredBufferScale(void Function(int factor) handler) {
   _preferredBufferScaleHandler = handler;
 }

 void Function(int factor)? _preferredBufferScaleHandler;

 /// preferred buffer transform for the surface
/// 
/// This event indicates the preferred buffer transform for this surface.
/// It is sent whenever the compositor's preference changes.
/// 
/// Before receiving this event the preferred buffer transform for this
/// surface is normal.
/// 
/// Applying this transformation to the surface buffer contents and using
/// wl_surface.set_buffer_transform might allow the compositor to use the
/// surface buffer more efficiently.
/// 
 void onpreferredBufferTransform(void Function(int transform) handler) {
   _preferredBufferTransformHandler = handler;
 }

 void Function(int transform)? _preferredBufferTransformHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_enterHandler != null) {
         _enterHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_leaveHandler != null) {
         _leaveHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_preferredBufferScaleHandler != null) {
         _preferredBufferScaleHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 3:
       if (_preferredBufferTransformHandler != null) {
         _preferredBufferTransformHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// wl_surface error values
/// 
/// These errors can be emitted in response to wl_surface requests.
/// 

enum Surfaceerror {
  /// buffer scale value is invalid
  invalidScale,
  /// buffer transform value is invalid
  invalidTransform,
  /// buffer size is invalid
  invalidSize,
  /// buffer offset is invalid
  invalidOffset,
  /// surface was destroyed before its role object
  defunctRoleObject,
}

/// group of input devices
/// 
/// A seat is a group of keyboards, pointer and touch devices. This
/// object is published as a global during start up, or when such a
/// device is hot plugged.  A seat typically has a pointer and
/// maintains a keyboard focus and a pointer focus.
/// 
class Seat extends Proxy implements Dispatcher{
  final Context context;

  Seat(this.context) : super(context.allocateClientId());

  Future<void> getPointer() async {
  var id =  Seat(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getKeyboard() async {
  var id =  Seat(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getTouch() async {
  var id =  Seat(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// seat capabilities changed
/// 
/// This is emitted whenever a seat gains or loses the pointer,
/// keyboard or touch capabilities.  The argument is a capability
/// enum containing the complete set of capabilities this seat has.
/// 
/// When the pointer capability is added, a client may create a
/// wl_pointer object using the wl_seat.get_pointer request. This object
/// will receive pointer events until the capability is removed in the
/// future.
/// 
/// When the pointer capability is removed, a client should destroy the
/// wl_pointer objects associated with the seat where the capability was
/// removed, using the wl_pointer.release request. No further pointer
/// events will be received on these objects.
/// 
/// In some compositors, if a seat regains the pointer capability and a
/// client has a previously obtained wl_pointer object of version 4 or
/// less, that object may start sending pointer events again. This
/// behavior is considered a misinterpretation of the intended behavior
/// and must not be relied upon by the client. wl_pointer objects of
/// version 5 or later must not send events if created before the most
/// recent event notifying the client of an added pointer capability.
/// 
/// The above behavior also applies to wl_keyboard and wl_touch with the
/// keyboard and touch capabilities, respectively.
/// 
 void oncapabilities(void Function(int capabilities) handler) {
   _capabilitiesHandler = handler;
 }

 void Function(int capabilities)? _capabilitiesHandler;

 /// unique identifier for this seat
/// 
/// In a multi-seat configuration the seat name can be used by clients to
/// help identify which physical devices the seat represents.
/// 
/// The seat name is a UTF-8 string with no convention defined for its
/// contents. Each name is unique among all wl_seat globals. The name is
/// only guaranteed to be unique for the current compositor instance.
/// 
/// The same seat names are used for all clients. Thus, the name can be
/// shared across processes to refer to a specific wl_seat global.
/// 
/// The name event is sent after binding to the seat global. This event is
/// only sent once per seat object, and the name does not change over the
/// lifetime of the wl_seat global.
/// 
/// Compositors may re-use the same seat name if the wl_seat global is
/// destroyed and re-created later.
/// 
 void onname(void Function(String name) handler) {
   _nameHandler = handler;
 }

 void Function(String name)? _nameHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_capabilitiesHandler != null) {
         _capabilitiesHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_nameHandler != null) {
         _nameHandler!(
           getString(data, 0),
         );
       }
       break;
   }
 }
}

/// seat capability bitmask
/// 
/// This is a bitmask of capabilities this seat has; if a member is
/// set, then it is present on the seat.
/// 

enum Seatcapability {
  /// the seat has pointer devices
  pointer,
  /// the seat has one or more keyboards
  keyboard,
  /// the seat has touch devices
  touch,
}

/// wl_seat error values
/// 
/// These errors can be emitted in response to wl_seat requests.
/// 

enum Seaterror {
  /// get_pointer, get_keyboard or get_touch called on seat without the matching capability
  missingCapability,
}

/// pointer input device
/// 
/// The wl_pointer interface represents one or more input devices,
/// such as mice, which control the pointer location and pointer_focus
/// of a seat.
/// 
/// The wl_pointer interface generates motion, enter and leave
/// events for the surfaces that the pointer is located over,
/// and button and axis events for button presses, button releases
/// and scrolling.
/// 
class Pointer extends Proxy implements Dispatcher{
  final Context context;

  Pointer(this.context) : super(context.allocateClientId());

  Future<void> setCursor(int serial, Surface surface, int hotspotX, int hotspotY) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        serial,
        surface,
        hotspotX,
        hotspotY,
      ],
      [
        WaylandType.uint,
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// enter event
/// 
/// Notification that this seat's pointer is focused on a certain
/// surface.
/// 
/// When a seat's focus enters a surface, the pointer image
/// is undefined and a client should respond to this event by setting
/// an appropriate pointer image with the set_cursor request.
/// 
 void onenter(void Function(int serial, int surface, double surfaceX, double surfaceY) handler) {
   _enterHandler = handler;
 }

 void Function(int serial, int surface, double surfaceX, double surfaceY)? _enterHandler;

 /// leave event
/// 
/// Notification that this seat's pointer is no longer focused on
/// a certain surface.
/// 
/// The leave notification is sent before the enter notification
/// for the new focus.
/// 
 void onleave(void Function(int serial, int surface) handler) {
   _leaveHandler = handler;
 }

 void Function(int serial, int surface)? _leaveHandler;

 /// pointer motion event
/// 
/// Notification of pointer location change. The arguments
/// surface_x and surface_y are the location relative to the
/// focused surface.
/// 
 void onmotion(void Function(int time, double surfaceX, double surfaceY) handler) {
   _motionHandler = handler;
 }

 void Function(int time, double surfaceX, double surfaceY)? _motionHandler;

 /// pointer button event
/// 
/// Mouse button click and release notifications.
/// 
/// The location of the click is given by the last motion or
/// enter event.
/// The time argument is a timestamp with millisecond
/// granularity, with an undefined base.
/// 
/// The button is a button code as defined in the Linux kernel's
/// linux/input-event-codes.h header file, e.g. BTN_LEFT.
/// 
/// Any 16-bit button code value is reserved for future additions to the
/// kernel's event code list. All other button codes above 0xFFFF are
/// currently undefined but may be used in future versions of this
/// protocol.
/// 
 void onbutton(void Function(int serial, int time, int button, int state) handler) {
   _buttonHandler = handler;
 }

 void Function(int serial, int time, int button, int state)? _buttonHandler;

 /// axis event
/// 
/// Scroll and other axis notifications.
/// 
/// For scroll events (vertical and horizontal scroll axes), the
/// value parameter is the length of a vector along the specified
/// axis in a coordinate space identical to those of motion events,
/// representing a relative movement along the specified axis.
/// 
/// For devices that support movements non-parallel to axes multiple
/// axis events will be emitted.
/// 
/// When applicable, for example for touch pads, the server can
/// choose to emit scroll events where the motion vector is
/// equivalent to a motion event vector.
/// 
/// When applicable, a client can transform its content relative to the
/// scroll distance.
/// 
 void onaxis(void Function(int time, int axis, double value) handler) {
   _axisHandler = handler;
 }

 void Function(int time, int axis, double value)? _axisHandler;

 /// end of a pointer event sequence
/// 
/// Indicates the end of a set of events that logically belong together.
/// A client is expected to accumulate the data in all events within the
/// frame before proceeding.
/// 
/// All wl_pointer events before a wl_pointer.frame event belong
/// logically together. For example, in a diagonal scroll motion the
/// compositor will send an optional wl_pointer.axis_source event, two
/// wl_pointer.axis events (horizontal and vertical) and finally a
/// wl_pointer.frame event. The client may use this information to
/// calculate a diagonal vector for scrolling.
/// 
/// When multiple wl_pointer.axis events occur within the same frame,
/// the motion vector is the combined motion of all events.
/// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
/// the same frame, this indicates that axis movement in one axis has
/// stopped but continues in the other axis.
/// When multiple wl_pointer.axis_stop events occur within the same
/// frame, this indicates that these axes stopped in the same instance.
/// 
/// A wl_pointer.frame event is sent for every logical event group,
/// even if the group only contains a single wl_pointer event.
/// Specifically, a client may get a sequence: motion, frame, button,
/// frame, axis, frame, axis_stop, frame.
/// 
/// The wl_pointer.enter and wl_pointer.leave events are logical events
/// generated by the compositor and not the hardware. These events are
/// also grouped by a wl_pointer.frame. When a pointer moves from one
/// surface to another, a compositor should group the
/// wl_pointer.leave event within the same wl_pointer.frame.
/// However, a client must not rely on wl_pointer.leave and
/// wl_pointer.enter being in the same wl_pointer.frame.
/// Compositor-specific policies may require the wl_pointer.leave and
/// wl_pointer.enter event being split across multiple wl_pointer.frame
/// groups.
/// 
 void onframe(void Function() handler) {
   _frameHandler = handler;
 }

 void Function()? _frameHandler;

 /// axis source event
/// 
/// Source information for scroll and other axes.
/// 
/// This event does not occur on its own. It is sent before a
/// wl_pointer.frame event and carries the source information for
/// all events within that frame.
/// 
/// The source specifies how this event was generated. If the source is
/// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
/// sent when the user lifts the finger off the device.
/// 
/// If the source is wl_pointer.axis_source.wheel,
/// wl_pointer.axis_source.wheel_tilt or
/// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
/// or may not be sent. Whether a compositor sends an axis_stop event
/// for these sources is hardware-specific and implementation-dependent;
/// clients must not rely on receiving an axis_stop event for these
/// scroll sources and should treat scroll sequences from these scroll
/// sources as unterminated by default.
/// 
/// This event is optional. If the source is unknown for a particular
/// axis event sequence, no event is sent.
/// Only one wl_pointer.axis_source event is permitted per frame.
/// 
/// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
/// not guaranteed.
/// 
 void onaxisSource(void Function(int axisSource) handler) {
   _axisSourceHandler = handler;
 }

 void Function(int axisSource)? _axisSourceHandler;

 /// axis stop event
/// 
/// Stop notification for scroll and other axes.
/// 
/// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
/// is sent to notify a client that the axis sequence has terminated.
/// This enables the client to implement kinetic scrolling.
/// See the wl_pointer.axis_source documentation for information on when
/// this event may be generated.
/// 
/// Any wl_pointer.axis events with the same axis_source after this
/// event should be considered as the start of a new axis motion.
/// 
/// The timestamp is to be interpreted identical to the timestamp in the
/// wl_pointer.axis event. The timestamp value may be the same as a
/// preceding wl_pointer.axis event.
/// 
 void onaxisStop(void Function(int time, int axis) handler) {
   _axisStopHandler = handler;
 }

 void Function(int time, int axis)? _axisStopHandler;

 /// axis click event
/// 
/// Discrete step information for scroll and other axes.
/// 
/// This event carries the axis value of the wl_pointer.axis event in
/// discrete steps (e.g. mouse wheel clicks).
/// 
/// This event is deprecated with wl_pointer version 8 - this event is not
/// sent to clients supporting version 8 or later.
/// 
/// This event does not occur on its own, it is coupled with a
/// wl_pointer.axis event that represents this axis value on a
/// continuous scale. The protocol guarantees that each axis_discrete
/// event is always followed by exactly one axis event with the same
/// axis number within the same wl_pointer.frame. Note that the protocol
/// allows for other events to occur between the axis_discrete and
/// its coupled axis event, including other axis_discrete or axis
/// events. A wl_pointer.frame must not contain more than one axis_discrete
/// event per axis type.
/// 
/// This event is optional; continuous scrolling devices
/// like two-finger scrolling on touchpads do not have discrete
/// steps and do not generate this event.
/// 
/// The discrete value carries the directional information. e.g. a value
/// of -2 is two steps towards the negative direction of this axis.
/// 
/// The axis number is identical to the axis number in the associated
/// axis event.
/// 
/// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
/// not guaranteed.
/// 
 void onaxisDiscrete(void Function(int axis, int discrete) handler) {
   _axisDiscreteHandler = handler;
 }

 void Function(int axis, int discrete)? _axisDiscreteHandler;

 /// axis high-resolution scroll event
/// 
/// Discrete high-resolution scroll information.
/// 
/// This event carries high-resolution wheel scroll information,
/// with each multiple of 120 representing one logical scroll step
/// (a wheel detent). For example, an axis_value120 of 30 is one quarter of
/// a logical scroll step in the positive direction, a value120 of
/// -240 are two logical scroll steps in the negative direction within the
/// same hardware event.
/// Clients that rely on discrete scrolling should accumulate the
/// value120 to multiples of 120 before processing the event.
/// 
/// The value120 must not be zero.
/// 
/// This event replaces the wl_pointer.axis_discrete event in clients
/// supporting wl_pointer version 8 or later.
/// 
/// Where a wl_pointer.axis_source event occurs in the same
/// wl_pointer.frame, the axis source applies to this event.
/// 
/// The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
/// not guaranteed.
/// 
 void onaxisValue120(void Function(int axis, int value120) handler) {
   _axisValue120Handler = handler;
 }

 void Function(int axis, int value120)? _axisValue120Handler;

 /// axis relative physical direction event
/// 
/// Relative directional information of the entity causing the axis
/// motion.
/// 
/// For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
/// event specifies the movement direction of the entity causing the
/// wl_pointer.axis event. For example:
/// - if a user's fingers on a touchpad move down and this
/// causes a wl_pointer.axis vertical_scroll down event, the physical
/// direction is 'identical'
/// - if a user's fingers on a touchpad move down and this causes a
/// wl_pointer.axis vertical_scroll up scroll up event ('natural
/// scrolling'), the physical direction is 'inverted'.
/// 
/// A client may use this information to adjust scroll motion of
/// components. Specifically, enabling natural scrolling causes the
/// content to change direction compared to traditional scrolling.
/// Some widgets like volume control sliders should usually match the
/// physical direction regardless of whether natural scrolling is
/// active. This event enables clients to match the scroll direction of
/// a widget to the physical direction.
/// 
/// This event does not occur on its own, it is coupled with a
/// wl_pointer.axis event that represents this axis value.
/// The protocol guarantees that each axis_relative_direction event is
/// always followed by exactly one axis event with the same
/// axis number within the same wl_pointer.frame. Note that the protocol
/// allows for other events to occur between the axis_relative_direction
/// and its coupled axis event.
/// 
/// The axis number is identical to the axis number in the associated
/// axis event.
/// 
/// The order of wl_pointer.axis_relative_direction,
/// wl_pointer.axis_discrete and wl_pointer.axis_source is not
/// guaranteed.
/// 
 void onaxisRelativeDirection(void Function(int axis, int direction) handler) {
   _axisRelativeDirectionHandler = handler;
 }

 void Function(int axis, int direction)? _axisRelativeDirectionHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_enterHandler != null) {
         _enterHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(12, Endian.host)),
         );
       }
       break;
     case 1:
       if (_leaveHandler != null) {
         _leaveHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_motionHandler != null) {
         _motionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
         );
       }
       break;
     case 3:
       if (_buttonHandler != null) {
         _buttonHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 4:
       if (_axisHandler != null) {
         _axisHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
         );
       }
       break;
     case 5:
       if (_frameHandler != null) {
         _frameHandler!(
         );
       }
       break;
     case 6:
       if (_axisSourceHandler != null) {
         _axisSourceHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 7:
       if (_axisStopHandler != null) {
         _axisStopHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 8:
       if (_axisDiscreteHandler != null) {
         _axisDiscreteHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 9:
       if (_axisValue120Handler != null) {
         _axisValue120Handler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 10:
       if (_axisRelativeDirectionHandler != null) {
         _axisRelativeDirectionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum Pointererror {
  /// given wl_surface has another role
  role,
}

/// physical button state
/// 
/// Describes the physical state of a button that produced the button
/// event.
/// 

enum PointerbuttonState {
  /// the button is not pressed
  released,
  /// the button is pressed
  pressed,
}

/// axis types
/// 
/// Describes the axis types of scroll events.
/// 

enum Pointeraxis {
  /// vertical axis
  verticalScroll,
  /// horizontal axis
  horizontalScroll,
}

/// axis source types
/// 
/// Describes the source types for axis events. This indicates to the
/// client how an axis event was physically generated; a client may
/// adjust the user interface accordingly. For example, scroll events
/// from a "finger" source may be in a smooth coordinate space with
/// kinetic scrolling whereas a "wheel" source may be in discrete steps
/// of a number of lines.
/// 
/// The "continuous" axis source is a device generating events in a
/// continuous coordinate space, but using something other than a
/// finger. One example for this source is button-based scrolling where
/// the vertical motion of a device is converted to scroll events while
/// a button is held down.
/// 
/// The "wheel tilt" axis source indicates that the actual device is a
/// wheel but the scroll event is not caused by a rotation but a
/// (usually sideways) tilt of the wheel.
/// 

enum PointeraxisSource {
  /// a physical wheel rotation
  wheel,
  /// finger on a touch surface
  finger,
  /// continuous coordinate space
  continuous,
  /// a physical wheel tilt
  wheelTilt,
}

/// axis relative direction
/// 
/// This specifies the direction of the physical motion that caused a
/// wl_pointer.axis event, relative to the wl_pointer.axis direction.
/// 

enum PointeraxisRelativeDirection {
  /// physical motion matches axis direction
  identical,
  /// physical motion is the inverse of the axis direction
  inverted,
}

/// keyboard input device
/// 
/// The wl_keyboard interface represents one or more keyboards
/// associated with a seat.
/// 
/// Each wl_keyboard has the following logical state:
/// 
/// - an active surface (possibly null),
/// - the keys currently logically down,
/// - the active modifiers,
/// - the active group.
/// 
/// By default, the active surface is null, the keys currently logically down
/// are empty, the active modifiers and the active group are 0.
/// 
class Keyboard extends Proxy implements Dispatcher{
  final Context context;

  Keyboard(this.context) : super(context.allocateClientId());

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// keyboard mapping
/// 
/// This event provides a file descriptor to the client which can be
/// memory-mapped in read-only mode to provide a keyboard mapping
/// description.
/// 
/// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
/// the recipient, as MAP_SHARED may fail.
/// 
 void onkeymap(void Function(int format, int fd, int size) handler) {
   _keymapHandler = handler;
 }

 void Function(int format, int fd, int size)? _keymapHandler;

 /// enter event
/// 
/// Notification that this seat's keyboard focus is on a certain
/// surface.
/// 
/// The compositor must send the wl_keyboard.modifiers event after this
/// event.
/// 
/// In the wl_keyboard logical state, this event sets the active surface to
/// the surface argument and the keys currently logically down to the keys
/// in the keys argument. The compositor must not send this event if the
/// wl_keyboard already had an active surface immediately before this event.
/// 
 void onenter(void Function(int serial, int surface, List<int> keys) handler) {
   _enterHandler = handler;
 }

 void Function(int serial, int surface, List<int> keys)? _enterHandler;

 /// leave event
/// 
/// Notification that this seat's keyboard focus is no longer on
/// a certain surface.
/// 
/// The leave notification is sent before the enter notification
/// for the new focus.
/// 
/// In the wl_keyboard logical state, this event resets all values to their
/// defaults. The compositor must not send this event if the active surface
/// of the wl_keyboard was not equal to the surface argument immediately
/// before this event.
/// 
 void onleave(void Function(int serial, int surface) handler) {
   _leaveHandler = handler;
 }

 void Function(int serial, int surface)? _leaveHandler;

 /// key event
/// 
/// A key was pressed or released.
/// The time argument is a timestamp with millisecond
/// granularity, with an undefined base.
/// 
/// The key is a platform-specific key code that can be interpreted
/// by feeding it to the keyboard mapping (see the keymap event).
/// 
/// If this event produces a change in modifiers, then the resulting
/// wl_keyboard.modifiers event must be sent after this event.
/// 
/// In the wl_keyboard logical state, this event adds the key to the keys
/// currently logically down (if the state argument is pressed) or removes
/// the key from the keys currently logically down (if the state argument is
/// released). The compositor must not send this event if the wl_keyboard
/// did not have an active surface immediately before this event. The
/// compositor must not send this event if state is pressed (resp. released)
/// and the key was already logically down (resp. was not logically down)
/// immediately before this event.
/// 
 void onkey(void Function(int serial, int time, int key, int state) handler) {
   _keyHandler = handler;
 }

 void Function(int serial, int time, int key, int state)? _keyHandler;

 /// modifier and group state
/// 
/// Notifies clients that the modifier and/or group state has
/// changed, and it should update its local state.
/// 
/// The compositor may send this event without a surface of the client
/// having keyboard focus, for example to tie modifier information to
/// pointer focus instead. If a modifier event with pressed modifiers is sent
/// without a prior enter event, the client can assume the modifier state is
/// valid until it receives the next wl_keyboard.modifiers event. In order to
/// reset the modifier state again, the compositor can send a
/// wl_keyboard.modifiers event with no pressed modifiers.
/// 
/// In the wl_keyboard logical state, this event updates the modifiers and
/// group.
/// 
 void onmodifiers(void Function(int serial, int modsDepressed, int modsLatched, int modsLocked, int group) handler) {
   _modifiersHandler = handler;
 }

 void Function(int serial, int modsDepressed, int modsLatched, int modsLocked, int group)? _modifiersHandler;

 /// repeat rate and delay
/// 
/// Informs the client about the keyboard's repeat rate and delay.
/// 
/// This event is sent as soon as the wl_keyboard object has been created,
/// and is guaranteed to be received by the client before any key press
/// event.
/// 
/// Negative values for either rate or delay are illegal. A rate of zero
/// will disable any repeating (regardless of the value of delay).
/// 
/// This event can be sent later on as well with a new value if necessary,
/// so clients should continue listening for the event past the creation
/// of wl_keyboard.
/// 
 void onrepeatInfo(void Function(int rate, int delay) handler) {
   _repeatInfoHandler = handler;
 }

 void Function(int rate, int delay)? _repeatInfoHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_keymapHandler != null) {
         _keymapHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fd,
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 1:
       if (_enterHandler != null) {
         _enterHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           getArray(data, 8),
         );
       }
       break;
     case 2:
       if (_leaveHandler != null) {
         _leaveHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
         );
       }
       break;
     case 3:
       if (_keyHandler != null) {
         _keyHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 4:
       if (_modifiersHandler != null) {
         _modifiersHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
           ByteData.view(data.buffer).getInt32(16, Endian.host),
         );
       }
       break;
     case 5:
       if (_repeatInfoHandler != null) {
         _repeatInfoHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
   }
 }
}

/// keyboard mapping format
/// 
/// This specifies the format of the keymap provided to the
/// client with the wl_keyboard.keymap event.
/// 

enum KeyboardkeymapFormat {
  /// no keymap; client must understand how to interpret the raw keycode
  noKeymap,
  /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
  xkbV1,
}

/// physical key state
/// 
/// Describes the physical state of a key that produced the key event.
/// 

enum KeyboardkeyState {
  /// key is not pressed
  released,
  /// key is pressed
  pressed,
}

/// touchscreen input device
/// 
/// The wl_touch interface represents a touchscreen
/// associated with a seat.
/// 
/// Touch interactions can consist of one or more contacts.
/// For each contact, a series of events is generated, starting
/// with a down event, followed by zero or more motion events,
/// and ending with an up event. Events relating to the same
/// contact point can be identified by the ID of the sequence.
/// 
class Touch extends Proxy implements Dispatcher{
  final Context context;

  Touch(this.context) : super(context.allocateClientId());

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// touch down event and beginning of a touch sequence
/// 
/// A new touch point has appeared on the surface. This touch point is
/// assigned a unique ID. Future events from this touch point reference
/// this ID. The ID ceases to be valid after a touch up event and may be
/// reused in the future.
/// 
 void ondown(void Function(int serial, int time, int surface, int id, double x, double y) handler) {
   _downHandler = handler;
 }

 void Function(int serial, int time, int surface, int id, double x, double y)? _downHandler;

 /// end of a touch event sequence
/// 
/// The touch point has disappeared. No further events will be sent for
/// this touch point and the touch point's ID is released and may be
/// reused in a future touch down event.
/// 
 void onup(void Function(int serial, int time, int id) handler) {
   _upHandler = handler;
 }

 void Function(int serial, int time, int id)? _upHandler;

 /// update of touch point coordinates
/// 
/// A touch point has changed coordinates.
/// 
 void onmotion(void Function(int time, int id, double x, double y) handler) {
   _motionHandler = handler;
 }

 void Function(int time, int id, double x, double y)? _motionHandler;

 /// end of touch frame event
/// 
/// Indicates the end of a set of events that logically belong together.
/// A client is expected to accumulate the data in all events within the
/// frame before proceeding.
/// 
/// A wl_touch.frame terminates at least one event but otherwise no
/// guarantee is provided about the set of events within a frame. A client
/// must assume that any state not updated in a frame is unchanged from the
/// previously known state.
/// 
 void onframe(void Function() handler) {
   _frameHandler = handler;
 }

 void Function()? _frameHandler;

 /// touch session cancelled
/// 
/// Sent if the compositor decides the touch stream is a global
/// gesture. No further events are sent to the clients from that
/// particular gesture. Touch cancellation applies to all touch points
/// currently active on this client's surface. The client is
/// responsible for finalizing the touch points, future touch points on
/// this surface may reuse the touch point ID.
/// 
/// No frame event is required after the cancel event.
/// 
 void oncancel(void Function() handler) {
   _cancelHandler = handler;
 }

 void Function()? _cancelHandler;

 /// update shape of touch point
/// 
/// Sent when a touchpoint has changed its shape.
/// 
/// This event does not occur on its own. It is sent before a
/// wl_touch.frame event and carries the new shape information for
/// any previously reported, or new touch points of that frame.
/// 
/// Other events describing the touch point such as wl_touch.down,
/// wl_touch.motion or wl_touch.orientation may be sent within the
/// same wl_touch.frame. A client should treat these events as a single
/// logical touch point update. The order of wl_touch.shape,
/// wl_touch.orientation and wl_touch.motion is not guaranteed.
/// A wl_touch.down event is guaranteed to occur before the first
/// wl_touch.shape event for this touch ID but both events may occur within
/// the same wl_touch.frame.
/// 
/// A touchpoint shape is approximated by an ellipse through the major and
/// minor axis length. The major axis length describes the longer diameter
/// of the ellipse, while the minor axis length describes the shorter
/// diameter. Major and minor are orthogonal and both are specified in
/// surface-local coordinates. The center of the ellipse is always at the
/// touchpoint location as reported by wl_touch.down or wl_touch.move.
/// 
/// This event is only sent by the compositor if the touch device supports
/// shape reports. The client has to make reasonable assumptions about the
/// shape if it did not receive this event.
/// 
 void onshape(void Function(int id, double major, double minor) handler) {
   _shapeHandler = handler;
 }

 void Function(int id, double major, double minor)? _shapeHandler;

 /// update orientation of touch point
/// 
/// Sent when a touchpoint has changed its orientation.
/// 
/// This event does not occur on its own. It is sent before a
/// wl_touch.frame event and carries the new shape information for
/// any previously reported, or new touch points of that frame.
/// 
/// Other events describing the touch point such as wl_touch.down,
/// wl_touch.motion or wl_touch.shape may be sent within the
/// same wl_touch.frame. A client should treat these events as a single
/// logical touch point update. The order of wl_touch.shape,
/// wl_touch.orientation and wl_touch.motion is not guaranteed.
/// A wl_touch.down event is guaranteed to occur before the first
/// wl_touch.orientation event for this touch ID but both events may occur
/// within the same wl_touch.frame.
/// 
/// The orientation describes the clockwise angle of a touchpoint's major
/// axis to the positive surface y-axis and is normalized to the -180 to
/// +180 degree range. The granularity of orientation depends on the touch
/// device, some devices only support binary rotation values between 0 and
/// 90 degrees.
/// 
/// This event is only sent by the compositor if the touch device supports
/// orientation reports.
/// 
 void onorientation(void Function(int id, double orientation) handler) {
   _orientationHandler = handler;
 }

 void Function(int id, double orientation)? _orientationHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_downHandler != null) {
         _downHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
           ByteData.view(data.buffer).getInt32(12, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(16, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(20, Endian.host)),
         );
       }
       break;
     case 1:
       if (_upHandler != null) {
         _upHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 2:
       if (_motionHandler != null) {
         _motionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(12, Endian.host)),
         );
       }
       break;
     case 3:
       if (_frameHandler != null) {
         _frameHandler!(
         );
       }
       break;
     case 4:
       if (_cancelHandler != null) {
         _cancelHandler!(
         );
       }
       break;
     case 5:
       if (_shapeHandler != null) {
         _shapeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
         );
       }
       break;
     case 6:
       if (_orientationHandler != null) {
         _orientationHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
         );
       }
       break;
   }
 }
}

/// compositor output region
/// 
/// An output describes part of the compositor geometry.  The
/// compositor works in the 'compositor coordinate system' and an
/// output corresponds to a rectangular area in that space that is
/// actually visible.  This typically corresponds to a monitor that
/// displays part of the compositor space.  This object is published
/// as global during start up, or when a monitor is hotplugged.
/// 
class Output extends Proxy implements Dispatcher{
  final Context context;

  Output(this.context) : super(context.allocateClientId());

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// properties of the output
/// 
/// The geometry event describes geometric properties of the output.
/// The event is sent when binding to the output object and whenever
/// any of the properties change.
/// 
/// The physical size can be set to zero if it doesn't make sense for this
/// output (e.g. for projectors or virtual outputs).
/// 
/// The geometry event will be followed by a done event (starting from
/// version 2).
/// 
/// Clients should use wl_surface.preferred_buffer_transform instead of the
/// transform advertised by this event to find the preferred buffer
/// transform to use for a surface.
/// 
/// Note: wl_output only advertises partial information about the output
/// position and identification. Some compositors, for instance those not
/// implementing a desktop-style output layout or those exposing virtual
/// outputs, might fake this information. Instead of using x and y, clients
/// should use xdg_output.logical_position. Instead of using make and model,
/// clients should use name and description.
/// 
 void ongeometry(void Function(int x, int y, int physicalWidth, int physicalHeight, int subpixel, String make, String model, int transform) handler) {
   _geometryHandler = handler;
 }

 void Function(int x, int y, int physicalWidth, int physicalHeight, int subpixel, String make, String model, int transform)? _geometryHandler;

 /// advertise available modes for the output
/// 
/// The mode event describes an available mode for the output.
/// 
/// The event is sent when binding to the output object and there
/// will always be one mode, the current mode.  The event is sent
/// again if an output changes mode, for the mode that is now
/// current.  In other words, the current mode is always the last
/// mode that was received with the current flag set.
/// 
/// Non-current modes are deprecated. A compositor can decide to only
/// advertise the current mode and never send other modes. Clients
/// should not rely on non-current modes.
/// 
/// The size of a mode is given in physical hardware units of
/// the output device. This is not necessarily the same as
/// the output size in the global compositor space. For instance,
/// the output may be scaled, as described in wl_output.scale,
/// or transformed, as described in wl_output.transform. Clients
/// willing to retrieve the output size in the global compositor
/// space should use xdg_output.logical_size instead.
/// 
/// The vertical refresh rate can be set to zero if it doesn't make
/// sense for this output (e.g. for virtual outputs).
/// 
/// The mode event will be followed by a done event (starting from
/// version 2).
/// 
/// Clients should not use the refresh rate to schedule frames. Instead,
/// they should use the wl_surface.frame event or the presentation-time
/// protocol.
/// 
/// Note: this information is not always meaningful for all outputs. Some
/// compositors, such as those exposing virtual outputs, might fake the
/// refresh rate or the size.
/// 
 void onmode(void Function(int flags, int width, int height, int refresh) handler) {
   _modeHandler = handler;
 }

 void Function(int flags, int width, int height, int refresh)? _modeHandler;

 /// sent all information about output
/// 
/// This event is sent after all other properties have been
/// sent after binding to the output object and after any
/// other property changes done after that. This allows
/// changes to the output properties to be seen as
/// atomic, even if they happen via multiple events.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// output scaling properties
/// 
/// This event contains scaling geometry information
/// that is not in the geometry event. It may be sent after
/// binding the output object or if the output scale changes
/// later. The compositor will emit a non-zero, positive
/// value for scale. If it is not sent, the client should
/// assume a scale of 1.
/// 
/// A scale larger than 1 means that the compositor will
/// automatically scale surface buffers by this amount
/// when rendering. This is used for very high resolution
/// displays where applications rendering at the native
/// resolution would be too small to be legible.
/// 
/// Clients should use wl_surface.preferred_buffer_scale
/// instead of this event to find the preferred buffer
/// scale to use for a surface.
/// 
/// The scale event will be followed by a done event.
/// 
 void onscale(void Function(int factor) handler) {
   _scaleHandler = handler;
 }

 void Function(int factor)? _scaleHandler;

 /// name of this output
/// 
/// Many compositors will assign user-friendly names to their outputs, show
/// them to the user, allow the user to refer to an output, etc. The client
/// may wish to know this name as well to offer the user similar behaviors.
/// 
/// The name is a UTF-8 string with no convention defined for its contents.
/// Each name is unique among all wl_output globals. The name is only
/// guaranteed to be unique for the compositor instance.
/// 
/// The same output name is used for all clients for a given wl_output
/// global. Thus, the name can be shared across processes to refer to a
/// specific wl_output global.
/// 
/// The name is not guaranteed to be persistent across sessions, thus cannot
/// be used to reliably identify an output in e.g. configuration files.
/// 
/// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
/// not assume that the name is a reflection of an underlying DRM connector,
/// X11 connection, etc.
/// 
/// The name event is sent after binding the output object. This event is
/// only sent once per output object, and the name does not change over the
/// lifetime of the wl_output global.
/// 
/// Compositors may re-use the same output name if the wl_output global is
/// destroyed and re-created later. Compositors should avoid re-using the
/// same name if possible.
/// 
/// The name event will be followed by a done event.
/// 
 void onname(void Function(String name) handler) {
   _nameHandler = handler;
 }

 void Function(String name)? _nameHandler;

 /// human-readable description of this output
/// 
/// Many compositors can produce human-readable descriptions of their
/// outputs. The client may wish to know this description as well, e.g. for
/// output selection purposes.
/// 
/// The description is a UTF-8 string with no convention defined for its
/// contents. The description is not guaranteed to be unique among all
/// wl_output globals. Examples might include 'Foocorp 11" Display' or
/// 'Virtual X11 output via :1'.
/// 
/// The description event is sent after binding the output object and
/// whenever the description changes. The description is optional, and may
/// not be sent at all.
/// 
/// The description event will be followed by a done event.
/// 
 void ondescription(void Function(String description) handler) {
   _descriptionHandler = handler;
 }

 void Function(String description)? _descriptionHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_geometryHandler != null) {
         _geometryHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
           ByteData.view(data.buffer).getInt32(16, Endian.host),
           getString(data, 20),
           getString(data, 24),
           ByteData.view(data.buffer).getInt32(28, Endian.host),
         );
       }
       break;
     case 1:
       if (_modeHandler != null) {
         _modeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 2:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 3:
       if (_scaleHandler != null) {
         _scaleHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 4:
       if (_nameHandler != null) {
         _nameHandler!(
           getString(data, 0),
         );
       }
       break;
     case 5:
       if (_descriptionHandler != null) {
         _descriptionHandler!(
           getString(data, 0),
         );
       }
       break;
   }
 }
}

/// subpixel geometry information
/// 
/// This enumeration describes how the physical
/// pixels on an output are laid out.
/// 

enum Outputsubpixel {
  /// unknown geometry
  unknown,
  /// no geometry
  none,
  /// horizontal RGB
  horizontalRgb,
  /// horizontal BGR
  horizontalBgr,
  /// vertical RGB
  verticalRgb,
  /// vertical BGR
  verticalBgr,
}

/// transformation applied to buffer contents
/// 
/// This describes transformations that clients and compositors apply to
/// buffer contents.
/// 
/// The flipped values correspond to an initial flip around a
/// vertical axis followed by rotation.
/// 
/// The purpose is mainly to allow clients to render accordingly and
/// tell the compositor, so that for fullscreen surfaces, the
/// compositor will still be able to scan out directly from client
/// surfaces.
/// 

enum Outputtransform {
  /// no transform
  normal,
  /// 90 degrees counter-clockwise
  w90,
  /// 180 degrees counter-clockwise
  w180,
  /// 270 degrees counter-clockwise
  w270,
  /// 180 degree flip around a vertical axis
  flipped,
  /// flip and rotate 90 degrees counter-clockwise
  flipped90,
  /// flip and rotate 180 degrees counter-clockwise
  flipped180,
  /// flip and rotate 270 degrees counter-clockwise
  flipped270,
}

/// mode information
/// 
/// These flags describe properties of an output mode.
/// They are used in the flags bitfield of the mode event.
/// 

enum Outputmode {
  /// indicates this is the current mode
  current,
  /// indicates this is the preferred mode
  preferred,
}

/// region interface
/// 
/// A region object describes an area.
/// 
/// Region objects are used to describe the opaque and input
/// regions of a surface.
/// 
class Region extends Proxy{
  final Context context;

  Region(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> add(int x, int y, int width, int height) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        x,
        y,
        width,
        height,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> subtract(int x, int y, int width, int height) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        x,
        y,
        width,
        height,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

}

/// sub-surface compositing
/// 
/// The global interface exposing sub-surface compositing capabilities.
/// A wl_surface, that has sub-surfaces associated, is called the
/// parent surface. Sub-surfaces can be arbitrarily nested and create
/// a tree of sub-surfaces.
/// 
/// The root surface in a tree of sub-surfaces is the main
/// surface. The main surface cannot be a sub-surface, because
/// sub-surfaces must always have a parent.
/// 
/// A main surface with its sub-surfaces forms a (compound) window.
/// For window management purposes, this set of wl_surface objects is
/// to be considered as a single window, and it should also behave as
/// such.
/// 
/// The aim of sub-surfaces is to offload some of the compositing work
/// within a window from clients to the compositor. A prime example is
/// a video player with decorations and video in separate wl_surface
/// objects. This should allow the compositor to pass YUV video buffer
/// processing to dedicated overlay hardware when possible.
/// 
class Subcompositor extends Proxy{
  final Context context;

  Subcompositor(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getSubsurface(Surface surface, Surface parent) async {
  var id =  Subcompositor(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        surface,
        parent,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum Subcompositorerror {
  /// the to-be sub-surface is invalid
  badSurface,
  /// the to-be sub-surface parent is invalid
  badParent,
}

/// sub-surface interface to a wl_surface
/// 
/// An additional interface to a wl_surface object, which has been
/// made a sub-surface. A sub-surface has one parent surface. A
/// sub-surface's size and position are not limited to that of the parent.
/// Particularly, a sub-surface is not automatically clipped to its
/// parent's area.
/// 
/// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
/// and the parent surface is mapped. The order of which one happens
/// first is irrelevant. A sub-surface is hidden if the parent becomes
/// hidden, or if a NULL wl_buffer is applied. These rules apply
/// recursively through the tree of surfaces.
/// 
/// The behaviour of a wl_surface.commit request on a sub-surface
/// depends on the sub-surface's mode. The possible modes are
/// synchronized and desynchronized, see methods
/// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
/// mode caches the wl_surface state to be applied when the parent's
/// state gets applied, and desynchronized mode applies the pending
/// wl_surface state directly. A sub-surface is initially in the
/// synchronized mode.
/// 
/// Sub-surfaces also have another kind of state, which is managed by
/// wl_subsurface requests, as opposed to wl_surface requests. This
/// state includes the sub-surface position relative to the parent
/// surface (wl_subsurface.set_position), and the stacking order of
/// the parent and its sub-surfaces (wl_subsurface.place_above and
/// .place_below). This state is applied when the parent surface's
/// wl_surface state is applied, regardless of the sub-surface's mode.
/// As the exception, set_sync and set_desync are effective immediately.
/// 
/// The main surface can be thought to be always in desynchronized mode,
/// since it does not have a parent in the sub-surfaces sense.
/// 
/// Even if a sub-surface is in desynchronized mode, it will behave as
/// in synchronized mode, if its parent surface behaves as in
/// synchronized mode. This rule is applied recursively throughout the
/// tree of surfaces. This means, that one can set a sub-surface into
/// synchronized mode, and then assume that all its child and grand-child
/// sub-surfaces are synchronized, too, without explicitly setting them.
/// 
/// Destroying a sub-surface takes effect immediately. If you need to
/// synchronize the removal of a sub-surface to the parent surface update,
/// unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
/// and then destroy the sub-surface.
/// 
/// If the parent wl_surface object is destroyed, the sub-surface is
/// unmapped.
/// 
/// A sub-surface never has the keyboard focus of any seat.
/// 
/// The wl_surface.offset request is ignored: clients must use set_position
/// instead to move the sub-surface.
/// 
class Subsurface extends Proxy{
  final Context context;

  Subsurface(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setPosition(int x, int y) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        x,
        y,
      ],
      [
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> placeAbove(Surface sibling) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        sibling,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> placeBelow(Surface sibling) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        sibling,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setSync() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setDesync() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      5,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum Subsurfaceerror {
  /// wl_surface is not a sibling or the parent
  badSurface,
}

