// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/stable/tablet/tablet-v2.xml
//
// tablet_v2 Protocol Copyright: 
/// 
/// Copyright 2014 © Stephen "Lyude" Chandler Paul
/// Copyright 2015-2016 © Red Hat, Inc.
/// 
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files
/// (the "Software"), to deal in the Software without restriction,
/// including without limitation the rights to use, copy, modify, merge,
/// publish, distribute, sublicense, and/or sell copies of the Software,
/// and to permit persons to whom the Software is furnished to do so,
/// subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the
/// next paragraph) shall be included in all copies or substantial
/// portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
/// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
/// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// controller object for graphic tablet devices
/// 
/// An object that provides access to the graphics tablets available on this
/// system. All tablets are associated with a seat, to get access to the
/// actual tablets, use wp_tablet_manager.get_tablet_seat.
/// 
class ZwpTabletManagerV2 extends Proxy{
  final Context context;

  ZwpTabletManagerV2(this.context) : super(context.allocateClientId());

  Future<void> getTabletSeat(Seat seat) async {
  var tabletSeat =  ZwpTabletManagerV2(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        tabletSeat,
        seat,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

}

/// controller object for graphic tablet devices of a seat
/// 
/// An object that provides access to the graphics tablets available on this
/// seat. After binding to this interface, the compositor sends a set of
/// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
/// 
class ZwpTabletSeatV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletSeatV2(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// new device notification
/// 
/// This event is sent whenever a new tablet becomes available on this
/// seat. This event only provides the object id of the tablet, any
/// static information about the tablet (device name, vid/pid, etc.) is
/// sent through the wp_tablet interface.
/// 
 void ontabletAdded(void Function(int id) handler) {
   _tabletAddedHandler = handler;
 }

 void Function(int id)? _tabletAddedHandler;

 /// a new tool has been used with a tablet
/// 
/// This event is sent whenever a tool that has not previously been used
/// with a tablet comes into use. This event only provides the object id
/// of the tool; any static information about the tool (capabilities,
/// type, etc.) is sent through the wp_tablet_tool interface.
/// 
 void ontoolAdded(void Function(int id) handler) {
   _toolAddedHandler = handler;
 }

 void Function(int id)? _toolAddedHandler;

 /// new pad notification
/// 
/// This event is sent whenever a new pad is known to the system. Typically,
/// pads are physically attached to tablets and a pad_added event is
/// sent immediately after the wp_tablet_seat.tablet_added.
/// However, some standalone pad devices logically attach to tablets at
/// runtime, and the client must wait for wp_tablet_pad.enter to know
/// the tablet a pad is attached to.
/// 
/// This event only provides the object id of the pad. All further
/// features (buttons, strips, rings) are sent through the wp_tablet_pad
/// interface.
/// 
 void onpadAdded(void Function(int id) handler) {
   _padAddedHandler = handler;
 }

 void Function(int id)? _padAddedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_tabletAddedHandler != null) {
         _tabletAddedHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_toolAddedHandler != null) {
         _toolAddedHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_padAddedHandler != null) {
         _padAddedHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
   }
 }
}

/// a physical tablet tool
/// 
/// An object that represents a physical tool that has been, or is
/// currently in use with a tablet in this seat. Each wp_tablet_tool
/// object stays valid until the client destroys it; the compositor
/// reuses the wp_tablet_tool object to indicate that the object's
/// respective physical tool has come into proximity of a tablet again.
/// 
/// A wp_tablet_tool object's relation to a physical tool depends on the
/// tablet's ability to report serial numbers. If the tablet supports
/// this capability, then the object represents a specific physical tool
/// and can be identified even when used on multiple tablets.
/// 
/// A tablet tool has a number of static characteristics, e.g. tool type,
/// hardware_serial and capabilities. These capabilities are sent in an
/// event sequence after the wp_tablet_seat.tool_added event before any
/// actual events from this tool. This initial event sequence is
/// terminated by a wp_tablet_tool.done event.
/// 
/// Tablet tool events are grouped by wp_tablet_tool.frame events.
/// Any events received before a wp_tablet_tool.frame event should be
/// considered part of the same hardware state change.
/// 
class ZwpTabletToolV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletToolV2(this.context) : super(context.allocateClientId());

  Future<void> setCursor(int serial, Surface surface, int hotspotX, int hotspotY) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        serial,
        surface,
        hotspotX,
        hotspotY,
      ],
      [
        WaylandType.uint,
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// tool type
/// 
/// The tool type is the high-level type of the tool and usually decides
/// the interaction expected from this tool.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void ontype(void Function(int toolType) handler) {
   _typeHandler = handler;
 }

 void Function(int toolType)? _typeHandler;

 /// unique hardware serial number of the tool
/// 
/// If the physical tool can be identified by a unique 64-bit serial
/// number, this event notifies the client of this serial number.
/// 
/// If multiple tablets are available in the same seat and the tool is
/// uniquely identifiable by the serial number, that tool may move
/// between tablets.
/// 
/// Otherwise, if the tool has no serial number and this event is
/// missing, the tool is tied to the tablet it first comes into
/// proximity with. Even if the physical tool is used on multiple
/// tablets, separate wp_tablet_tool objects will be created, one per
/// tablet.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void onhardwareSerial(void Function(int hardwareSerialHi, int hardwareSerialLo) handler) {
   _hardwareSerialHandler = handler;
 }

 void Function(int hardwareSerialHi, int hardwareSerialLo)? _hardwareSerialHandler;

 /// hardware id notification in Wacom's format
/// 
/// This event notifies the client of a hardware id available on this tool.
/// 
/// The hardware id is a device-specific 64-bit id that provides extra
/// information about the tool in use, beyond the wl_tool.type
/// enumeration. The format of the id is specific to tablets made by
/// Wacom Inc. For example, the hardware id of a Wacom Grip
/// Pen (a stylus) is 0x802.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void onhardwareIdWacom(void Function(int hardwareIdHi, int hardwareIdLo) handler) {
   _hardwareIdWacomHandler = handler;
 }

 void Function(int hardwareIdHi, int hardwareIdLo)? _hardwareIdWacomHandler;

 /// tool capability notification
/// 
/// This event notifies the client of any capabilities of this tool,
/// beyond the main set of x/y axes and tip up/down detection.
/// 
/// One event is sent for each extra capability available on this tool.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void oncapability(void Function(int capability) handler) {
   _capabilityHandler = handler;
 }

 void Function(int capability)? _capabilityHandler;

 /// tool description events sequence complete
/// 
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the tool to
/// be complete and finalize initialization of the tool.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// tool removed
/// 
/// This event is sent when the tool is removed from the system and will
/// send no further events. Should the physical tool come back into
/// proximity later, a new wp_tablet_tool object will be created.
/// 
/// It is compositor-dependent when a tool is removed. A compositor may
/// remove a tool on proximity out, tablet removal or any other reason.
/// A compositor may also keep a tool alive until shutdown.
/// 
/// If the tool is currently in proximity, a proximity_out event will be
/// sent before the removed event. See wp_tablet_tool.proximity_out for
/// the handling of any buttons logically down.
/// 
/// When this event is received, the client must wp_tablet_tool.destroy
/// the object.
/// 
 void onremoved(void Function() handler) {
   _removedHandler = handler;
 }

 void Function()? _removedHandler;

 /// proximity in event
/// 
/// Notification that this tool is focused on a certain surface.
/// 
/// This event can be received when the tool has moved from one surface to
/// another, or when the tool has come back into proximity above the
/// surface.
/// 
/// If any button is logically down when the tool comes into proximity,
/// the respective button event is sent after the proximity_in event but
/// within the same frame as the proximity_in event.
/// 
 void onproximityIn(void Function(int serial, int tablet, int surface) handler) {
   _proximityInHandler = handler;
 }

 void Function(int serial, int tablet, int surface)? _proximityInHandler;

 /// proximity out event
/// 
/// Notification that this tool has either left proximity, or is no
/// longer focused on a certain surface.
/// 
/// When the tablet tool leaves proximity of the tablet, button release
/// events are sent for each button that was held down at the time of
/// leaving proximity. These events are sent before the proximity_out
/// event but within the same wp_tablet.frame.
/// 
/// If the tool stays within proximity of the tablet, but the focus
/// changes from one surface to another, a button release event may not
/// be sent until the button is actually released or the tool leaves the
/// proximity of the tablet.
/// 
 void onproximityOut(void Function() handler) {
   _proximityOutHandler = handler;
 }

 void Function()? _proximityOutHandler;

 /// tablet tool is making contact
/// 
/// Sent whenever the tablet tool comes in contact with the surface of the
/// tablet.
/// 
/// If the tool is already in contact with the tablet when entering the
/// input region, the client owning said region will receive a
/// wp_tablet.proximity_in event, followed by a wp_tablet.down
/// event and a wp_tablet.frame event.
/// 
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool in
/// logical contact until a minimum physical pressure threshold is
/// exceeded.
/// 
 void ondown(void Function(int serial) handler) {
   _downHandler = handler;
 }

 void Function(int serial)? _downHandler;

 /// tablet tool is no longer making contact
/// 
/// Sent whenever the tablet tool stops making contact with the surface of
/// the tablet, or when the tablet tool moves out of the input region
/// and the compositor grab (if any) is dismissed.
/// 
/// If the tablet tool moves out of the input region while in contact
/// with the surface of the tablet and the compositor does not have an
/// ongoing grab on the surface, the client owning said region will
/// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
/// event and a wp_tablet.frame event. If the compositor has an ongoing
/// grab on this device, this event sequence is sent whenever the grab
/// is dismissed in the future.
/// 
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool out
/// of logical contact until physical pressure falls below a specific
/// threshold.
/// 
 void onup(void Function() handler) {
   _upHandler = handler;
 }

 void Function()? _upHandler;

 /// motion event
/// 
/// Sent whenever a tablet tool moves.
/// 
 void onmotion(void Function(double x, double y) handler) {
   _motionHandler = handler;
 }

 void Function(double x, double y)? _motionHandler;

 /// pressure change event
/// 
/// Sent whenever the pressure axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
/// 
/// Note that pressure may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
/// 
 void onpressure(void Function(int pressure) handler) {
   _pressureHandler = handler;
 }

 void Function(int pressure)? _pressureHandler;

 /// distance change event
/// 
/// Sent whenever the distance axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
/// 
/// Note that distance may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
/// 
 void ondistance(void Function(int distance) handler) {
   _distanceHandler = handler;
 }

 void Function(int distance)? _distanceHandler;

 /// tilt change event
/// 
/// Sent whenever one or both of the tilt axes on a tool change. Each tilt
/// value is in degrees, relative to the z-axis of the tablet.
/// The angle is positive when the top of a tool tilts along the
/// positive x or y axis.
/// 
 void ontilt(void Function(double tiltX, double tiltY) handler) {
   _tiltHandler = handler;
 }

 void Function(double tiltX, double tiltY)? _tiltHandler;

 /// z-rotation change event
/// 
/// Sent whenever the z-rotation axis on the tool changes. The
/// rotation value is in degrees clockwise from the tool's
/// logical neutral position.
/// 
 void onrotation(void Function(double degrees) handler) {
   _rotationHandler = handler;
 }

 void Function(double degrees)? _rotationHandler;

 /// Slider position change event
/// 
/// Sent whenever the slider position on the tool changes. The
/// value is normalized between -65535 and 65535, with 0 as the logical
/// neutral position of the slider.
/// 
/// The slider is available on e.g. the Wacom Airbrush tool.
/// 
 void onslider(void Function(int position) handler) {
   _sliderHandler = handler;
 }

 void Function(int position)? _sliderHandler;

 /// Wheel delta event
/// 
/// Sent whenever the wheel on the tool emits an event. This event
/// contains two values for the same axis change. The degrees value is
/// in the same orientation as the wl_pointer.vertical_scroll axis. The
/// clicks value is in discrete logical clicks of the mouse wheel. This
/// value may be zero if the movement of the wheel was less
/// than one logical click.
/// 
/// Clients should choose either value and avoid mixing degrees and
/// clicks. The compositor may accumulate values smaller than a logical
/// click and emulate click events when a certain threshold is met.
/// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
/// have different degrees values.
/// 
 void onwheel(void Function(double degrees, int clicks) handler) {
   _wheelHandler = handler;
 }

 void Function(double degrees, int clicks)? _wheelHandler;

 /// button event
/// 
/// Sent whenever a button on the tool is pressed or released.
/// 
/// If a button is held down when the tool moves in or out of proximity,
/// button events are generated by the compositor. See
/// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
/// details.
/// 
 void onbutton(void Function(int serial, int button, int state) handler) {
   _buttonHandler = handler;
 }

 void Function(int serial, int button, int state)? _buttonHandler;

 /// frame event
/// 
/// Marks the end of a series of axis and/or button updates from the
/// tablet. The Wayland protocol requires axis updates to be sent
/// sequentially, however all events within a frame should be considered
/// one hardware event.
/// 
 void onframe(void Function(int time) handler) {
   _frameHandler = handler;
 }

 void Function(int time)? _frameHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_typeHandler != null) {
         _typeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_hardwareSerialHandler != null) {
         _hardwareSerialHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 2:
       if (_hardwareIdWacomHandler != null) {
         _hardwareIdWacomHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 3:
       if (_capabilityHandler != null) {
         _capabilityHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 4:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 5:
       if (_removedHandler != null) {
         _removedHandler!(
         );
       }
       break;
     case 6:
       if (_proximityInHandler != null) {
         _proximityInHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
         );
       }
       break;
     case 7:
       if (_proximityOutHandler != null) {
         _proximityOutHandler!(
         );
       }
       break;
     case 8:
       if (_downHandler != null) {
         _downHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 9:
       if (_upHandler != null) {
         _upHandler!(
         );
       }
       break;
     case 10:
       if (_motionHandler != null) {
         _motionHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
         );
       }
       break;
     case 11:
       if (_pressureHandler != null) {
         _pressureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 12:
       if (_distanceHandler != null) {
         _distanceHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 13:
       if (_tiltHandler != null) {
         _tiltHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
         );
       }
       break;
     case 14:
       if (_rotationHandler != null) {
         _rotationHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
         );
       }
       break;
     case 15:
       if (_sliderHandler != null) {
         _sliderHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 16:
       if (_wheelHandler != null) {
         _wheelHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 17:
       if (_buttonHandler != null) {
         _buttonHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 18:
       if (_frameHandler != null) {
         _frameHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// a physical tool type
/// 
/// Describes the physical type of a tool. The physical type of a tool
/// generally defines its base usage.
/// 
/// The mouse tool represents a mouse-shaped tool that is not a relative
/// device but bound to the tablet's surface, providing absolute
/// coordinates.
/// 
/// The lens tool is a mouse-shaped tool with an attached lens to
/// provide precision focus.
/// 

enum ZwpTabletToolV2type {
  /// Pen
  pen,
  /// Eraser
  eraser,
  /// Brush
  brush,
  /// Pencil
  pencil,
  /// Airbrush
  airbrush,
  /// Finger
  finger,
  /// Mouse
  mouse,
  /// Lens
  lens,
}

/// capability flags for a tool
/// 
/// Describes extra capabilities on a tablet.
/// 
/// Any tool must provide x and y values, extra axes are
/// device-specific.
/// 

enum ZwpTabletToolV2capability {
  /// Tilt axes
  tilt,
  /// Pressure axis
  pressure,
  /// Distance axis
  distance,
  /// Z-rotation axis
  rotation,
  /// Slider axis
  slider,
  /// Wheel axis
  wheel,
}

/// physical button state
/// 
/// Describes the physical state of a button that produced the button event.
/// 

enum ZwpTabletToolV2buttonState {
  /// button is not pressed
  released,
  /// button is pressed
  pressed,
}

/// 
/// 

enum ZwpTabletToolV2error {
  /// given wl_surface has another role
  role,
}

/// graphics tablet device
/// 
/// The wp_tablet interface represents one graphics tablet device. The
/// tablet interface itself does not generate events; all events are
/// generated by wp_tablet_tool objects when in proximity above a tablet.
/// 
/// A tablet has a number of static characteristics, e.g. device name and
/// pid/vid. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.tablet_added event. This initial event sequence is
/// terminated by a wp_tablet.done event.
/// 
class ZwpTabletV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletV2(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// tablet device name
/// 
/// A descriptive name for the tablet device.
/// 
/// If the device has no descriptive name, this event is not sent.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onname(void Function(String name) handler) {
   _nameHandler = handler;
 }

 void Function(String name)? _nameHandler;

 /// tablet device USB vendor/product id
/// 
/// The USB vendor and product IDs for the tablet device.
/// 
/// If the device has no USB vendor/product ID, this event is not sent.
/// This can happen for virtual devices or non-USB devices, for instance.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onid(void Function(int vid, int pid) handler) {
   _idHandler = handler;
 }

 void Function(int vid, int pid)? _idHandler;

 /// path to the device
/// 
/// A system-specific device path that indicates which device is behind
/// this wp_tablet. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
/// 
/// A device may have more than one device path. If so, multiple
/// wp_tablet.path events are sent. A device may be emulated and not
/// have a device path, and in that case this event will not be sent.
/// 
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onpath(void Function(String path) handler) {
   _pathHandler = handler;
 }

 void Function(String path)? _pathHandler;

 /// tablet description events sequence complete
/// 
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// tablet removed event
/// 
/// Sent when the tablet has been removed from the system. When a tablet
/// is removed, some tools may be removed.
/// 
/// When this event is received, the client must wp_tablet.destroy
/// the object.
/// 
 void onremoved(void Function() handler) {
   _removedHandler = handler;
 }

 void Function()? _removedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_nameHandler != null) {
         _nameHandler!(
           getString(data, 0),
         );
       }
       break;
     case 1:
       if (_idHandler != null) {
         _idHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 2:
       if (_pathHandler != null) {
         _pathHandler!(
           getString(data, 0),
         );
       }
       break;
     case 3:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 4:
       if (_removedHandler != null) {
         _removedHandler!(
         );
       }
       break;
   }
 }
}

/// pad ring
/// 
/// A circular interaction area, such as the touch ring on the Wacom Intuos
/// Pro series tablets.
/// 
/// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
/// event.
/// 
class ZwpTabletPadRingV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletPadRingV2(this.context) : super(context.allocateClientId());

  Future<void> setFeedback(String description, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        description,
        serial,
      ],
      [
        WaylandType.string,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// ring event source
/// 
/// Source information for ring events.
/// 
/// This event does not occur on its own. It is sent before a
/// wp_tablet_pad_ring.frame event and carries the source information
/// for all events within that frame.
/// 
/// The source specifies how this event was generated. If the source is
/// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
/// will be sent when the user lifts the finger off the device.
/// 
/// This event is optional. If the source is unknown for an interaction,
/// no event is sent.
/// 
 void onsource(void Function(int source) handler) {
   _sourceHandler = handler;
 }

 void Function(int source)? _sourceHandler;

 /// angle changed
/// 
/// Sent whenever the angle on a ring changes.
/// 
/// The angle is provided in degrees clockwise from the logical
/// north of the ring in the pad's current rotation.
/// 
 void onangle(void Function(double degrees) handler) {
   _angleHandler = handler;
 }

 void Function(double degrees)? _angleHandler;

 /// interaction stopped
/// 
/// Stop notification for ring events.
/// 
/// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
/// event is sent to notify a client that the interaction with the ring
/// has terminated. This enables the client to implement kinetic scrolling.
/// See the wp_tablet_pad_ring.source documentation for information on
/// when this event may be generated.
/// 
/// Any wp_tablet_pad_ring.angle events with the same source after this
/// event should be considered as the start of a new interaction.
/// 
 void onstop(void Function() handler) {
   _stopHandler = handler;
 }

 void Function()? _stopHandler;

 /// end of a ring event sequence
/// 
/// Indicates the end of a set of ring events that logically belong
/// together. A client is expected to accumulate the data in all events
/// within the frame before proceeding.
/// 
/// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
/// logically together. For example, on termination of a finger interaction
/// on a ring the compositor will send a wp_tablet_pad_ring.source event,
/// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
/// 
/// A wp_tablet_pad_ring.frame event is sent for every logical event
/// group, even if the group only contains a single wp_tablet_pad_ring
/// event. Specifically, a client may get a sequence: angle, frame,
/// angle, frame, etc.
/// 
 void onframe(void Function(int time) handler) {
   _frameHandler = handler;
 }

 void Function(int time)? _frameHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_sourceHandler != null) {
         _sourceHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_angleHandler != null) {
         _angleHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
         );
       }
       break;
     case 2:
       if (_stopHandler != null) {
         _stopHandler!(
         );
       }
       break;
     case 3:
       if (_frameHandler != null) {
         _frameHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// ring axis source
/// 
/// Describes the source types for ring events. This indicates to the
/// client how a ring event was physically generated; a client may
/// adjust the user interface accordingly. For example, events
/// from a "finger" source may trigger kinetic scrolling.
/// 

enum ZwpTabletPadRingV2source {
  /// finger
  finger,
}

/// pad strip
/// 
/// A linear interaction area, such as the strips found in Wacom Cintiq
/// models.
/// 
/// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
/// event.
/// 
class ZwpTabletPadStripV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletPadStripV2(this.context) : super(context.allocateClientId());

  Future<void> setFeedback(String description, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        description,
        serial,
      ],
      [
        WaylandType.string,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// strip event source
/// 
/// Source information for strip events.
/// 
/// This event does not occur on its own. It is sent before a
/// wp_tablet_pad_strip.frame event and carries the source information
/// for all events within that frame.
/// 
/// The source specifies how this event was generated. If the source is
/// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
/// will be sent when the user lifts their finger off the device.
/// 
/// This event is optional. If the source is unknown for an interaction,
/// no event is sent.
/// 
 void onsource(void Function(int source) handler) {
   _sourceHandler = handler;
 }

 void Function(int source)? _sourceHandler;

 /// position changed
/// 
/// Sent whenever the position on a strip changes.
/// 
/// The position is normalized to a range of [0, 65535], the 0-value
/// represents the top-most and/or left-most position of the strip in
/// the pad's current rotation.
/// 
 void onposition(void Function(int position) handler) {
   _positionHandler = handler;
 }

 void Function(int position)? _positionHandler;

 /// interaction stopped
/// 
/// Stop notification for strip events.
/// 
/// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
/// event is sent to notify a client that the interaction with the strip
/// has terminated. This enables the client to implement kinetic
/// scrolling. See the wp_tablet_pad_strip.source documentation for
/// information on when this event may be generated.
/// 
/// Any wp_tablet_pad_strip.position events with the same source after this
/// event should be considered as the start of a new interaction.
/// 
 void onstop(void Function() handler) {
   _stopHandler = handler;
 }

 void Function()? _stopHandler;

 /// end of a strip event sequence
/// 
/// Indicates the end of a set of events that represent one logical
/// hardware strip event. A client is expected to accumulate the data
/// in all events within the frame before proceeding.
/// 
/// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
/// logically together. For example, on termination of a finger interaction
/// on a strip the compositor will send a wp_tablet_pad_strip.source event,
/// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
/// event.
/// 
/// A wp_tablet_pad_strip.frame event is sent for every logical event
/// group, even if the group only contains a single wp_tablet_pad_strip
/// event. Specifically, a client may get a sequence: position, frame,
/// position, frame, etc.
/// 
 void onframe(void Function(int time) handler) {
   _frameHandler = handler;
 }

 void Function(int time)? _frameHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_sourceHandler != null) {
         _sourceHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_positionHandler != null) {
         _positionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 2:
       if (_stopHandler != null) {
         _stopHandler!(
         );
       }
       break;
     case 3:
       if (_frameHandler != null) {
         _frameHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// strip axis source
/// 
/// Describes the source types for strip events. This indicates to the
/// client how a strip event was physically generated; a client may
/// adjust the user interface accordingly. For example, events
/// from a "finger" source may trigger kinetic scrolling.
/// 

enum ZwpTabletPadStripV2source {
  /// finger
  finger,
}

/// a set of buttons, rings and strips
/// 
/// A pad group describes a distinct (sub)set of buttons, rings and strips
/// present in the tablet. The criteria of this grouping is usually positional,
/// eg. if a tablet has buttons on the left and right side, 2 groups will be
/// presented. The physical arrangement of groups is undisclosed and may
/// change on the fly.
/// 
/// Pad groups will announce their features during pad initialization. Between
/// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
/// pad group will announce the buttons, rings and strips contained in it,
/// plus the number of supported modes.
/// 
/// Modes are a mechanism to allow multiple groups of actions for every element
/// in the pad group. The number of groups and available modes in each is
/// persistent across device plugs. The current mode is user-switchable, it
/// will be announced through the wp_tablet_pad_group.mode_switch event both
/// whenever it is switched, and after wp_tablet_pad.enter.
/// 
/// The current mode logically applies to all elements in the pad group,
/// although it is at clients' discretion whether to actually perform different
/// actions, and/or issue the respective .set_feedback requests to notify the
/// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
/// 
class ZwpTabletPadGroupV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletPadGroupV2(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// buttons announced
/// 
/// Sent on wp_tablet_pad_group initialization to announce the available
/// buttons in the group. Button indices start at 0, a button may only be
/// in one group at a time.
/// 
/// This event is first sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
/// 
/// Some buttons are reserved by the compositor. These buttons may not be
/// assigned to any wp_tablet_pad_group. Compositors may broadcast this
/// event in the case of changes to the mapping of these reserved buttons.
/// If the compositor happens to reserve all buttons in a group, this event
/// will be sent with an empty array.
/// 
 void onbuttons(void Function(List<int> buttons) handler) {
   _buttonsHandler = handler;
 }

 void Function(List<int> buttons)? _buttonsHandler;

 /// ring announced
/// 
/// Sent on wp_tablet_pad_group initialization to announce available rings.
/// One event is sent for each ring available on this pad group.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
/// 
 void onring(void Function(int ring) handler) {
   _ringHandler = handler;
 }

 void Function(int ring)? _ringHandler;

 /// strip announced
/// 
/// Sent on wp_tablet_pad initialization to announce available strips.
/// One event is sent for each strip available on this pad group.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
/// 
 void onstrip(void Function(int strip) handler) {
   _stripHandler = handler;
 }

 void Function(int strip)? _stripHandler;

 /// mode-switch ability announced
/// 
/// Sent on wp_tablet_pad_group initialization to announce that the pad
/// group may switch between modes. A client may use a mode to store a
/// specific configuration for buttons, rings and strips and use the
/// wl_tablet_pad_group.mode_switch event to toggle between these
/// configurations. Mode indices start at 0.
/// 
/// Switching modes is compositor-dependent. See the
/// wp_tablet_pad_group.mode_switch event for more details.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event. This event is only sent when more than
/// more than one mode is available.
/// 
 void onmodes(void Function(int modes) handler) {
   _modesHandler = handler;
 }

 void Function(int modes)? _modesHandler;

 /// tablet group description events sequence complete
/// 
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet group.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// mode switch event
/// 
/// Notification that the mode was switched.
/// 
/// A mode applies to all buttons, rings and strips in a group
/// simultaneously, but a client is not required to assign different actions
/// for each mode. For example, a client may have mode-specific button
/// mappings but map the ring to vertical scrolling in all modes. Mode
/// indices start at 0.
/// 
/// Switching modes is compositor-dependent. The compositor may provide
/// visual cues to the client about the mode, e.g. by toggling LEDs on
/// the tablet device. Mode-switching may be software-controlled or
/// controlled by one or more physical buttons. For example, on a Wacom
/// Intuos Pro, the button inside the ring may be assigned to switch
/// between modes.
/// 
/// The compositor will also send this event after wp_tablet_pad.enter on
/// each group in order to notify of the current mode. Groups that only
/// feature one mode will use mode=0 when emitting this event.
/// 
/// If a button action in the new mode differs from the action in the
/// previous mode, the client should immediately issue a
/// wp_tablet_pad.set_feedback request for each changed button.
/// 
/// If a ring or strip action in the new mode differs from the action
/// in the previous mode, the client should immediately issue a
/// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
/// for each changed ring or strip.
/// 
 void onmodeSwitch(void Function(int time, int serial, int mode) handler) {
   _modeSwitchHandler = handler;
 }

 void Function(int time, int serial, int mode)? _modeSwitchHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_buttonsHandler != null) {
         _buttonsHandler!(
           getArray(data, 0),
         );
       }
       break;
     case 1:
       if (_ringHandler != null) {
         _ringHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_stripHandler != null) {
         _stripHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 3:
       if (_modesHandler != null) {
         _modesHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 4:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 5:
       if (_modeSwitchHandler != null) {
         _modeSwitchHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

/// a set of buttons, rings and strips
/// 
/// A pad device is a set of buttons, rings and strips
/// usually physically present on the tablet device itself. Some
/// exceptions exist where the pad device is physically detached, e.g. the
/// Wacom ExpressKey Remote.
/// 
/// Pad devices have no axes that control the cursor and are generally
/// auxiliary devices to the tool devices used on the tablet surface.
/// 
/// A pad device has a number of static characteristics, e.g. the number
/// of rings. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.pad_added event before any actual events from this pad.
/// This initial event sequence is terminated by a wp_tablet_pad.done
/// event.
/// 
/// All pad features (buttons, rings and strips) are logically divided into
/// groups and all pads have at least one group. The available groups are
/// notified through the wp_tablet_pad.group event; the compositor will
/// emit one event per group before emitting wp_tablet_pad.done.
/// 
/// Groups may have multiple modes. Modes allow clients to map multiple
/// actions to a single pad feature. Only one mode can be active per group,
/// although different groups may have different active modes.
/// 
class ZwpTabletPadV2 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletPadV2(this.context) : super(context.allocateClientId());

  Future<void> setFeedback(int button, String description, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        button,
        description,
        serial,
      ],
      [
        WaylandType.uint,
        WaylandType.string,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// group announced
/// 
/// Sent on wp_tablet_pad initialization to announce available groups.
/// One event is sent for each pad group available.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event. At least one group will be announced.
/// 
 void ongroup(void Function(int padGroup) handler) {
   _groupHandler = handler;
 }

 void Function(int padGroup)? _groupHandler;

 /// path to the device
/// 
/// A system-specific device path that indicates which device is behind
/// this wp_tablet_pad. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
/// 
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event.
/// 
 void onpath(void Function(String path) handler) {
   _pathHandler = handler;
 }

 void Function(String path)? _pathHandler;

 /// buttons announced
/// 
/// Sent on wp_tablet_pad initialization to announce the available
/// buttons.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event. This event is only sent when at least one
/// button is available.
/// 
 void onbuttons(void Function(int buttons) handler) {
   _buttonsHandler = handler;
 }

 void Function(int buttons)? _buttonsHandler;

 /// pad description event sequence complete
/// 
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the pad to
/// be complete and finalize initialization of the pad.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// physical button state
/// 
/// Sent whenever the physical state of a button changes.
/// 
 void onbutton(void Function(int time, int button, int state) handler) {
   _buttonHandler = handler;
 }

 void Function(int time, int button, int state)? _buttonHandler;

 /// enter event
/// 
/// Notification that this pad is focused on the specified surface.
/// 
 void onenter(void Function(int serial, int tablet, int surface) handler) {
   _enterHandler = handler;
 }

 void Function(int serial, int tablet, int surface)? _enterHandler;

 /// leave event
/// 
/// Notification that this pad is no longer focused on the specified
/// surface.
/// 
 void onleave(void Function(int serial, int surface) handler) {
   _leaveHandler = handler;
 }

 void Function(int serial, int surface)? _leaveHandler;

 /// pad removed event
/// 
/// Sent when the pad has been removed from the system. When a tablet
/// is removed its pad(s) will be removed too.
/// 
/// When this event is received, the client must destroy all rings, strips
/// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
/// the pad itself.
/// 
 void onremoved(void Function() handler) {
   _removedHandler = handler;
 }

 void Function()? _removedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_groupHandler != null) {
         _groupHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_pathHandler != null) {
         _pathHandler!(
           getString(data, 0),
         );
       }
       break;
     case 2:
       if (_buttonsHandler != null) {
         _buttonsHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 3:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 4:
       if (_buttonHandler != null) {
         _buttonHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 5:
       if (_enterHandler != null) {
         _enterHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
         );
       }
       break;
     case 6:
       if (_leaveHandler != null) {
         _leaveHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
         );
       }
       break;
     case 7:
       if (_removedHandler != null) {
         _removedHandler!(
         );
       }
       break;
   }
 }
}

/// physical button state
/// 
/// Describes the physical state of a button that caused the button
/// event.
/// 

enum ZwpTabletPadV2buttonState {
  /// the button is not pressed
  released,
  /// the button is pressed
  pressed,
}

