// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/stable/linux-dmabuf/linux-dmabuf-v1.xml
//
// linux_dmabuf_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2014, 2015 Collabora, Ltd.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// factory for creating dmabuf-based wl_buffers
/// 
/// Following the interfaces from:
/// https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
/// https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
/// and the Linux DRM sub-system's AddFb2 ioctl.
/// 
/// This interface offers ways to create generic dmabuf-based wl_buffers.
/// 
/// Clients can use the get_surface_feedback request to get dmabuf feedback
/// for a particular surface. If the client wants to retrieve feedback not
/// tied to a surface, they can use the get_default_feedback request.
/// 
/// The following are required from clients:
/// 
/// - Clients must ensure that either all data in the dma-buf is
/// coherent for all subsequent read access or that coherency is
/// correctly handled by the underlying kernel-side dma-buf
/// implementation.
/// 
/// - Don't make any more attachments after sending the buffer to the
/// compositor. Making more attachments later increases the risk of
/// the compositor not being able to use (re-import) an existing
/// dmabuf-based wl_buffer.
/// 
/// The underlying graphics stack must ensure the following:
/// 
/// - The dmabuf file descriptors relayed to the server will stay valid
/// for the whole lifetime of the wl_buffer. This means the server may
/// at any time use those fds to import the dmabuf into any kernel
/// sub-system that might accept it.
/// 
/// However, when the underlying graphics stack fails to deliver the
/// promise, because of e.g. a device hot-unplug which raises internal
/// errors, after the wl_buffer has been successfully created the
/// compositor must not raise protocol errors to the client when dmabuf
/// import later fails.
/// 
/// To create a wl_buffer from one or more dmabufs, a client creates a
/// zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
/// request. All planes required by the intended format are added with
/// the 'add' request. Finally, a 'create' or 'create_immed' request is
/// issued, which has the following outcome depending on the import success.
/// 
/// The 'create' request,
/// - on success, triggers a 'created' event which provides the final
/// wl_buffer to the client.
/// - on failure, triggers a 'failed' event to convey that the server
/// cannot use the dmabufs received from the client.
/// 
/// For the 'create_immed' request,
/// - on success, the server immediately imports the added dmabufs to
/// create a wl_buffer. No event is sent from the server in this case.
/// - on failure, the server can choose to either:
/// - terminate the client by raising a fatal error.
/// - mark the wl_buffer as failed, and send a 'failed' event to the
/// client. If the client uses a failed wl_buffer as an argument to any
/// request, the behaviour is compositor implementation-defined.
/// 
/// For all DRM formats and unless specified in another protocol extension,
/// pre-multiplied alpha is used for pixel values.
/// 
/// Unless specified otherwise in another protocol extension, implicit
/// synchronization is used. In other words, compositors and clients must
/// wait and signal fences implicitly passed via the DMA-BUF's reservation
/// mechanism.
/// 
class ZwpLinuxDmabufV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLinuxDmabufV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> createParams() async {
  var paramsId =  ZwpLinuxDmabufV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        paramsId,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getDefaultFeedback() async {
  var id =  ZwpLinuxDmabufV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getSurfaceFeedback(Surface surface) async {
  var id =  ZwpLinuxDmabufV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

 /// supported buffer format
/// 
/// This event advertises one buffer format that the server supports.
/// All the supported formats are advertised once when the client
/// binds to this interface. A roundtrip after binding guarantees
/// that the client has received all supported formats.
/// 
/// For the definition of the format codes, see the
/// zwp_linux_buffer_params_v1::create request.
/// 
/// Starting version 4, the format event is deprecated and must not be
/// sent by compositors. Instead, use get_default_feedback or
/// get_surface_feedback.
/// 
 void onformat(void Function(int format) handler) {
   _formatHandler = handler;
 }

 void Function(int format)? _formatHandler;

 /// supported buffer format modifier
/// 
/// This event advertises the formats that the server supports, along with
/// the modifiers supported for each format. All the supported modifiers
/// for all the supported formats are advertised once when the client
/// binds to this interface. A roundtrip after binding guarantees that
/// the client has received all supported format-modifier pairs.
/// 
/// For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
/// 0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
/// It indicates that the server can support the format with an implicit
/// modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
/// is as if no explicit modifier is specified. The effective modifier
/// will be derived from the dmabuf.
/// 
/// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
/// a given format supports both explicit modifiers and implicit modifiers.
/// 
/// For the definition of the format and modifier codes, see the
/// zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
/// requests.
/// 
/// Starting version 4, the modifier event is deprecated and must not be
/// sent by compositors. Instead, use get_default_feedback or
/// get_surface_feedback.
/// 
 void onmodifier(void Function(int format, int modifierHi, int modifierLo) handler) {
   _modifierHandler = handler;
 }

 void Function(int format, int modifierHi, int modifierLo)? _modifierHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_formatHandler != null) {
         _formatHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_modifierHandler != null) {
         _modifierHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

/// parameters for creating a dmabuf-based wl_buffer
/// 
/// This temporary object is a collection of dmabufs and other
/// parameters that together form a single logical buffer. The temporary
/// object may eventually create one wl_buffer unless cancelled by
/// destroying it before requesting 'create'.
/// 
/// Single-planar formats only require one dmabuf, however
/// multi-planar formats may require more than one dmabuf. For all
/// formats, an 'add' request must be called once per plane (even if the
/// underlying dmabuf fd is identical).
/// 
/// You must use consecutive plane indices ('plane_idx' argument for 'add')
/// from zero to the number of planes used by the drm_fourcc format code.
/// All planes required by the format must be given exactly once, but can
/// be given in any order. Each plane index can be set only once.
/// 
class ZwpLinuxBufferParamsV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLinuxBufferParamsV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> add(int fd, int planeIdx, int offset, int stride, int modifierHi, int modifierLo) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        fd,
        planeIdx,
        offset,
        stride,
        modifierHi,
        modifierLo,
      ],
      [
        WaylandType.fd,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> create(int width, int height, int format, int flags) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        width,
        height,
        format,
        flags,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> createImmed(int width, int height, int format, int flags) async {
  var bufferId =  ZwpLinuxBufferParamsV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        bufferId,
        width,
        height,
        format,
        flags,
      ],
      [
        WaylandType.newId,
        WaylandType.int,
        WaylandType.int,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// buffer creation succeeded
/// 
/// This event indicates that the attempted buffer creation was
/// successful. It provides the new wl_buffer referencing the dmabuf(s).
/// 
/// Upon receiving this event, the client should destroy the
/// zwp_linux_buffer_params_v1 object.
/// 
 void oncreated(void Function(int buffer) handler) {
   _createdHandler = handler;
 }

 void Function(int buffer)? _createdHandler;

 /// buffer creation failed
/// 
/// This event indicates that the attempted buffer creation has
/// failed. It usually means that one of the dmabuf constraints
/// has not been fulfilled.
/// 
/// Upon receiving this event, the client should destroy the
/// zwp_linux_buffer_params_v1 object.
/// 
 void onfailed(void Function() handler) {
   _failedHandler = handler;
 }

 void Function()? _failedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_createdHandler != null) {
         _createdHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_failedHandler != null) {
         _failedHandler!(
         );
       }
       break;
   }
 }
}

/// 
/// 

enum ZwpLinuxBufferParamsV1error {
  /// the dmabuf_batch object has already been used to create a wl_buffer
  alreadyUsed,
  /// plane index out of bounds
  planeIdx,
  /// the plane index was already set
  planeSet,
  /// missing or too many planes to create a buffer
  incomplete,
  /// format not supported
  invalidFormat,
  /// invalid width or height
  invalidDimensions,
  /// offset + stride * height goes out of dmabuf bounds
  outOfBounds,
  /// invalid wl_buffer resulted from importing dmabufs via               the create_immed request on given buffer_params
  invalidWlBuffer,
}

/// 
/// 

enum ZwpLinuxBufferParamsV1flags {
  /// contents are y-inverted
  yInvert,
  /// content is interlaced
  interlaced,
  /// bottom field first
  bottomFirst,
}

/// dmabuf feedback
/// 
/// This object advertises dmabuf parameters feedback. This includes the
/// preferred devices and the supported formats/modifiers.
/// 
/// The parameters are sent once when this object is created and whenever they
/// change. The done event is always sent once after all parameters have been
/// sent. When a single parameter changes, all parameters are re-sent by the
/// compositor.
/// 
/// Compositors can re-send the parameters when the current client buffer
/// allocations are sub-optimal. Compositors should not re-send the
/// parameters if re-allocating the buffers would not result in a more optimal
/// configuration. In particular, compositors should avoid sending the exact
/// same parameters multiple times in a row.
/// 
/// The tranche_target_device and tranche_formats events are grouped by
/// tranches of preference. For each tranche, a tranche_target_device, one
/// tranche_flags and one or more tranche_formats events are sent, followed
/// by a tranche_done event finishing the list. The tranches are sent in
/// descending order of preference. All formats and modifiers in the same
/// tranche have the same preference.
/// 
/// To send parameters, the compositor sends one main_device event, tranches
/// (each consisting of one tranche_target_device event, one tranche_flags
/// event, tranche_formats events and then a tranche_done event), then one
/// done event.
/// 
class ZwpLinuxDmabufFeedbackV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLinuxDmabufFeedbackV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// all feedback has been sent
/// 
/// This event is sent after all parameters of a wp_linux_dmabuf_feedback
/// object have been sent.
/// 
/// This allows changes to the wp_linux_dmabuf_feedback parameters to be
/// seen as atomic, even if they happen via multiple events.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// format and modifier table
/// 
/// This event provides a file descriptor which can be memory-mapped to
/// access the format and modifier table.
/// 
/// The table contains a tightly packed array of consecutive format +
/// modifier pairs. Each pair is 16 bytes wide. It contains a format as a
/// 32-bit unsigned integer, followed by 4 bytes of unused padding, and a
/// modifier as a 64-bit unsigned integer. The native endianness is used.
/// 
/// The client must map the file descriptor in read-only private mode.
/// 
/// Compositors are not allowed to mutate the table file contents once this
/// event has been sent. Instead, compositors must create a new, separate
/// table file and re-send feedback parameters. Compositors are allowed to
/// store duplicate format + modifier pairs in the table.
/// 
 void onformatTable(void Function(int fd, int size) handler) {
   _formatTableHandler = handler;
 }

 void Function(int fd, int size)? _formatTableHandler;

 /// preferred main device
/// 
/// This event advertises the main device that the server prefers to use
/// when direct scan-out to the target device isn't possible. The
/// advertised main device may be different for each
/// wp_linux_dmabuf_feedback object, and may change over time.
/// 
/// There is exactly one main device. The compositor must send at least
/// one preference tranche with tranche_target_device equal to main_device.
/// 
/// Clients need to create buffers that the main device can import and
/// read from, otherwise creating the dmabuf wl_buffer will fail (see the
/// wp_linux_buffer_params.create and create_immed requests for details).
/// The main device will also likely be kept active by the compositor,
/// so clients can use it instead of waking up another device for power
/// savings.
/// 
/// In general the device is a DRM node. The DRM node type (primary vs.
/// render) is unspecified. Clients must not rely on the compositor sending
/// a particular node type. Clients cannot check two devices for equality
/// by comparing the dev_t value.
/// 
/// If explicit modifiers are not supported and the client performs buffer
/// allocations on a different device than the main device, then the client
/// must force the buffer to have a linear layout.
/// 
 void onmainDevice(void Function(List<int> device) handler) {
   _mainDeviceHandler = handler;
 }

 void Function(List<int> device)? _mainDeviceHandler;

 /// a preference tranche has been sent
/// 
/// This event splits tranche_target_device and tranche_formats events in
/// preference tranches. It is sent after a set of tranche_target_device
/// and tranche_formats events; it represents the end of a tranche. The
/// next tranche will have a lower preference.
/// 
 void ontrancheDone(void Function() handler) {
   _trancheDoneHandler = handler;
 }

 void Function()? _trancheDoneHandler;

 /// target device
/// 
/// This event advertises the target device that the server prefers to use
/// for a buffer created given this tranche. The advertised target device
/// may be different for each preference tranche, and may change over time.
/// 
/// There is exactly one target device per tranche.
/// 
/// The target device may be a scan-out device, for example if the
/// compositor prefers to directly scan-out a buffer created given this
/// tranche. The target device may be a rendering device, for example if
/// the compositor prefers to texture from said buffer.
/// 
/// The client can use this hint to allocate the buffer in a way that makes
/// it accessible from the target device, ideally directly. The buffer must
/// still be accessible from the main device, either through direct import
/// or through a potentially more expensive fallback path. If the buffer
/// can't be directly imported from the main device then clients must be
/// prepared for the compositor changing the tranche priority or making
/// wl_buffer creation fail (see the wp_linux_buffer_params.create and
/// create_immed requests for details).
/// 
/// If the device is a DRM node, the DRM node type (primary vs. render) is
/// unspecified. Clients must not rely on the compositor sending a
/// particular node type. Clients cannot check two devices for equality by
/// comparing the dev_t value.
/// 
/// This event is tied to a preference tranche, see the tranche_done event.
/// 
 void ontrancheTargetDevice(void Function(List<int> device) handler) {
   _trancheTargetDeviceHandler = handler;
 }

 void Function(List<int> device)? _trancheTargetDeviceHandler;

 /// supported buffer format modifier
/// 
/// This event advertises the format + modifier combinations that the
/// compositor supports.
/// 
/// It carries an array of indices, each referring to a format + modifier
/// pair in the last received format table (see the format_table event).
/// Each index is a 16-bit unsigned integer in native endianness.
/// 
/// For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier.
/// It indicates that the server can support the format with an implicit
/// modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it
/// is as if no explicit modifier is specified. The effective modifier
/// will be derived from the dmabuf.
/// 
/// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
/// a given format supports both explicit modifiers and implicit modifiers.
/// 
/// Compositors must not send duplicate format + modifier pairs within the
/// same tranche or across two different tranches with the same target
/// device and flags.
/// 
/// This event is tied to a preference tranche, see the tranche_done event.
/// 
/// For the definition of the format and modifier codes, see the
/// wp_linux_buffer_params.create request.
/// 
 void ontrancheFormats(void Function(List<int> indices) handler) {
   _trancheFormatsHandler = handler;
 }

 void Function(List<int> indices)? _trancheFormatsHandler;

 /// tranche flags
/// 
/// This event sets tranche-specific flags.
/// 
/// The scanout flag is a hint that direct scan-out may be attempted by the
/// compositor on the target device if the client appropriately allocates a
/// buffer. How to allocate a buffer that can be scanned out on the target
/// device is implementation-defined.
/// 
/// This event is tied to a preference tranche, see the tranche_done event.
/// 
 void ontrancheFlags(void Function(int flags) handler) {
   _trancheFlagsHandler = handler;
 }

 void Function(int flags)? _trancheFlagsHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 1:
       if (_formatTableHandler != null) {
         _formatTableHandler!(
           fd,
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 2:
       if (_mainDeviceHandler != null) {
         _mainDeviceHandler!(
           getArray(data, 0),
         );
       }
       break;
     case 3:
       if (_trancheDoneHandler != null) {
         _trancheDoneHandler!(
         );
       }
       break;
     case 4:
       if (_trancheTargetDeviceHandler != null) {
         _trancheTargetDeviceHandler!(
           getArray(data, 0),
         );
       }
       break;
     case 5:
       if (_trancheFormatsHandler != null) {
         _trancheFormatsHandler!(
           getArray(data, 0),
         );
       }
       break;
     case 6:
       if (_trancheFlagsHandler != null) {
         _trancheFlagsHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum ZwpLinuxDmabufFeedbackV1trancheFlags {
  /// direct scan-out tranche
  scanout,
}

