// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/input-method/input-method-unstable-v1.xml
//
// input_method_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2012, 2013 Intel Corporation
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// input method context
/// 
/// Corresponds to a text input on the input method side. An input method context
/// is created on text input activation on the input method side. It allows
/// receiving information about the text input from the application via events.
/// Input method contexts do not keep state after deactivation and should be
/// destroyed after deactivation is handled.
/// 
/// Text is generally UTF-8 encoded, indices and lengths are in bytes.
/// 
/// Serials are used to synchronize the state between the text input and
/// an input method. New serials are sent by the text input in the
/// commit_state request and are used by the input method to indicate
/// the known text input state in events like preedit_string, commit_string,
/// and keysym. The text input can then ignore events from the input method
/// which are based on an outdated state (for example after a reset).
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpInputMethodContextV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpInputMethodContextV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> commitString(int serial, String text) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        serial,
        text,
      ],
      [
        WaylandType.uint,
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> preeditString(int serial, String text, String commit) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        serial,
        text,
        commit,
      ],
      [
        WaylandType.uint,
        WaylandType.string,
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> preeditStyling(int index, int length, int style) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        index,
        length,
        style,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> preeditCursor(int index) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        index,
      ],
      [
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> deleteSurroundingText(int index, int length) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      5,
      [
        index,
        length,
      ],
      [
        WaylandType.int,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> cursorPosition(int index, int anchor) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      6,
      [
        index,
        anchor,
      ],
      [
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> modifiersMap(List<int> map) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      7,
      [
        map,
      ],
      [
        WaylandType.array,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> keysym(int serial, int time, int sym, int state, int modifiers) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      8,
      [
        serial,
        time,
        sym,
        state,
        modifiers,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> grabKeyboard() async {
  var keyboard =  ZwpInputMethodContextV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      9,
      [
        keyboard,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> key(int serial, int time, int key, int state) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      10,
      [
        serial,
        time,
        key,
        state,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> modifiers(int serial, int modsDepressed, int modsLatched, int modsLocked, int group) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      11,
      [
        serial,
        modsDepressed,
        modsLatched,
        modsLocked,
        group,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> language(int serial, String language) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      12,
      [
        serial,
        language,
      ],
      [
        WaylandType.uint,
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> textDirection(int serial, int direction) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      13,
      [
        serial,
        direction,
      ],
      [
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// surrounding text event
/// 
/// The plain surrounding text around the input position. Cursor is the
/// position in bytes within the surrounding text relative to the beginning
/// of the text. Anchor is the position in bytes of the selection anchor
/// within the surrounding text relative to the beginning of the text. If
/// there is no selected text then anchor is the same as cursor.
/// 
 void onsurroundingText(void Function(String text, int cursor, int anchor) handler) {
   _surroundingTextHandler = handler;
 }

 void Function(String text, int cursor, int anchor)? _surroundingTextHandler;

 /// 
/// 
 void onreset(void Function() handler) {
   _resetHandler = handler;
 }

 void Function()? _resetHandler;

 /// 
/// 
 void oncontentType(void Function(int hint, int purpose) handler) {
   _contentTypeHandler = handler;
 }

 void Function(int hint, int purpose)? _contentTypeHandler;

 /// 
/// 
 void oninvokeAction(void Function(int button, int index) handler) {
   _invokeActionHandler = handler;
 }

 void Function(int button, int index)? _invokeActionHandler;

 /// 
/// 
 void oncommitState(void Function(int serial) handler) {
   _commitStateHandler = handler;
 }

 void Function(int serial)? _commitStateHandler;

 /// 
/// 
 void onpreferredLanguage(void Function(String language) handler) {
   _preferredLanguageHandler = handler;
 }

 void Function(String language)? _preferredLanguageHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_surroundingTextHandler != null) {
         _surroundingTextHandler!(
           getString(data, 0),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 1:
       if (_resetHandler != null) {
         _resetHandler!(
         );
       }
       break;
     case 2:
       if (_contentTypeHandler != null) {
         _contentTypeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 3:
       if (_invokeActionHandler != null) {
         _invokeActionHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 4:
       if (_commitStateHandler != null) {
         _commitStateHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 5:
       if (_preferredLanguageHandler != null) {
         _preferredLanguageHandler!(
           getString(data, 0),
         );
       }
       break;
   }
 }
}

/// input method
/// 
/// An input method object is responsible for composing text in response to
/// input from hardware or virtual keyboards. There is one input method
/// object per seat. On activate there is a new input method context object
/// created which allows the input method to communicate with the text input.
/// 
class ZwpInputMethodV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpInputMethodV1(this.context) : super(context.allocateClientId());

 /// activate event
/// 
/// A text input was activated. Creates an input method context object
/// which allows communication with the text input.
/// 
 void onactivate(void Function(int id) handler) {
   _activateHandler = handler;
 }

 void Function(int id)? _activateHandler;

 /// deactivate event
/// 
/// The text input corresponding to the context argument was deactivated.
/// The input method context should be destroyed after deactivation is
/// handled.
/// 
 void ondeactivate(void Function(int context) handler) {
   _deactivateHandler = handler;
 }

 void Function(int context)? _deactivateHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_activateHandler != null) {
         _activateHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_deactivateHandler != null) {
         _deactivateHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
   }
 }
}

/// interface for implementing keyboards
/// 
/// Only one client can bind this interface at a time.
/// 
class ZwpInputPanelV1 extends Proxy{
  final Context context;

  ZwpInputPanelV1(this.context) : super(context.allocateClientId());

  Future<void> getInputPanelSurface(Surface surface) async {
  var id =  ZwpInputPanelV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 
class ZwpInputPanelSurfaceV1 extends Proxy{
  final Context context;

  ZwpInputPanelSurfaceV1(this.context) : super(context.allocateClientId());

  Future<void> setToplevel(Output output, int position) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        output,
        position,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setOverlayPanel() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum ZwpInputPanelSurfaceV1position {
  /// 
  centerBottom,
}

