// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/fullscreen-shell/fullscreen-shell-unstable-v1.xml
//
// fullscreen_shell_unstable_v1 Protocol Copyright: 
/// 
/// Copyright © 2016 Yong Bakos
/// Copyright © 2015 Jason Ekstrand
/// Copyright © 2015 Jonas Ådahl
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// displays a single surface per output
/// 
/// Displays a single surface per output.
/// 
/// This interface provides a mechanism for a single client to display
/// simple full-screen surfaces.  While there technically may be multiple
/// clients bound to this interface, only one of those clients should be
/// shown at a time.
/// 
/// To present a surface, the client uses either the present_surface or
/// present_surface_for_mode requests.  Presenting a surface takes effect
/// on the next wl_surface.commit.  See the individual requests for
/// details about scaling and mode switches.
/// 
/// The client can have at most one surface per output at any time.
/// Requesting a surface to be presented on an output that already has a
/// surface replaces the previously presented surface.  Presenting a null
/// surface removes its content and effectively disables the output.
/// Exactly what happens when an output is "disabled" is
/// compositor-specific.  The same surface may be presented on multiple
/// outputs simultaneously.
/// 
/// Once a surface is presented on an output, it stays on that output
/// until either the client removes it or the compositor destroys the
/// output.  This way, the client can update the output's contents by
/// simply attaching a new buffer.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpFullscreenShellV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpFullscreenShellV1(this.context) : super(context.allocateClientId());

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> presentSurface(Surface surface, int method, Output output) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        surface,
        method,
        output,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> presentSurfaceForMode(Surface surface, Output output, int framerate) async {
  var feedback =  ZwpFullscreenShellV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        surface,
        output,
        framerate,
        feedback,
      ],
      [
        WaylandType.object,
        WaylandType.object,
        WaylandType.int,
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

 /// advertises a capability of the compositor
/// 
/// Advertises a single capability of the compositor.
/// 
/// When the wl_fullscreen_shell interface is bound, this event is emitted
/// once for each capability advertised.  Valid capabilities are given by
/// the wl_fullscreen_shell.capability enum.  If clients want to take
/// advantage of any of these capabilities, they should use a
/// wl_display.sync request immediately after binding to ensure that they
/// receive all the capability events.
/// 
 void oncapability(void Function(int capability) handler) {
   _capabilityHandler = handler;
 }

 void Function(int capability)? _capabilityHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_capabilityHandler != null) {
         _capabilityHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// capabilities advertised by the compositor
/// 
/// Various capabilities that can be advertised by the compositor.  They
/// are advertised one-at-a-time when the wl_fullscreen_shell interface is
/// bound.  See the wl_fullscreen_shell.capability event for more details.
/// 
/// ARBITRARY_MODES:
/// This is a hint to the client that indicates that the compositor is
/// capable of setting practically any mode on its outputs.  If this
/// capability is provided, wl_fullscreen_shell.present_surface_for_mode
/// will almost never fail and clients should feel free to set whatever
/// mode they like.  If the compositor does not advertise this, it may
/// still support some modes that are not advertised through wl_global.mode
/// but it is less likely.
/// 
/// CURSOR_PLANE:
/// This is a hint to the client that indicates that the compositor can
/// handle a cursor surface from the client without actually compositing.
/// This may be because of a hardware cursor plane or some other mechanism.
/// If the compositor does not advertise this capability then setting
/// wl_pointer.cursor may degrade performance or be ignored entirely.  If
/// CURSOR_PLANE is not advertised, it is recommended that the client draw
/// its own cursor and set wl_pointer.cursor(NULL).
/// 

enum ZwpFullscreenShellV1capability {
  /// compositor is capable of almost any output mode
  arbitraryModes,
  /// compositor has a separate cursor plane
  cursorPlane,
}

/// different method to set the surface fullscreen
/// 
/// Hints to indicate to the compositor how to deal with a conflict
/// between the dimensions of the surface and the dimensions of the
/// output. The compositor is free to ignore this parameter.
/// 

enum ZwpFullscreenShellV1presentMethod {
  /// no preference, apply default policy
  defaulted,
  /// center the surface on the output
  center,
  /// scale the surface, preserving aspect ratio, to the largest size that will fit on the output
  zoom,
  /// scale the surface, preserving aspect ratio, to fully fill the output cropping if needed
  zoomCrop,
  /// scale the surface to the size of the output ignoring aspect ratio
  stretch,
}

/// wl_fullscreen_shell error values
/// 
/// These errors can be emitted in response to wl_fullscreen_shell requests.
/// 

enum ZwpFullscreenShellV1error {
  /// present_method is not known
  invalidMethod,
  /// given wl_surface has another role
  role,
}

/// 
/// 
class ZwpFullscreenShellModeFeedbackV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpFullscreenShellModeFeedbackV1(this.context) : super(context.allocateClientId());

 /// mode switch succeeded
/// 
/// This event indicates that the attempted mode switch operation was
/// successful.  A surface of the size requested in the mode switch
/// will fill the output without scaling.
/// 
/// Upon receiving this event, the client should destroy the
/// wl_fullscreen_shell_mode_feedback object.
/// 
 void onmodeSuccessful(void Function() handler) {
   _modeSuccessfulHandler = handler;
 }

 void Function()? _modeSuccessfulHandler;

 /// mode switch failed
/// 
/// This event indicates that the attempted mode switch operation
/// failed.  This may be because the requested output mode is not
/// possible or it may mean that the compositor does not want to allow it.
/// 
/// Upon receiving this event, the client should destroy the
/// wl_fullscreen_shell_mode_feedback object.
/// 
 void onmodeFailed(void Function() handler) {
   _modeFailedHandler = handler;
 }

 void Function()? _modeFailedHandler;

 /// mode switch cancelled
/// 
/// This event indicates that the attempted mode switch operation was
/// cancelled.  Most likely this is because the client requested a
/// second mode switch before the first one completed.
/// 
/// Upon receiving this event, the client should destroy the
/// wl_fullscreen_shell_mode_feedback object.
/// 
 void onpresentCancelled(void Function() handler) {
   _presentCancelledHandler = handler;
 }

 void Function()? _presentCancelledHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_modeSuccessfulHandler != null) {
         _modeSuccessfulHandler!(
         );
       }
       break;
     case 1:
       if (_modeFailedHandler != null) {
         _modeFailedHandler!(
         );
       }
       break;
     case 2:
       if (_presentCancelledHandler != null) {
         _presentCancelledHandler!(
         );
       }
       break;
   }
 }
}

