// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-shell/xdg-shell-unstable-v5.xml
//
// xdg_shell_unstable_v5 Protocol Copyright: 
/// 
/// Copyright © 2008-2013 Kristian Høgsberg
/// Copyright © 2013      Rafael Antognolli
/// Copyright © 2013      Jasper St. Pierre
/// Copyright © 2010-2013 Intel Corporation
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// create desktop-style surfaces
/// 
/// xdg_shell allows clients to turn a wl_surface into a "real window"
/// which can be dragged, resized, stacked, and moved around by the
/// user. Everything about this interface is suited towards traditional
/// desktop environments.
/// 
class XdgShell extends Proxy implements Dispatcher{
  final Context context;

  XdgShell(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> useUnstableVersion(int version) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        version,
      ],
      [
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getXdgSurface(Surface surface) async {
  var id =  XdgShell(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getXdgPopup(Surface surface, Surface parent, Seat seat, int serial, int x, int y) async {
  var id =  XdgShell(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        id,
        surface,
        parent,
        seat,
        serial,
        x,
        y,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> pong(int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        serial,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// check if the client is alive
/// 
/// The ping event asks the client if it's still alive. Pass the
/// serial specified in the event back to the compositor by sending
/// a "pong" request back with the specified serial.
/// 
/// Compositors can use this to determine if the client is still
/// alive. It's unspecified what will happen if the client doesn't
/// respond to the ping request, or in what timeframe. Clients should
/// try to respond in a reasonable amount of time.
/// 
/// A compositor is free to ping in any way it wants, but a client must
/// always respond to any xdg_shell object it created.
/// 
 void onping(void Function(int serial) handler) {
   _pingHandler = handler;
 }

 void Function(int serial)? _pingHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_pingHandler != null) {
         _pingHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// latest protocol version
/// 
/// The 'current' member of this enum gives the version of the
/// protocol.  Implementations can compare this to the version
/// they implement using static_assert to ensure the protocol and
/// implementation versions match.
/// 

enum XdgShellversion {
  /// Always the latest version
  current,
}

/// 
/// 

enum XdgShellerror {
  /// given wl_surface has another role
  role,
  /// xdg_shell was destroyed before children
  defunctSurfaces,
  /// the client tried to map or destroy a non-topmost popup
  notTheTopmostPopup,
  /// the client specified an invalid popup parent surface
  invalidPopupParent,
}

/// A desktop window
/// 
/// An interface that may be implemented by a wl_surface, for
/// implementations that provide a desktop-style user interface.
/// 
/// It provides requests to treat surfaces like windows, allowing to set
/// properties like maximized, fullscreen, minimized, and to move and resize
/// them, and associate metadata like title and app id.
/// 
/// The client must call wl_surface.commit on the corresponding wl_surface
/// for the xdg_surface state to take effect. Prior to committing the new
/// state, it can set up initial configuration, such as maximizing or setting
/// a window geometry.
/// 
/// Even without attaching a buffer the compositor must respond to initial
/// committed configuration, for instance sending a configure event with
/// expected window geometry if the client maximized its surface during
/// initialization.
/// 
/// For a surface to be mapped by the compositor the client must have
/// committed both an xdg_surface state and a buffer.
/// 
class XdgSurface extends Proxy implements Dispatcher{
  final Context context;

  XdgSurface(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setParent(XdgSurface parent) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        parent,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setTitle(String title) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        title,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setAppId(String appId) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        appId,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> showWindowMenu(Seat seat, int serial, int x, int y) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      4,
      [
        seat,
        serial,
        x,
        y,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> move(Seat seat, int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      5,
      [
        seat,
        serial,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> resize(Seat seat, int serial, int edges) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      6,
      [
        seat,
        serial,
        edges,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> ackConfigure(int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      7,
      [
        serial,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setWindowGeometry(int x, int y, int width, int height) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      8,
      [
        x,
        y,
        width,
        height,
      ],
      [
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setMaximized() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      9,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> unsetMaximized() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      10,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setFullscreen(Output output) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      11,
      [
        output,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> unsetFullscreen() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      12,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setMinimized() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      13,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// suggest a surface change
/// 
/// The configure event asks the client to resize its surface or to
/// change its state.
/// 
/// The width and height arguments specify a hint to the window
/// about how its surface should be resized in window geometry
/// coordinates. See set_window_geometry.
/// 
/// If the width or height arguments are zero, it means the client
/// should decide its own window dimension. This may happen when the
/// compositor need to configure the state of the surface but doesn't
/// have any information about any previous or expected dimension.
/// 
/// The states listed in the event specify how the width/height
/// arguments should be interpreted, and possibly how it should be
/// drawn.
/// 
/// Clients should arrange their surface for the new size and
/// states, and then send a ack_configure request with the serial
/// sent in this configure event at some point before committing
/// the new surface.
/// 
/// If the client receives multiple configure events before it
/// can respond to one, it is free to discard all but the last
/// event it received.
/// 
 void onconfigure(void Function(int width, int height, List<int> states, int serial) handler) {
   _configureHandler = handler;
 }

 void Function(int width, int height, List<int> states, int serial)? _configureHandler;

 /// surface wants to be closed
/// 
/// The close event is sent by the compositor when the user
/// wants the surface to be closed. This should be equivalent to
/// the user clicking the close button in client-side decorations,
/// if your application has any...
/// 
/// This is only a request that the user intends to close your
/// window. The client may choose to ignore this request, or show
/// a dialog to ask the user to save their data...
/// 
 void onclose(void Function() handler) {
   _closeHandler = handler;
 }

 void Function()? _closeHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_configureHandler != null) {
         _configureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           getArray(data, 8),
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 1:
       if (_closeHandler != null) {
         _closeHandler!(
         );
       }
       break;
   }
 }
}

/// edge values for resizing
/// 
/// These values are used to indicate which edge of a surface
/// is being dragged in a resize operation.
/// 

enum XdgSurfaceresizeEdge {
  /// 
  none,
  /// 
  top,
  /// 
  bottom,
  /// 
  left,
  /// 
  topLeft,
  /// 
  bottomLeft,
  /// 
  right,
  /// 
  topRight,
  /// 
  bottomRight,
}

/// types of state on the surface
/// 
/// The different state values used on the surface. This is designed for
/// state values like maximized, fullscreen. It is paired with the
/// configure event to ensure that both the client and the compositor
/// setting the state can be synchronized.
/// 
/// States set in this way are double-buffered, see wl_surface.commit.
/// 
/// Desktop environments may extend this enum by taking up a range of
/// values and documenting the range they chose in this description.
/// They are not required to document the values for the range that they
/// chose. Ideally, any good extensions from a desktop environment should
/// make its way into standardization into this enum.
/// 
/// The current reserved ranges are:
/// 
/// 0x0000 - 0x0FFF: xdg-shell core values, documented below.
/// 0x1000 - 0x1FFF: GNOME
/// 0x2000 - 0x2FFF: EFL
/// 

enum XdgSurfacestate {
  /// the surface is maximized
  maximized,
  /// the surface is fullscreen
  fullscreen,
  /// the surface is being resized
  resizing,
  /// the surface is now activated
  activated,
}

/// short-lived, popup surfaces for menus
/// 
/// A popup surface is a short-lived, temporary surface that can be
/// used to implement menus. It takes an explicit grab on the surface
/// that will be dismissed when the user dismisses the popup. This can
/// be done by the user clicking outside the surface, using the keyboard,
/// or even locking the screen through closing the lid or a timeout.
/// 
/// When the popup is dismissed, a popup_done event will be sent out,
/// and at the same time the surface will be unmapped. The xdg_popup
/// object is now inert and cannot be reactivated, so clients should
/// destroy it. Explicitly destroying the xdg_popup object will also
/// dismiss the popup and unmap the surface.
/// 
/// Clients will receive events for all their surfaces during this
/// grab (which is an "owner-events" grab in X11 parlance). This is
/// done so that users can navigate through submenus and other
/// "nested" popup windows without having to dismiss the topmost
/// popup.
/// 
/// Clients that want to dismiss the popup when another surface of
/// their own is clicked should dismiss the popup using the destroy
/// request.
/// 
/// The parent surface must have either an xdg_surface or xdg_popup
/// role.
/// 
/// Specifying an xdg_popup for the parent means that the popups are
/// nested, with this popup now being the topmost popup. Nested
/// popups must be destroyed in the reverse order they were created
/// in, e.g. the only popup you are allowed to destroy at all times
/// is the topmost one.
/// 
/// If there is an existing popup when creating a new popup, the
/// parent must be the current topmost popup.
/// 
/// A parent surface must be mapped before the new popup is mapped.
/// 
/// When compositors choose to dismiss a popup, they will likely
/// dismiss every nested popup as well. When a compositor dismisses
/// popups, it will follow the same dismissing order as required
/// from the client.
/// 
/// The x and y arguments passed when creating the popup object specify
/// where the top left of the popup should be placed, relative to the
/// local surface coordinates of the parent surface. See
/// xdg_shell.get_xdg_popup.
/// 
/// The client must call wl_surface.commit on the corresponding wl_surface
/// for the xdg_popup state to take effect.
/// 
/// For a surface to be mapped by the compositor the client must have
/// committed both the xdg_popup state and a buffer.
/// 
class XdgPopup extends Proxy implements Dispatcher{
  final Context context;

  XdgPopup(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// popup interaction is done
/// 
/// The popup_done event is sent out when a popup is dismissed by the
/// compositor. The client should destroy the xdg_popup object at this
/// point.
/// 
 void onpopupDone(void Function() handler) {
   _popupDoneHandler = handler;
 }

 void Function()? _popupDoneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_popupDoneHandler != null) {
         _popupDoneHandler!(
         );
       }
       break;
   }
 }
}

