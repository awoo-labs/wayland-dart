// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
//
// xdg_decoration_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2018 Simon Ser
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'package:wayland/generated/stable/xdg-shell/xdg_shell.dart';
import 'dart:typed_data';
/// window decoration manager
/// 
/// This interface allows a compositor to announce support for server-side
/// decorations.
/// 
/// A window decoration is a set of window controls as deemed appropriate by
/// the party managing them, such as user interface components used to move,
/// resize and change a window's state.
/// 
/// A client can use this protocol to request being decorated by a supporting
/// compositor.
/// 
/// If compositor and client do not negotiate the use of a server-side
/// decoration using this protocol, clients continue to self-decorate as they
/// see fit.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZxdgDecorationManagerV1 extends Proxy{
  final Context context;

  ZxdgDecorationManagerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getToplevelDecoration(XdgToplevel toplevel) async {
  var id =  ZxdgDecorationManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        toplevel,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// decoration object for a toplevel surface
/// 
/// The decoration object allows the compositor to toggle server-side window
/// decorations for a toplevel surface. The client can request to switch to
/// another mode.
/// 
/// The xdg_toplevel_decoration object must be destroyed before its
/// xdg_toplevel.
/// 
class ZxdgToplevelDecorationV1 extends Proxy implements Dispatcher{
  final Context context;

  ZxdgToplevelDecorationV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setMode(int mode) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        mode,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> unsetMode() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// notify a decoration mode change
/// 
/// The configure event configures the effective decoration mode. The
/// configured state should not be applied immediately. Clients must send an
/// ack_configure in response to this event. See xdg_surface.configure and
/// xdg_surface.ack_configure for details.
/// 
/// A configure event can be sent at any time. The specified mode must be
/// obeyed by the client.
/// 
 void onconfigure(void Function(int mode) handler) {
   _configureHandler = handler;
 }

 void Function(int mode)? _configureHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_configureHandler != null) {
         _configureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum ZxdgToplevelDecorationV1error {
  /// xdg_toplevel has a buffer attached before configure
  unconfiguredBuffer,
  /// xdg_toplevel already has a decoration object
  alreadyConstructed,
  /// xdg_toplevel destroyed before the decoration object
  orphaned,
}

/// window decoration modes
/// 
/// These values describe window decoration modes.
/// 

enum ZxdgToplevelDecorationV1mode {
  /// no server-side window decoration
  clientSide,
  /// server-side window decoration
  serverSide,
}

