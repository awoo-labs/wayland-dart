// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
//
// xdg_decoration_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2018 Simon Ser
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'package:wayland/generated/stable/xdg-shell/xdg_shell.dart';
import 'dart:async';
import 'dart:typed_data';


/// window decoration manager
/// 
/// This interface allows a compositor to announce support for server-side
/// decorations.
/// 
/// A window decoration is a set of window controls as deemed appropriate by
/// the party managing them, such as user interface components used to move,
/// resize and change a window's state.
/// 
/// A client can use this protocol to request being decorated by a supporting
/// compositor.
/// 
/// If compositor and client do not negotiate the use of a server-side
/// decoration using this protocol, clients continue to self-decorate as they
/// see fit.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZxdgDecorationManagerV1 extends Proxy{
  final Context context;

  ZxdgDecorationManagerV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the decoration manager object
/// 
/// Destroy the decoration manager. This doesn't destroy objects created
/// with the manager.
/// 
  Future<void> destroy() async {
    print("ZxdgDecorationManagerV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// create a new toplevel decoration object
/// 
/// Create a new decoration object associated with the given toplevel.
/// 
/// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
/// buffer attached or committed is a client error, and any attempts by a
/// client to attach or manipulate a buffer prior to the first
/// xdg_toplevel_decoration.configure event must also be treated as
/// errors.
/// 
/// [id]:
/// [toplevel]:
  Future<ZxdgToplevelDecorationV1> getToplevelDecoration(XdgToplevel toplevel) async {
  var id =  ZxdgToplevelDecorationV1(context);
    print("ZxdgDecorationManagerV1::getToplevelDecoration  id: $id toplevel: $toplevel");
    final message = WaylandMessage(
      objectId,
      1,
      [
        id,
        toplevel,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

}


/// notify a decoration mode change
/// 
/// The configure event configures the effective decoration mode. The
/// configured state should not be applied immediately. Clients must send an
/// ack_configure in response to this event. See xdg_surface.configure and
/// xdg_surface.ack_configure for details.
/// 
/// A configure event can be sent at any time. The specified mode must be
/// obeyed by the client.
/// 
class ZxdgToplevelDecorationV1ConfigureEvent {
/// the decoration mode
  final int mode;

  ZxdgToplevelDecorationV1ConfigureEvent(
this.mode,

);

@override
String toString(){
  return """ZxdgToplevelDecorationV1ConfigureEvent: {
    mode: $mode,
  }""";
}

}

typedef ZxdgToplevelDecorationV1ConfigureEventHandler = void Function(ZxdgToplevelDecorationV1ConfigureEvent);


/// decoration object for a toplevel surface
/// 
/// The decoration object allows the compositor to toggle server-side window
/// decorations for a toplevel surface. The client can request to switch to
/// another mode.
/// 
/// The xdg_toplevel_decoration object must be destroyed before its
/// xdg_toplevel.
/// 
class ZxdgToplevelDecorationV1 extends Proxy implements Dispatcher{
  final Context context;

  ZxdgToplevelDecorationV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the decoration object
/// 
/// Switch back to a mode without any server-side decorations at the next
/// commit.
/// 
  Future<void> destroy() async {
    print("ZxdgToplevelDecorationV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// set the decoration mode
/// 
/// Set the toplevel surface decoration mode. This informs the compositor
/// that the client prefers the provided decoration mode.
/// 
/// After requesting a decoration mode, the compositor will respond by
/// emitting an xdg_surface.configure event. The client should then update
/// its content, drawing it without decorations if the received mode is
/// server-side decorations. The client must also acknowledge the configure
/// when committing the new content (see xdg_surface.ack_configure).
/// 
/// The compositor can decide not to use the client's mode and enforce a
/// different mode instead.
/// 
/// Clients whose decoration mode depend on the xdg_toplevel state may send
/// a set_mode request in response to an xdg_surface.configure event and wait
/// for the next xdg_surface.configure event to prevent unwanted state.
/// Such clients are responsible for preventing configure loops and must
/// make sure not to send multiple successive set_mode requests with the
/// same decoration mode.
/// 
/// [mode]: the decoration mode
  Future<void> setMode(int mode) async {
    print("ZxdgToplevelDecorationV1::setMode  mode: $mode");
    final message = WaylandMessage(
      objectId,
      1,
      [
        mode,
      ],
      [
        WaylandType.uint,
      ],
    );
    await context.sendMessage(message);
  }

/// unset the decoration mode
/// 
/// Unset the toplevel surface decoration mode. This informs the compositor
/// that the client doesn't prefer a particular decoration mode.
/// 
/// This request has the same semantics as set_mode.
/// 
  Future<void> unsetMode() async {
    print("ZxdgToplevelDecorationV1::unsetMode ");
    final message = WaylandMessage(
      objectId,
      2,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// notify a decoration mode change
/// 
/// The configure event configures the effective decoration mode. The
/// configured state should not be applied immediately. Clients must send an
/// ack_configure in response to this event. See xdg_surface.configure and
/// xdg_surface.ack_configure for details.
/// 
/// A configure event can be sent at any time. The specified mode must be
/// obeyed by the client.
/// 
/// Event handler for Configure
/// - [mode]: the decoration mode
 void onConfigure(ZxdgToplevelDecorationV1ConfigureEventHandler handler) {
   _configureHandler = handler;
 }

 ZxdgToplevelDecorationV1ConfigureEventHandler? _configureHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_configureHandler != null) {
var event = ZxdgToplevelDecorationV1ConfigureEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
        );
         _configureHandler!(event);
       }
       break;
   }
 }
}

/// 
/// 

enum ZxdgToplevelDecorationV1error {
/// xdg_toplevel has a buffer attached before configure
  unconfiguredBuffer,
/// xdg_toplevel already has a decoration object
  alreadyConstructed,
/// xdg_toplevel destroyed before the decoration object
  orphaned,
}

/// window decoration modes
/// 
/// These values describe window decoration modes.
/// 

enum ZxdgToplevelDecorationV1mode {
/// no server-side window decoration
  clientSide,
/// server-side window decoration
  serverSide,
}

