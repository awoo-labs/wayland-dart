// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/linux-explicit-synchronization/linux-explicit-synchronization-unstable-v1.xml
//
// zwp_linux_explicit_synchronization_unstable_v1 Protocol Copyright: 
/// 
/// Copyright 2016 The Chromium Authors.
/// Copyright 2017 Intel Corporation
/// Copyright 2018 Collabora, Ltd
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// protocol for providing explicit synchronization
/// 
/// This global is a factory interface, allowing clients to request
/// explicit synchronization for buffers on a per-surface basis.
/// 
/// See zwp_linux_surface_synchronization_v1 for more information.
/// 
/// This interface is derived from Chromium's
/// zcr_linux_explicit_synchronization_v1.
/// 
/// Note: this protocol is superseded by linux-drm-syncobj.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpLinuxExplicitSynchronizationV1 extends Proxy{
  final Context context;

  ZwpLinuxExplicitSynchronizationV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getSynchronization(Surface surface) async {
  var id =  ZwpLinuxExplicitSynchronizationV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum ZwpLinuxExplicitSynchronizationV1error {
  /// the surface already has a synchronization object associated
  synchronizationExists,
}

/// per-surface explicit synchronization support
/// 
/// This object implements per-surface explicit synchronization.
/// 
/// Synchronization refers to co-ordination of pipelined operations performed
/// on buffers. Most GPU clients will schedule an asynchronous operation to
/// render to the buffer, then immediately send the buffer to the compositor
/// to be attached to a surface.
/// 
/// In implicit synchronization, ensuring that the rendering operation is
/// complete before the compositor displays the buffer is an implementation
/// detail handled by either the kernel or userspace graphics driver.
/// 
/// By contrast, in explicit synchronization, dma_fence objects mark when the
/// asynchronous operations are complete. When submitting a buffer, the
/// client provides an acquire fence which will be waited on before the
/// compositor accesses the buffer. The Wayland server, through a
/// zwp_linux_buffer_release_v1 object, will inform the client with an event
/// which may be accompanied by a release fence, when the compositor will no
/// longer access the buffer contents due to the specific commit that
/// requested the release event.
/// 
/// Each surface can be associated with only one object of this interface at
/// any time.
/// 
/// In version 1 of this interface, explicit synchronization is only
/// guaranteed to be supported for buffers created with any version of the
/// wp_linux_dmabuf buffer factory. Version 2 additionally guarantees
/// explicit synchronization support for opaque EGL buffers, which is a type
/// of platform specific buffers described in the EGL_WL_bind_wayland_display
/// extension. Compositors are free to support explicit synchronization for
/// additional buffer types.
/// 
class ZwpLinuxSurfaceSynchronizationV1 extends Proxy{
  final Context context;

  ZwpLinuxSurfaceSynchronizationV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setAcquireFence(int fd) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        fd,
      ],
      [
        WaylandType.fd,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getRelease() async {
  var release =  ZwpLinuxSurfaceSynchronizationV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        release,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum ZwpLinuxSurfaceSynchronizationV1error {
  /// the fence specified by the client could not be imported
  invalidFence,
  /// multiple fences added for a single surface commit
  duplicateFence,
  /// multiple releases added for a single surface commit
  duplicateRelease,
  /// the associated wl_surface was destroyed
  noSurface,
  /// the buffer does not support explicit synchronization
  unsupportedBuffer,
  /// no buffer was attached
  noBuffer,
}

/// buffer release explicit synchronization
/// 
/// This object is instantiated in response to a
/// zwp_linux_surface_synchronization_v1.get_release request.
/// 
/// It provides an alternative to wl_buffer.release events, providing a
/// unique release from a single wl_surface.commit request. The release event
/// also supports explicit synchronization, providing a fence FD for the
/// client to synchronize against.
/// 
/// Exactly one event, either a fenced_release or an immediate_release, will
/// be emitted for the wl_surface.commit request. The compositor can choose
/// release by release which event it uses.
/// 
/// This event does not replace wl_buffer.release events; servers are still
/// required to send those events.
/// 
/// Once a buffer release object has delivered a 'fenced_release' or an
/// 'immediate_release' event it is automatically destroyed.
/// 
class ZwpLinuxBufferReleaseV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLinuxBufferReleaseV1(this.context) : super(context.allocateClientId());

 /// release buffer with fence
/// 
/// Sent when the compositor has finalised its usage of the associated
/// buffer for the relevant commit, providing a dma_fence which will be
/// signaled when all operations by the compositor on that buffer for that
/// commit have finished.
/// 
/// Once the fence has signaled, and assuming the associated buffer is not
/// pending release from other wl_surface.commit requests, no additional
/// explicit or implicit synchronization is required to safely reuse or
/// destroy the buffer.
/// 
/// This event destroys the zwp_linux_buffer_release_v1 object.
/// 
 void onfencedRelease(void Function(int fence) handler) {
   _fencedReleaseHandler = handler;
 }

 void Function(int fence)? _fencedReleaseHandler;

 /// release buffer immediately
/// 
/// Sent when the compositor has finalised its usage of the associated
/// buffer for the relevant commit, and either performed no operations
/// using it, or has a guarantee that all its operations on that buffer for
/// that commit have finished.
/// 
/// Once this event is received, and assuming the associated buffer is not
/// pending release from other wl_surface.commit requests, no additional
/// explicit or implicit synchronization is required to safely reuse or
/// destroy the buffer.
/// 
/// This event destroys the zwp_linux_buffer_release_v1 object.
/// 
 void onimmediateRelease(void Function() handler) {
   _immediateReleaseHandler = handler;
 }

 void Function()? _immediateReleaseHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_fencedReleaseHandler != null) {
         _fencedReleaseHandler!(
           fd,
         );
       }
       break;
     case 1:
       if (_immediateReleaseHandler != null) {
         _immediateReleaseHandler!(
         );
       }
       break;
   }
 }
}

