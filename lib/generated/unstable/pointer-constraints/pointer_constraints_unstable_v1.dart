// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml
//
// pointer_constraints_unstable_v1 Protocol Copyright: 
/// 
/// Copyright © 2014      Jonas Ådahl
/// Copyright © 2015      Red Hat Inc.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// constrain the movement of a pointer
/// 
/// The global interface exposing pointer constraining functionality. It
/// exposes two requests: lock_pointer for locking the pointer to its
/// position, and confine_pointer for locking the pointer to a region.
/// 
/// The lock_pointer and confine_pointer requests create the objects
/// wp_locked_pointer and wp_confined_pointer respectively, and the client can
/// use these objects to interact with the lock.
/// 
/// For any surface, only one lock or confinement may be active across all
/// wl_pointer objects of the same seat. If a lock or confinement is requested
/// when another lock or confinement is active or requested on the same surface
/// and with any of the wl_pointer objects of the same seat, an
/// 'already_constrained' error will be raised.
/// 
class ZwpPointerConstraintsV1 extends Proxy{
  final Context context;

  ZwpPointerConstraintsV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> lockPointer(Surface surface, Pointer pointer, Region region, int lifetime) async {
  var id =  ZwpPointerConstraintsV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        surface,
        pointer,
        region,
        lifetime,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> confinePointer(Surface surface, Pointer pointer, Region region, int lifetime) async {
  var id =  ZwpPointerConstraintsV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        id,
        surface,
        pointer,
        region,
        lifetime,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

}

/// wp_pointer_constraints error values
/// 
/// These errors can be emitted in response to wp_pointer_constraints
/// requests.
/// 

enum ZwpPointerConstraintsV1error {
  /// pointer constraint already requested on that surface
  alreadyConstrained,
}

/// constraint lifetime
/// 
/// These values represent different lifetime semantics. They are passed
/// as arguments to the factory requests to specify how the constraint
/// lifetimes should be managed.
/// 

enum ZwpPointerConstraintsV1lifetime {
  /// 
  oneshot,
  /// 
  persistent,
}

/// receive relative pointer motion events
/// 
/// The wp_locked_pointer interface represents a locked pointer state.
/// 
/// While the lock of this object is active, the wl_pointer objects of the
/// associated seat will not emit any wl_pointer.motion events.
/// 
/// This object will send the event 'locked' when the lock is activated.
/// Whenever the lock is activated, it is guaranteed that the locked surface
/// will already have received pointer focus and that the pointer will be
/// within the region passed to the request creating this object.
/// 
/// To unlock the pointer, send the destroy request. This will also destroy
/// the wp_locked_pointer object.
/// 
/// If the compositor decides to unlock the pointer the unlocked event is
/// sent. See wp_locked_pointer.unlock for details.
/// 
/// When unlocking, the compositor may warp the cursor position to the set
/// cursor position hint. If it does, it will not result in any relative
/// motion events emitted via wp_relative_pointer.
/// 
/// If the surface the lock was requested on is destroyed and the lock is not
/// yet activated, the wp_locked_pointer object is now defunct and must be
/// destroyed.
/// 
class ZwpLockedPointerV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLockedPointerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setCursorPositionHint(double surfaceX, double surfaceY) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        surfaceX,
        surfaceY,
      ],
      [
        WaylandType.fixed,
        WaylandType.fixed,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setRegion(Region region) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

 /// lock activation event
/// 
/// Notification that the pointer lock of the seat's pointer is activated.
/// 
 void onlocked(void Function() handler) {
   _lockedHandler = handler;
 }

 void Function()? _lockedHandler;

 /// lock deactivation event
/// 
/// Notification that the pointer lock of the seat's pointer is no longer
/// active. If this is a oneshot pointer lock (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer lock (see
/// wp_pointer_constraints.lifetime) this pointer lock may again
/// reactivate in the future.
/// 
 void onunlocked(void Function() handler) {
   _unlockedHandler = handler;
 }

 void Function()? _unlockedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_lockedHandler != null) {
         _lockedHandler!(
         );
       }
       break;
     case 1:
       if (_unlockedHandler != null) {
         _unlockedHandler!(
         );
       }
       break;
   }
 }
}

/// confined pointer object
/// 
/// The wp_confined_pointer interface represents a confined pointer state.
/// 
/// This object will send the event 'confined' when the confinement is
/// activated. Whenever the confinement is activated, it is guaranteed that
/// the surface the pointer is confined to will already have received pointer
/// focus and that the pointer will be within the region passed to the request
/// creating this object. It is up to the compositor to decide whether this
/// requires some user interaction and if the pointer will warp to within the
/// passed region if outside.
/// 
/// To unconfine the pointer, send the destroy request. This will also destroy
/// the wp_confined_pointer object.
/// 
/// If the compositor decides to unconfine the pointer the unconfined event is
/// sent. The wp_confined_pointer object is at this point defunct and should
/// be destroyed.
/// 
class ZwpConfinedPointerV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpConfinedPointerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setRegion(Region region) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

 /// pointer confined
/// 
/// Notification that the pointer confinement of the seat's pointer is
/// activated.
/// 
 void onconfined(void Function() handler) {
   _confinedHandler = handler;
 }

 void Function()? _confinedHandler;

 /// pointer unconfined
/// 
/// Notification that the pointer confinement of the seat's pointer is no
/// longer active. If this is a oneshot pointer confinement (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer confinement (see
/// wp_pointer_constraints.lifetime) this pointer confinement may again
/// reactivate in the future.
/// 
 void onunconfined(void Function() handler) {
   _unconfinedHandler = handler;
 }

 void Function()? _unconfinedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_confinedHandler != null) {
         _confinedHandler!(
         );
       }
       break;
     case 1:
       if (_unconfinedHandler != null) {
         _unconfinedHandler!(
         );
       }
       break;
   }
 }
}

