// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml
//
// pointer_constraints_unstable_v1 Protocol Copyright: 
/// 
/// Copyright © 2014      Jonas Ådahl
/// Copyright © 2015      Red Hat Inc.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:async';
import 'dart:typed_data';


/// constrain the movement of a pointer
/// 
/// The global interface exposing pointer constraining functionality. It
/// exposes two requests: lock_pointer for locking the pointer to its
/// position, and confine_pointer for locking the pointer to a region.
/// 
/// The lock_pointer and confine_pointer requests create the objects
/// wp_locked_pointer and wp_confined_pointer respectively, and the client can
/// use these objects to interact with the lock.
/// 
/// For any surface, only one lock or confinement may be active across all
/// wl_pointer objects of the same seat. If a lock or confinement is requested
/// when another lock or confinement is active or requested on the same surface
/// and with any of the wl_pointer objects of the same seat, an
/// 'already_constrained' error will be raised.
/// 
class ZwpPointerConstraintsV1 extends Proxy{
  final Context context;

  ZwpPointerConstraintsV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the pointer constraints manager object
/// 
/// Used by the client to notify the server that it will no longer use this
/// pointer constraints object.
/// 
  Future<void> destroy() async {
    print("ZwpPointerConstraintsV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// lock pointer to a position
/// 
/// The lock_pointer request lets the client request to disable movements of
/// the virtual pointer (i.e. the cursor), effectively locking the pointer
/// to a position. This request may not take effect immediately; in the
/// future, when the compositor deems implementation-specific constraints
/// are satisfied, the pointer lock will be activated and the compositor
/// sends a locked event.
/// 
/// The protocol provides no guarantee that the constraints are ever
/// satisfied, and does not require the compositor to send an error if the
/// constraints cannot ever be satisfied. It is thus possible to request a
/// lock that will never activate.
/// 
/// There may not be another pointer constraint of any kind requested or
/// active on the surface for any of the wl_pointer objects of the seat of
/// the passed pointer when requesting a lock. If there is, an error will be
/// raised. See general pointer lock documentation for more details.
/// 
/// The intersection of the region passed with this request and the input
/// region of the surface is used to determine where the pointer must be
/// in order for the lock to activate. It is up to the compositor whether to
/// warp the pointer or require some kind of user interaction for the lock
/// to activate. If the region is null the surface input region is used.
/// 
/// A surface may receive pointer focus without the lock being activated.
/// 
/// The request creates a new object wp_locked_pointer which is used to
/// interact with the lock as well as receive updates about its state. See
/// the the description of wp_locked_pointer for further information.
/// 
/// Note that while a pointer is locked, the wl_pointer objects of the
/// corresponding seat will not emit any wl_pointer.motion events, but
/// relative motion events will still be emitted via wp_relative_pointer
/// objects of the same seat. wl_pointer.axis and wl_pointer.button events
/// are unaffected.
/// 
/// [id]:
/// [surface]: surface to lock pointer to
/// [pointer]: the pointer that should be locked
/// [region]: region of surface
/// [lifetime]: lock lifetime
  Future<ZwpLockedPointerV1> lockPointer(Surface surface, Pointer pointer, Region region, int lifetime) async {
  var id =  ZwpLockedPointerV1(context);
    print("ZwpPointerConstraintsV1::lockPointer  id: $id surface: $surface pointer: $pointer region: $region lifetime: $lifetime");
    final message = WaylandMessage(
      objectId,
      1,
      [
        id,
        surface,
        pointer,
        region,
        lifetime,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

/// confine pointer to a region
/// 
/// The confine_pointer request lets the client request to confine the
/// pointer cursor to a given region. This request may not take effect
/// immediately; in the future, when the compositor deems implementation-
/// specific constraints are satisfied, the pointer confinement will be
/// activated and the compositor sends a confined event.
/// 
/// The intersection of the region passed with this request and the input
/// region of the surface is used to determine where the pointer must be
/// in order for the confinement to activate. It is up to the compositor
/// whether to warp the pointer or require some kind of user interaction for
/// the confinement to activate. If the region is null the surface input
/// region is used.
/// 
/// The request will create a new object wp_confined_pointer which is used
/// to interact with the confinement as well as receive updates about its
/// state. See the the description of wp_confined_pointer for further
/// information.
/// 
/// [id]:
/// [surface]: surface to lock pointer to
/// [pointer]: the pointer that should be confined
/// [region]: region of surface
/// [lifetime]: confinement lifetime
  Future<ZwpConfinedPointerV1> confinePointer(Surface surface, Pointer pointer, Region region, int lifetime) async {
  var id =  ZwpConfinedPointerV1(context);
    print("ZwpPointerConstraintsV1::confinePointer  id: $id surface: $surface pointer: $pointer region: $region lifetime: $lifetime");
    final message = WaylandMessage(
      objectId,
      2,
      [
        id,
        surface,
        pointer,
        region,
        lifetime,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
        WaylandType.object,
        WaylandType.uint,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

}

/// wp_pointer_constraints error values
/// 
/// These errors can be emitted in response to wp_pointer_constraints
/// requests.
/// 

enum ZwpPointerConstraintsV1error {
/// pointer constraint already requested on that surface
  alreadyConstrained,
}

/// constraint lifetime
/// 
/// These values represent different lifetime semantics. They are passed
/// as arguments to the factory requests to specify how the constraint
/// lifetimes should be managed.
/// 

enum ZwpPointerConstraintsV1lifetime {
/// 
  oneshot,
/// 
  persistent,
}


/// lock activation event
/// 
/// Notification that the pointer lock of the seat's pointer is activated.
/// 
class ZwpLockedPointerV1LockedEvent {
  ZwpLockedPointerV1LockedEvent(
);

@override
String toString(){
  return """ZwpLockedPointerV1LockedEvent: {
  }""";
}

}

typedef ZwpLockedPointerV1LockedEventHandler = void Function(ZwpLockedPointerV1LockedEvent);

/// lock deactivation event
/// 
/// Notification that the pointer lock of the seat's pointer is no longer
/// active. If this is a oneshot pointer lock (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer lock (see
/// wp_pointer_constraints.lifetime) this pointer lock may again
/// reactivate in the future.
/// 
class ZwpLockedPointerV1UnlockedEvent {
  ZwpLockedPointerV1UnlockedEvent(
);

@override
String toString(){
  return """ZwpLockedPointerV1UnlockedEvent: {
  }""";
}

}

typedef ZwpLockedPointerV1UnlockedEventHandler = void Function(ZwpLockedPointerV1UnlockedEvent);


/// receive relative pointer motion events
/// 
/// The wp_locked_pointer interface represents a locked pointer state.
/// 
/// While the lock of this object is active, the wl_pointer objects of the
/// associated seat will not emit any wl_pointer.motion events.
/// 
/// This object will send the event 'locked' when the lock is activated.
/// Whenever the lock is activated, it is guaranteed that the locked surface
/// will already have received pointer focus and that the pointer will be
/// within the region passed to the request creating this object.
/// 
/// To unlock the pointer, send the destroy request. This will also destroy
/// the wp_locked_pointer object.
/// 
/// If the compositor decides to unlock the pointer the unlocked event is
/// sent. See wp_locked_pointer.unlock for details.
/// 
/// When unlocking, the compositor may warp the cursor position to the set
/// cursor position hint. If it does, it will not result in any relative
/// motion events emitted via wp_relative_pointer.
/// 
/// If the surface the lock was requested on is destroyed and the lock is not
/// yet activated, the wp_locked_pointer object is now defunct and must be
/// destroyed.
/// 
class ZwpLockedPointerV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpLockedPointerV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the locked pointer object
/// 
/// Destroy the locked pointer object. If applicable, the compositor will
/// unlock the pointer.
/// 
  Future<void> destroy() async {
    print("ZwpLockedPointerV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// set the pointer cursor position hint
/// 
/// Set the cursor position hint relative to the top left corner of the
/// surface.
/// 
/// If the client is drawing its own cursor, it should update the position
/// hint to the position of its own cursor. A compositor may use this
/// information to warp the pointer upon unlock in order to avoid pointer
/// jumps.
/// 
/// The cursor position hint is double-buffered state, see
/// wl_surface.commit.
/// 
/// [surface_x]: surface-local x coordinate
/// [surface_y]: surface-local y coordinate
  Future<void> setCursorPositionHint(double surfaceX, double surfaceY) async {
    print("ZwpLockedPointerV1::setCursorPositionHint  surfaceX: $surfaceX surfaceY: $surfaceY");
    final message = WaylandMessage(
      objectId,
      1,
      [
        surfaceX,
        surfaceY,
      ],
      [
        WaylandType.fixed,
        WaylandType.fixed,
      ],
    );
    await context.sendMessage(message);
  }

/// set a new lock region
/// 
/// Set a new region used to lock the pointer.
/// 
/// The new lock region is double-buffered, see wl_surface.commit.
/// 
/// For details about the lock region, see wp_locked_pointer.
/// 
/// [region]: region of surface
  Future<void> setRegion(Region region) async {
    print("ZwpLockedPointerV1::setRegion  region: $region");
    final message = WaylandMessage(
      objectId,
      2,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
  }

/// lock activation event
/// 
/// Notification that the pointer lock of the seat's pointer is activated.
/// 
/// Event handler for Locked
 void onLocked(ZwpLockedPointerV1LockedEventHandler handler) {
   _lockedHandler = handler;
 }

 ZwpLockedPointerV1LockedEventHandler? _lockedHandler;

/// lock deactivation event
/// 
/// Notification that the pointer lock of the seat's pointer is no longer
/// active. If this is a oneshot pointer lock (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer lock (see
/// wp_pointer_constraints.lifetime) this pointer lock may again
/// reactivate in the future.
/// 
/// Event handler for Unlocked
 void onUnlocked(ZwpLockedPointerV1UnlockedEventHandler handler) {
   _unlockedHandler = handler;
 }

 ZwpLockedPointerV1UnlockedEventHandler? _unlockedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_lockedHandler != null) {
var event = ZwpLockedPointerV1LockedEvent(
        );
         _lockedHandler!(event);
       }
       break;
     case 1:
       if (_unlockedHandler != null) {
var event = ZwpLockedPointerV1UnlockedEvent(
        );
         _unlockedHandler!(event);
       }
       break;
   }
 }
}


/// pointer confined
/// 
/// Notification that the pointer confinement of the seat's pointer is
/// activated.
/// 
class ZwpConfinedPointerV1ConfinedEvent {
  ZwpConfinedPointerV1ConfinedEvent(
);

@override
String toString(){
  return """ZwpConfinedPointerV1ConfinedEvent: {
  }""";
}

}

typedef ZwpConfinedPointerV1ConfinedEventHandler = void Function(ZwpConfinedPointerV1ConfinedEvent);

/// pointer unconfined
/// 
/// Notification that the pointer confinement of the seat's pointer is no
/// longer active. If this is a oneshot pointer confinement (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer confinement (see
/// wp_pointer_constraints.lifetime) this pointer confinement may again
/// reactivate in the future.
/// 
class ZwpConfinedPointerV1UnconfinedEvent {
  ZwpConfinedPointerV1UnconfinedEvent(
);

@override
String toString(){
  return """ZwpConfinedPointerV1UnconfinedEvent: {
  }""";
}

}

typedef ZwpConfinedPointerV1UnconfinedEventHandler = void Function(ZwpConfinedPointerV1UnconfinedEvent);


/// confined pointer object
/// 
/// The wp_confined_pointer interface represents a confined pointer state.
/// 
/// This object will send the event 'confined' when the confinement is
/// activated. Whenever the confinement is activated, it is guaranteed that
/// the surface the pointer is confined to will already have received pointer
/// focus and that the pointer will be within the region passed to the request
/// creating this object. It is up to the compositor to decide whether this
/// requires some user interaction and if the pointer will warp to within the
/// passed region if outside.
/// 
/// To unconfine the pointer, send the destroy request. This will also destroy
/// the wp_confined_pointer object.
/// 
/// If the compositor decides to unconfine the pointer the unconfined event is
/// sent. The wp_confined_pointer object is at this point defunct and should
/// be destroyed.
/// 
class ZwpConfinedPointerV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpConfinedPointerV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the confined pointer object
/// 
/// Destroy the confined pointer object. If applicable, the compositor will
/// unconfine the pointer.
/// 
  Future<void> destroy() async {
    print("ZwpConfinedPointerV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// set a new confine region
/// 
/// Set a new region used to confine the pointer.
/// 
/// The new confine region is double-buffered, see wl_surface.commit.
/// 
/// If the confinement is active when the new confinement region is applied
/// and the pointer ends up outside of newly applied region, the pointer may
/// warped to a position within the new confinement region. If warped, a
/// wl_pointer.motion event will be emitted, but no
/// wp_relative_pointer.relative_motion event.
/// 
/// The compositor may also, instead of using the new region, unconfine the
/// pointer.
/// 
/// For details about the confine region, see wp_confined_pointer.
/// 
/// [region]: region of surface
  Future<void> setRegion(Region region) async {
    print("ZwpConfinedPointerV1::setRegion  region: $region");
    final message = WaylandMessage(
      objectId,
      1,
      [
        region,
      ],
      [
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
  }

/// pointer confined
/// 
/// Notification that the pointer confinement of the seat's pointer is
/// activated.
/// 
/// Event handler for Confined
 void onConfined(ZwpConfinedPointerV1ConfinedEventHandler handler) {
   _confinedHandler = handler;
 }

 ZwpConfinedPointerV1ConfinedEventHandler? _confinedHandler;

/// pointer unconfined
/// 
/// Notification that the pointer confinement of the seat's pointer is no
/// longer active. If this is a oneshot pointer confinement (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer confinement (see
/// wp_pointer_constraints.lifetime) this pointer confinement may again
/// reactivate in the future.
/// 
/// Event handler for Unconfined
 void onUnconfined(ZwpConfinedPointerV1UnconfinedEventHandler handler) {
   _unconfinedHandler = handler;
 }

 ZwpConfinedPointerV1UnconfinedEventHandler? _unconfinedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_confinedHandler != null) {
var event = ZwpConfinedPointerV1ConfinedEvent(
        );
         _confinedHandler!(event);
       }
       break;
     case 1:
       if (_unconfinedHandler != null) {
var event = ZwpConfinedPointerV1UnconfinedEvent(
        );
         _unconfinedHandler!(event);
       }
       break;
   }
 }
}

