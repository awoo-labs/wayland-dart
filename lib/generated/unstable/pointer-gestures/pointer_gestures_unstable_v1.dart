// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/pointer-gestures/pointer-gestures-unstable-v1.xml
//
// pointer_gestures_unstable_v1 Protocol Copyright: 
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:async';
import 'dart:typed_data';


/// touchpad gestures
/// 
/// A global interface to provide semantic touchpad gestures for a given
/// pointer.
/// 
/// Three gestures are currently supported: swipe, pinch, and hold.
/// Pinch and swipe gestures follow a three-stage cycle: begin, update,
/// end, hold gestures follow a two-stage cycle: begin and end. All
/// gestures are identified by a unique id.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpPointerGesturesV1 extends Proxy{
  final Context context;

  ZwpPointerGesturesV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// get swipe gesture
/// 
/// Create a swipe gesture object. See the
/// wl_pointer_gesture_swipe interface for details.
/// 
/// [id]:
/// [pointer]:
  Future<ZwpPointerGestureSwipeV1> getSwipeGesture(Pointer pointer) async {
  var id =  ZwpPointerGestureSwipeV1(context);
    print("ZwpPointerGesturesV1::getSwipeGesture  id: $id pointer: $pointer");
    final message = WaylandMessage(
      objectId,
      0,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

/// get pinch gesture
/// 
/// Create a pinch gesture object. See the
/// wl_pointer_gesture_pinch interface for details.
/// 
/// [id]:
/// [pointer]:
  Future<ZwpPointerGesturePinchV1> getPinchGesture(Pointer pointer) async {
  var id =  ZwpPointerGesturePinchV1(context);
    print("ZwpPointerGesturesV1::getPinchGesture  id: $id pointer: $pointer");
    final message = WaylandMessage(
      objectId,
      1,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

/// destroy the pointer gesture object
/// 
/// Destroy the pointer gesture object. Swipe, pinch and hold objects
/// created via this gesture object remain valid.
/// 
  Future<void> release() async {
    print("ZwpPointerGesturesV1::release ");
    final message = WaylandMessage(
      objectId,
      2,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// get hold gesture
/// 
/// Create a hold gesture object. See the
/// wl_pointer_gesture_hold interface for details.
/// 
/// [id]:
/// [pointer]:
  Future<ZwpPointerGestureHoldV1> getHoldGesture(Pointer pointer) async {
  var id =  ZwpPointerGestureHoldV1(context);
    print("ZwpPointerGesturesV1::getHoldGesture  id: $id pointer: $pointer");
    final message = WaylandMessage(
      objectId,
      3,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

}


/// multi-finger swipe begin
/// 
/// This event is sent when a multi-finger swipe gesture is detected
/// on the device.
/// 
class ZwpPointerGestureSwipeV1BeginEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 
  final int surface;

/// number of fingers
  final int fingers;

  ZwpPointerGestureSwipeV1BeginEvent(
this.serial,

this.time,

this.surface,

this.fingers,

);

@override
String toString(){
  return """ZwpPointerGestureSwipeV1BeginEvent: {
    serial: $serial,
    time: $time,
    surface: $surface,
    fingers: $fingers,
  }""";
}

}

typedef ZwpPointerGestureSwipeV1BeginEventHandler = void Function(ZwpPointerGestureSwipeV1BeginEvent);

/// multi-finger swipe motion
/// 
/// This event is sent when a multi-finger swipe gesture changes the
/// position of the logical center.
/// 
/// The dx and dy coordinates are relative coordinates of the logical
/// center of the gesture compared to the previous event.
/// 
class ZwpPointerGestureSwipeV1UpdateEvent {
/// timestamp with millisecond granularity
  final int time;

/// delta x coordinate in surface coordinate space
  final double dx;

/// delta y coordinate in surface coordinate space
  final double dy;

  ZwpPointerGestureSwipeV1UpdateEvent(
this.time,

this.dx,

this.dy,

);

@override
String toString(){
  return """ZwpPointerGestureSwipeV1UpdateEvent: {
    time: $time,
    dx: $dx,
    dy: $dy,
  }""";
}

}

typedef ZwpPointerGestureSwipeV1UpdateEventHandler = void Function(ZwpPointerGestureSwipeV1UpdateEvent);

/// multi-finger swipe end
/// 
/// This event is sent when a multi-finger swipe gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
class ZwpPointerGestureSwipeV1EndEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 1 if the gesture was cancelled, 0 otherwise
  final int cancelled;

  ZwpPointerGestureSwipeV1EndEvent(
this.serial,

this.time,

this.cancelled,

);

@override
String toString(){
  return """ZwpPointerGestureSwipeV1EndEvent: {
    serial: $serial,
    time: $time,
    cancelled: $cancelled,
  }""";
}

}

typedef ZwpPointerGestureSwipeV1EndEventHandler = void Function(ZwpPointerGestureSwipeV1EndEvent);


/// a swipe gesture object
/// 
/// A swipe gesture object notifies a client about a multi-finger swipe
/// gesture detected on an indirect input device such as a touchpad.
/// The gesture is usually initiated by multiple fingers moving in the
/// same direction but once initiated the direction may change.
/// The precise conditions of when such a gesture is detected are
/// implementation-dependent.
/// 
/// A gesture consists of three stages: begin, update (optional) and end.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGestureSwipeV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGestureSwipeV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the pointer swipe gesture object
/// 
  Future<void> destroy() async {
    print("ZwpPointerGestureSwipeV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// multi-finger swipe begin
/// 
/// This event is sent when a multi-finger swipe gesture is detected
/// on the device.
/// 
/// Event handler for Begin
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [surface]:
/// - [fingers]: number of fingers
 void onBegin(ZwpPointerGestureSwipeV1BeginEventHandler handler) {
   _beginHandler = handler;
 }

 ZwpPointerGestureSwipeV1BeginEventHandler? _beginHandler;

/// multi-finger swipe motion
/// 
/// This event is sent when a multi-finger swipe gesture changes the
/// position of the logical center.
/// 
/// The dx and dy coordinates are relative coordinates of the logical
/// center of the gesture compared to the previous event.
/// 
/// Event handler for Update
/// - [time]: timestamp with millisecond granularity
/// - [dx]: delta x coordinate in surface coordinate space
/// - [dy]: delta y coordinate in surface coordinate space
 void onUpdate(ZwpPointerGestureSwipeV1UpdateEventHandler handler) {
   _updateHandler = handler;
 }

 ZwpPointerGestureSwipeV1UpdateEventHandler? _updateHandler;

/// multi-finger swipe end
/// 
/// This event is sent when a multi-finger swipe gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
/// Event handler for End
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [cancelled]: 1 if the gesture was cancelled, 0 otherwise
 void onEnd(ZwpPointerGestureSwipeV1EndEventHandler handler) {
   _endHandler = handler;
 }

 ZwpPointerGestureSwipeV1EndEventHandler? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
var event = ZwpPointerGestureSwipeV1BeginEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.little)).objectId,
           ByteData.view(data.buffer).getUint32(12, Endian.little),
        );
         _beginHandler!(event);
       }
       break;
     case 1:
       if (_updateHandler != null) {
var event = ZwpPointerGestureSwipeV1UpdateEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.little)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.little)),
        );
         _updateHandler!(event);
       }
       break;
     case 2:
       if (_endHandler != null) {
var event = ZwpPointerGestureSwipeV1EndEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           ByteData.view(data.buffer).getInt32(8, Endian.little),
        );
         _endHandler!(event);
       }
       break;
   }
 }
}


/// multi-finger pinch begin
/// 
/// This event is sent when a multi-finger pinch gesture is detected
/// on the device.
/// 
class ZwpPointerGesturePinchV1BeginEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 
  final int surface;

/// number of fingers
  final int fingers;

  ZwpPointerGesturePinchV1BeginEvent(
this.serial,

this.time,

this.surface,

this.fingers,

);

@override
String toString(){
  return """ZwpPointerGesturePinchV1BeginEvent: {
    serial: $serial,
    time: $time,
    surface: $surface,
    fingers: $fingers,
  }""";
}

}

typedef ZwpPointerGesturePinchV1BeginEventHandler = void Function(ZwpPointerGesturePinchV1BeginEvent);

/// multi-finger pinch motion
/// 
/// This event is sent when a multi-finger pinch gesture changes the
/// position of the logical center, the rotation or the relative scale.
/// 
/// The dx and dy coordinates are relative coordinates in the
/// surface coordinate space of the logical center of the gesture.
/// 
/// The scale factor is an absolute scale compared to the
/// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
/// are now twice as far apart as on pointer_gesture_pinch.begin.
/// 
/// The rotation is the relative angle in degrees clockwise compared to the previous
/// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
/// 
class ZwpPointerGesturePinchV1UpdateEvent {
/// timestamp with millisecond granularity
  final int time;

/// delta x coordinate in surface coordinate space
  final double dx;

/// delta y coordinate in surface coordinate space
  final double dy;

/// scale relative to the initial finger position
  final double scale;

/// angle in degrees cw relative to the previous event
  final double rotation;

  ZwpPointerGesturePinchV1UpdateEvent(
this.time,

this.dx,

this.dy,

this.scale,

this.rotation,

);

@override
String toString(){
  return """ZwpPointerGesturePinchV1UpdateEvent: {
    time: $time,
    dx: $dx,
    dy: $dy,
    scale: $scale,
    rotation: $rotation,
  }""";
}

}

typedef ZwpPointerGesturePinchV1UpdateEventHandler = void Function(ZwpPointerGesturePinchV1UpdateEvent);

/// multi-finger pinch end
/// 
/// This event is sent when a multi-finger pinch gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
class ZwpPointerGesturePinchV1EndEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 1 if the gesture was cancelled, 0 otherwise
  final int cancelled;

  ZwpPointerGesturePinchV1EndEvent(
this.serial,

this.time,

this.cancelled,

);

@override
String toString(){
  return """ZwpPointerGesturePinchV1EndEvent: {
    serial: $serial,
    time: $time,
    cancelled: $cancelled,
  }""";
}

}

typedef ZwpPointerGesturePinchV1EndEventHandler = void Function(ZwpPointerGesturePinchV1EndEvent);


/// a pinch gesture object
/// 
/// A pinch gesture object notifies a client about a multi-finger pinch
/// gesture detected on an indirect input device such as a touchpad.
/// The gesture is usually initiated by multiple fingers moving towards
/// each other or away from each other, or by two or more fingers rotating
/// around a logical center of gravity. The precise conditions of when
/// such a gesture is detected are implementation-dependent.
/// 
/// A gesture consists of three stages: begin, update (optional) and end.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGesturePinchV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGesturePinchV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the pinch gesture object
/// 
  Future<void> destroy() async {
    print("ZwpPointerGesturePinchV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// multi-finger pinch begin
/// 
/// This event is sent when a multi-finger pinch gesture is detected
/// on the device.
/// 
/// Event handler for Begin
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [surface]:
/// - [fingers]: number of fingers
 void onBegin(ZwpPointerGesturePinchV1BeginEventHandler handler) {
   _beginHandler = handler;
 }

 ZwpPointerGesturePinchV1BeginEventHandler? _beginHandler;

/// multi-finger pinch motion
/// 
/// This event is sent when a multi-finger pinch gesture changes the
/// position of the logical center, the rotation or the relative scale.
/// 
/// The dx and dy coordinates are relative coordinates in the
/// surface coordinate space of the logical center of the gesture.
/// 
/// The scale factor is an absolute scale compared to the
/// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
/// are now twice as far apart as on pointer_gesture_pinch.begin.
/// 
/// The rotation is the relative angle in degrees clockwise compared to the previous
/// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
/// 
/// Event handler for Update
/// - [time]: timestamp with millisecond granularity
/// - [dx]: delta x coordinate in surface coordinate space
/// - [dy]: delta y coordinate in surface coordinate space
/// - [scale]: scale relative to the initial finger position
/// - [rotation]: angle in degrees cw relative to the previous event
 void onUpdate(ZwpPointerGesturePinchV1UpdateEventHandler handler) {
   _updateHandler = handler;
 }

 ZwpPointerGesturePinchV1UpdateEventHandler? _updateHandler;

/// multi-finger pinch end
/// 
/// This event is sent when a multi-finger pinch gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
/// Event handler for End
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [cancelled]: 1 if the gesture was cancelled, 0 otherwise
 void onEnd(ZwpPointerGesturePinchV1EndEventHandler handler) {
   _endHandler = handler;
 }

 ZwpPointerGesturePinchV1EndEventHandler? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
var event = ZwpPointerGesturePinchV1BeginEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.little)).objectId,
           ByteData.view(data.buffer).getUint32(12, Endian.little),
        );
         _beginHandler!(event);
       }
       break;
     case 1:
       if (_updateHandler != null) {
var event = ZwpPointerGesturePinchV1UpdateEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.little)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.little)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(12, Endian.little)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(16, Endian.little)),
        );
         _updateHandler!(event);
       }
       break;
     case 2:
       if (_endHandler != null) {
var event = ZwpPointerGesturePinchV1EndEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           ByteData.view(data.buffer).getInt32(8, Endian.little),
        );
         _endHandler!(event);
       }
       break;
   }
 }
}


/// multi-finger hold begin
/// 
/// This event is sent when a hold gesture is detected on the device.
/// 
class ZwpPointerGestureHoldV1BeginEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 
  final int surface;

/// number of fingers
  final int fingers;

  ZwpPointerGestureHoldV1BeginEvent(
this.serial,

this.time,

this.surface,

this.fingers,

);

@override
String toString(){
  return """ZwpPointerGestureHoldV1BeginEvent: {
    serial: $serial,
    time: $time,
    surface: $surface,
    fingers: $fingers,
  }""";
}

}

typedef ZwpPointerGestureHoldV1BeginEventHandler = void Function(ZwpPointerGestureHoldV1BeginEvent);

/// multi-finger hold end
/// 
/// This event is sent when a hold gesture ceases to
/// be valid. This may happen when the holding fingers are lifted or
/// the gesture is cancelled, for example if the fingers move past an
/// implementation-defined threshold, the finger count changes or the hold
/// gesture changes into a different type of gesture.
/// 
/// When a gesture is cancelled, the client may need to undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
class ZwpPointerGestureHoldV1EndEvent {
/// 
  final int serial;

/// timestamp with millisecond granularity
  final int time;

/// 1 if the gesture was cancelled, 0 otherwise
  final int cancelled;

  ZwpPointerGestureHoldV1EndEvent(
this.serial,

this.time,

this.cancelled,

);

@override
String toString(){
  return """ZwpPointerGestureHoldV1EndEvent: {
    serial: $serial,
    time: $time,
    cancelled: $cancelled,
  }""";
}

}

typedef ZwpPointerGestureHoldV1EndEventHandler = void Function(ZwpPointerGestureHoldV1EndEvent);


/// a hold gesture object
/// 
/// A hold gesture object notifies a client about a single- or
/// multi-finger hold gesture detected on an indirect input device such as
/// a touchpad. The gesture is usually initiated by one or more fingers
/// being held down without significant movement. The precise conditions
/// of when such a gesture is detected are implementation-dependent.
/// 
/// In particular, this gesture may be used to cancel kinetic scrolling.
/// 
/// A hold gesture consists of two stages: begin and end. Unlike pinch and
/// swipe there is no update stage.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGestureHoldV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGestureHoldV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the hold gesture object
/// 
  Future<void> destroy() async {
    print("ZwpPointerGestureHoldV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// multi-finger hold begin
/// 
/// This event is sent when a hold gesture is detected on the device.
/// 
/// Event handler for Begin
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [surface]:
/// - [fingers]: number of fingers
 void onBegin(ZwpPointerGestureHoldV1BeginEventHandler handler) {
   _beginHandler = handler;
 }

 ZwpPointerGestureHoldV1BeginEventHandler? _beginHandler;

/// multi-finger hold end
/// 
/// This event is sent when a hold gesture ceases to
/// be valid. This may happen when the holding fingers are lifted or
/// the gesture is cancelled, for example if the fingers move past an
/// implementation-defined threshold, the finger count changes or the hold
/// gesture changes into a different type of gesture.
/// 
/// When a gesture is cancelled, the client may need to undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
/// Event handler for End
/// - [serial]:
/// - [time]: timestamp with millisecond granularity
/// - [cancelled]: 1 if the gesture was cancelled, 0 otherwise
 void onEnd(ZwpPointerGestureHoldV1EndEventHandler handler) {
   _endHandler = handler;
 }

 ZwpPointerGestureHoldV1EndEventHandler? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
var event = ZwpPointerGestureHoldV1BeginEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.little)).objectId,
           ByteData.view(data.buffer).getUint32(12, Endian.little),
        );
         _beginHandler!(event);
       }
       break;
     case 1:
       if (_endHandler != null) {
var event = ZwpPointerGestureHoldV1EndEvent(
           ByteData.view(data.buffer).getUint32(0, Endian.little),
           ByteData.view(data.buffer).getUint32(4, Endian.little),
           ByteData.view(data.buffer).getInt32(8, Endian.little),
        );
         _endHandler!(event);
       }
       break;
   }
 }
}

