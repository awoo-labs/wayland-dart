// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/pointer-gestures/pointer-gestures-unstable-v1.xml
//
// pointer_gestures_unstable_v1 Protocol Copyright: 
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// touchpad gestures
/// 
/// A global interface to provide semantic touchpad gestures for a given
/// pointer.
/// 
/// Three gestures are currently supported: swipe, pinch, and hold.
/// Pinch and swipe gestures follow a three-stage cycle: begin, update,
/// end, hold gestures follow a two-stage cycle: begin and end. All
/// gestures are identified by a unique id.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpPointerGesturesV1 extends Proxy{
  final Context context;

  ZwpPointerGesturesV1(this.context) : super(context.allocateClientId());

  Future<void> getSwipeGesture(Pointer pointer) async {
  var id =  ZwpPointerGesturesV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getPinchGesture(Pointer pointer) async {
  var id =  ZwpPointerGesturesV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getHoldGesture(Pointer pointer) async {
  var id =  ZwpPointerGesturesV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      3,
      [
        id,
        pointer,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

}

/// a swipe gesture object
/// 
/// A swipe gesture object notifies a client about a multi-finger swipe
/// gesture detected on an indirect input device such as a touchpad.
/// The gesture is usually initiated by multiple fingers moving in the
/// same direction but once initiated the direction may change.
/// The precise conditions of when such a gesture is detected are
/// implementation-dependent.
/// 
/// A gesture consists of three stages: begin, update (optional) and end.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGestureSwipeV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGestureSwipeV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// multi-finger swipe begin
/// 
/// This event is sent when a multi-finger swipe gesture is detected
/// on the device.
/// 
 void onbegin(void Function(int serial, int time, int surface, int fingers) handler) {
   _beginHandler = handler;
 }

 void Function(int serial, int time, int surface, int fingers)? _beginHandler;

 /// multi-finger swipe motion
/// 
/// This event is sent when a multi-finger swipe gesture changes the
/// position of the logical center.
/// 
/// The dx and dy coordinates are relative coordinates of the logical
/// center of the gesture compared to the previous event.
/// 
 void onupdate(void Function(int time, double dx, double dy) handler) {
   _updateHandler = handler;
 }

 void Function(int time, double dx, double dy)? _updateHandler;

 /// multi-finger swipe end
/// 
/// This event is sent when a multi-finger swipe gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
 void onend(void Function(int serial, int time, int cancelled) handler) {
   _endHandler = handler;
 }

 void Function(int serial, int time, int cancelled)? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
         _beginHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 1:
       if (_updateHandler != null) {
         _updateHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
         );
       }
       break;
     case 2:
       if (_endHandler != null) {
         _endHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

/// a pinch gesture object
/// 
/// A pinch gesture object notifies a client about a multi-finger pinch
/// gesture detected on an indirect input device such as a touchpad.
/// The gesture is usually initiated by multiple fingers moving towards
/// each other or away from each other, or by two or more fingers rotating
/// around a logical center of gravity. The precise conditions of when
/// such a gesture is detected are implementation-dependent.
/// 
/// A gesture consists of three stages: begin, update (optional) and end.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGesturePinchV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGesturePinchV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// multi-finger pinch begin
/// 
/// This event is sent when a multi-finger pinch gesture is detected
/// on the device.
/// 
 void onbegin(void Function(int serial, int time, int surface, int fingers) handler) {
   _beginHandler = handler;
 }

 void Function(int serial, int time, int surface, int fingers)? _beginHandler;

 /// multi-finger pinch motion
/// 
/// This event is sent when a multi-finger pinch gesture changes the
/// position of the logical center, the rotation or the relative scale.
/// 
/// The dx and dy coordinates are relative coordinates in the
/// surface coordinate space of the logical center of the gesture.
/// 
/// The scale factor is an absolute scale compared to the
/// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
/// are now twice as far apart as on pointer_gesture_pinch.begin.
/// 
/// The rotation is the relative angle in degrees clockwise compared to the previous
/// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
/// 
 void onupdate(void Function(int time, double dx, double dy, double scale, double rotation) handler) {
   _updateHandler = handler;
 }

 void Function(int time, double dx, double dy, double scale, double rotation)? _updateHandler;

 /// multi-finger pinch end
/// 
/// This event is sent when a multi-finger pinch gesture ceases to
/// be valid. This may happen when one or more fingers are lifted or
/// the gesture is cancelled.
/// 
/// When a gesture is cancelled, the client should undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
 void onend(void Function(int serial, int time, int cancelled) handler) {
   _endHandler = handler;
 }

 void Function(int serial, int time, int cancelled)? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
         _beginHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 1:
       if (_updateHandler != null) {
         _updateHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(8, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(12, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(16, Endian.host)),
         );
       }
       break;
     case 2:
       if (_endHandler != null) {
         _endHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

/// a hold gesture object
/// 
/// A hold gesture object notifies a client about a single- or
/// multi-finger hold gesture detected on an indirect input device such as
/// a touchpad. The gesture is usually initiated by one or more fingers
/// being held down without significant movement. The precise conditions
/// of when such a gesture is detected are implementation-dependent.
/// 
/// In particular, this gesture may be used to cancel kinetic scrolling.
/// 
/// A hold gesture consists of two stages: begin and end. Unlike pinch and
/// swipe there is no update stage.
/// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
/// same pointer/seat, how compositors prevent these situations is
/// implementation-dependent.
/// 
/// A gesture may be cancelled by the compositor or the hardware.
/// Clients should not consider performing permanent or irreversible
/// actions until the end of a gesture has been received.
/// 
class ZwpPointerGestureHoldV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpPointerGestureHoldV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// multi-finger hold begin
/// 
/// This event is sent when a hold gesture is detected on the device.
/// 
 void onbegin(void Function(int serial, int time, int surface, int fingers) handler) {
   _beginHandler = handler;
 }

 void Function(int serial, int time, int surface, int fingers)? _beginHandler;

 /// multi-finger hold end
/// 
/// This event is sent when a hold gesture ceases to
/// be valid. This may happen when the holding fingers are lifted or
/// the gesture is cancelled, for example if the fingers move past an
/// implementation-defined threshold, the finger count changes or the hold
/// gesture changes into a different type of gesture.
/// 
/// When a gesture is cancelled, the client may need to undo state changes
/// caused by this gesture. What causes a gesture to be cancelled is
/// implementation-dependent.
/// 
 void onend(void Function(int serial, int time, int cancelled) handler) {
   _endHandler = handler;
 }

 void Function(int serial, int time, int cancelled)? _endHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_beginHandler != null) {
         _beginHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
           ByteData.view(data.buffer).getInt32(12, Endian.host),
         );
       }
       break;
     case 1:
       if (_endHandler != null) {
         _endHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

