// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/keyboard-shortcuts-inhibit/keyboard-shortcuts-inhibit-unstable-v1.xml
//
// keyboard_shortcuts_inhibit_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2017 Red Hat Inc.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:async';
import 'dart:typed_data';


/// context object for keyboard grab_manager
/// 
/// A global interface used for inhibiting the compositor keyboard shortcuts.
/// 
class ZwpKeyboardShortcutsInhibitManagerV1 extends Proxy{
  final Context context;

  ZwpKeyboardShortcutsInhibitManagerV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the keyboard shortcuts inhibitor object
/// 
/// Destroy the keyboard shortcuts inhibitor manager.
/// 
  Future<void> destroy() async {
    print("ZwpKeyboardShortcutsInhibitManagerV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// create a new keyboard shortcuts inhibitor object
/// 
/// Create a new keyboard shortcuts inhibitor object associated with
/// the given surface for the given seat.
/// 
/// If shortcuts are already inhibited for the specified seat and surface,
/// a protocol error "already_inhibited" is raised by the compositor.
/// 
/// [id]:
/// [surface]: the surface that inhibits the keyboard shortcuts behavior
/// [seat]: the wl_seat for which keyboard shortcuts should be disabled
  Future<ZwpKeyboardShortcutsInhibitorV1> inhibitShortcuts(Surface surface, Seat seat) async {
  var id =  ZwpKeyboardShortcutsInhibitorV1(context);
    print("ZwpKeyboardShortcutsInhibitManagerV1::inhibitShortcuts  id: $id surface: $surface seat: $seat");
    final message = WaylandMessage(
      objectId,
      1,
      [
        id,
        surface,
        seat,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

}

/// 
/// 

enum ZwpKeyboardShortcutsInhibitManagerV1error {
/// the shortcuts are already inhibited for this surface
  alreadyInhibited,
}


/// shortcuts are inhibited
/// 
/// This event indicates that the shortcut inhibitor is active.
/// 
/// The compositor sends this event every time compositor shortcuts
/// are inhibited on behalf of the surface. When active, the client
/// may receive input events normally reserved by the compositor
/// (see zwp_keyboard_shortcuts_inhibitor_v1).
/// 
/// This occurs typically when the initial request "inhibit_shortcuts"
/// first becomes active or when the user instructs the compositor to
/// re-enable and existing shortcuts inhibitor using any mechanism
/// offered by the compositor.
/// 
class ZwpKeyboardShortcutsInhibitorV1ActiveEvent {
  ZwpKeyboardShortcutsInhibitorV1ActiveEvent(
);

@override
String toString(){
  return """ZwpKeyboardShortcutsInhibitorV1ActiveEvent: {
  }""";
}

}

typedef ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler = void Function(ZwpKeyboardShortcutsInhibitorV1ActiveEvent);

/// shortcuts are restored
/// 
/// This event indicates that the shortcuts inhibitor is inactive,
/// normal shortcuts processing is restored by the compositor.
/// 
class ZwpKeyboardShortcutsInhibitorV1InactiveEvent {
  ZwpKeyboardShortcutsInhibitorV1InactiveEvent(
);

@override
String toString(){
  return """ZwpKeyboardShortcutsInhibitorV1InactiveEvent: {
  }""";
}

}

typedef ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler = void Function(ZwpKeyboardShortcutsInhibitorV1InactiveEvent);


/// context object for keyboard shortcuts inhibitor
/// 
/// A keyboard shortcuts inhibitor instructs the compositor to ignore
/// its own keyboard shortcuts when the associated surface has keyboard
/// focus. As a result, when the surface has keyboard focus on the given
/// seat, it will receive all key events originating from the specified
/// seat, even those which would normally be caught by the compositor for
/// its own shortcuts.
/// 
/// The Wayland compositor is however under no obligation to disable
/// all of its shortcuts, and may keep some special key combo for its own
/// use, including but not limited to one allowing the user to forcibly
/// restore normal keyboard events routing in the case of an unwilling
/// client. The compositor may also use the same key combo to reactivate
/// an existing shortcut inhibitor that was previously deactivated on
/// user request.
/// 
/// When the compositor restores its own keyboard shortcuts, an
/// "inactive" event is emitted to notify the client that the keyboard
/// shortcuts inhibitor is not effectively active for the surface and
/// seat any more, and the client should not expect to receive all
/// keyboard events.
/// 
/// When the keyboard shortcuts inhibitor is inactive, the client has
/// no way to forcibly reactivate the keyboard shortcuts inhibitor.
/// 
/// The user can chose to re-enable a previously deactivated keyboard
/// shortcuts inhibitor using any mechanism the compositor may offer,
/// in which case the compositor will send an "active" event to notify
/// the client.
/// 
/// If the surface is destroyed, unmapped, or loses the seat's keyboard
/// focus, the keyboard shortcuts inhibitor becomes irrelevant and the
/// compositor will restore its own keyboard shortcuts but no "inactive"
/// event is emitted in this case.
/// 
class ZwpKeyboardShortcutsInhibitorV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpKeyboardShortcutsInhibitorV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the keyboard shortcuts inhibitor object
/// 
/// Remove the keyboard shortcuts inhibitor from the associated wl_surface.
/// 
  Future<void> destroy() async {
    print("ZwpKeyboardShortcutsInhibitorV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// shortcuts are inhibited
/// 
/// This event indicates that the shortcut inhibitor is active.
/// 
/// The compositor sends this event every time compositor shortcuts
/// are inhibited on behalf of the surface. When active, the client
/// may receive input events normally reserved by the compositor
/// (see zwp_keyboard_shortcuts_inhibitor_v1).
/// 
/// This occurs typically when the initial request "inhibit_shortcuts"
/// first becomes active or when the user instructs the compositor to
/// re-enable and existing shortcuts inhibitor using any mechanism
/// offered by the compositor.
/// 
/// Event handler for Active
 void onActive(ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler handler) {
   _activeHandler = handler;
 }

 ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler? _activeHandler;

/// shortcuts are restored
/// 
/// This event indicates that the shortcuts inhibitor is inactive,
/// normal shortcuts processing is restored by the compositor.
/// 
/// Event handler for Inactive
 void onInactive(ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler handler) {
   _inactiveHandler = handler;
 }

 ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler? _inactiveHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_activeHandler != null) {
var event = ZwpKeyboardShortcutsInhibitorV1ActiveEvent(
        );
         _activeHandler!(event);
       }
       break;
     case 1:
       if (_inactiveHandler != null) {
var event = ZwpKeyboardShortcutsInhibitorV1InactiveEvent(
        );
         _inactiveHandler!(event);
       }
       break;
   }
 }
}

