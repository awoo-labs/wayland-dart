// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/tablet/tablet-unstable-v1.xml
//
// tablet_unstable_v1 Protocol Copyright: 
/// 
/// Copyright 2014 © Stephen "Lyude" Chandler Paul
/// Copyright 2015-2016 © Red Hat, Inc.
/// 
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files
/// (the "Software"), to deal in the Software without restriction,
/// including without limitation the rights to use, copy, modify, merge,
/// publish, distribute, sublicense, and/or sell copies of the Software,
/// and to permit persons to whom the Software is furnished to do so,
/// subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the
/// next paragraph) shall be included in all copies or substantial
/// portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
/// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
/// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// controller object for graphic tablet devices
/// 
/// An object that provides access to the graphics tablets available on this
/// system. All tablets are associated with a seat, to get access to the
/// actual tablets, use wp_tablet_manager.get_tablet_seat.
/// 
class ZwpTabletManagerV1 extends Proxy{
  final Context context;

  ZwpTabletManagerV1(this.context) : super(context.allocateClientId());

  Future<void> getTabletSeat(Seat seat) async {
  var tabletSeat =  ZwpTabletManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        tabletSeat,
        seat,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

}

/// controller object for graphic tablet devices of a seat
/// 
/// An object that provides access to the graphics tablets available on this
/// seat. After binding to this interface, the compositor sends a set of
/// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
/// 
class ZwpTabletSeatV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletSeatV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// new device notification
/// 
/// This event is sent whenever a new tablet becomes available on this
/// seat. This event only provides the object id of the tablet, any
/// static information about the tablet (device name, vid/pid, etc.) is
/// sent through the wp_tablet interface.
/// 
 void ontabletAdded(void Function(int id) handler) {
   _tabletAddedHandler = handler;
 }

 void Function(int id)? _tabletAddedHandler;

 /// a new tool has been used with a tablet
/// 
/// This event is sent whenever a tool that has not previously been used
/// with a tablet comes into use. This event only provides the object id
/// of the tool; any static information about the tool (capabilities,
/// type, etc.) is sent through the wp_tablet_tool interface.
/// 
 void ontoolAdded(void Function(int id) handler) {
   _toolAddedHandler = handler;
 }

 void Function(int id)? _toolAddedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_tabletAddedHandler != null) {
         _tabletAddedHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_toolAddedHandler != null) {
         _toolAddedHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
   }
 }
}

/// a physical tablet tool
/// 
/// An object that represents a physical tool that has been, or is
/// currently in use with a tablet in this seat. Each wp_tablet_tool
/// object stays valid until the client destroys it; the compositor
/// reuses the wp_tablet_tool object to indicate that the object's
/// respective physical tool has come into proximity of a tablet again.
/// 
/// A wp_tablet_tool object's relation to a physical tool depends on the
/// tablet's ability to report serial numbers. If the tablet supports
/// this capability, then the object represents a specific physical tool
/// and can be identified even when used on multiple tablets.
/// 
/// A tablet tool has a number of static characteristics, e.g. tool type,
/// hardware_serial and capabilities. These capabilities are sent in an
/// event sequence after the wp_tablet_seat.tool_added event before any
/// actual events from this tool. This initial event sequence is
/// terminated by a wp_tablet_tool.done event.
/// 
/// Tablet tool events are grouped by wp_tablet_tool.frame events.
/// Any events received before a wp_tablet_tool.frame event should be
/// considered part of the same hardware state change.
/// 
class ZwpTabletToolV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletToolV1(this.context) : super(context.allocateClientId());

  Future<void> setCursor(int serial, Surface surface, int hotspotX, int hotspotY) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        serial,
        surface,
        hotspotX,
        hotspotY,
      ],
      [
        WaylandType.uint,
        WaylandType.object,
        WaylandType.int,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// tool type
/// 
/// The tool type is the high-level type of the tool and usually decides
/// the interaction expected from this tool.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void ontype(void Function(int toolType) handler) {
   _typeHandler = handler;
 }

 void Function(int toolType)? _typeHandler;

 /// unique hardware serial number of the tool
/// 
/// If the physical tool can be identified by a unique 64-bit serial
/// number, this event notifies the client of this serial number.
/// 
/// If multiple tablets are available in the same seat and the tool is
/// uniquely identifiable by the serial number, that tool may move
/// between tablets.
/// 
/// Otherwise, if the tool has no serial number and this event is
/// missing, the tool is tied to the tablet it first comes into
/// proximity with. Even if the physical tool is used on multiple
/// tablets, separate wp_tablet_tool objects will be created, one per
/// tablet.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void onhardwareSerial(void Function(int hardwareSerialHi, int hardwareSerialLo) handler) {
   _hardwareSerialHandler = handler;
 }

 void Function(int hardwareSerialHi, int hardwareSerialLo)? _hardwareSerialHandler;

 /// hardware id notification in Wacom's format
/// 
/// This event notifies the client of a hardware id available on this tool.
/// 
/// The hardware id is a device-specific 64-bit id that provides extra
/// information about the tool in use, beyond the wl_tool.type
/// enumeration. The format of the id is specific to tablets made by
/// Wacom Inc. For example, the hardware id of a Wacom Grip
/// Pen (a stylus) is 0x802.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void onhardwareIdWacom(void Function(int hardwareIdHi, int hardwareIdLo) handler) {
   _hardwareIdWacomHandler = handler;
 }

 void Function(int hardwareIdHi, int hardwareIdLo)? _hardwareIdWacomHandler;

 /// tool capability notification
/// 
/// This event notifies the client of any capabilities of this tool,
/// beyond the main set of x/y axes and tip up/down detection.
/// 
/// One event is sent for each extra capability available on this tool.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
/// 
 void oncapability(void Function(int capability) handler) {
   _capabilityHandler = handler;
 }

 void Function(int capability)? _capabilityHandler;

 /// tool description events sequence complete
/// 
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the tool to
/// be complete and finalize initialization of the tool.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// tool removed
/// 
/// This event is sent when the tool is removed from the system and will
/// send no further events. Should the physical tool come back into
/// proximity later, a new wp_tablet_tool object will be created.
/// 
/// It is compositor-dependent when a tool is removed. A compositor may
/// remove a tool on proximity out, tablet removal or any other reason.
/// A compositor may also keep a tool alive until shutdown.
/// 
/// If the tool is currently in proximity, a proximity_out event will be
/// sent before the removed event. See wp_tablet_tool.proximity_out for
/// the handling of any buttons logically down.
/// 
/// When this event is received, the client must wp_tablet_tool.destroy
/// the object.
/// 
 void onremoved(void Function() handler) {
   _removedHandler = handler;
 }

 void Function()? _removedHandler;

 /// proximity in event
/// 
/// Notification that this tool is focused on a certain surface.
/// 
/// This event can be received when the tool has moved from one surface to
/// another, or when the tool has come back into proximity above the
/// surface.
/// 
/// If any button is logically down when the tool comes into proximity,
/// the respective button event is sent after the proximity_in event but
/// within the same frame as the proximity_in event.
/// 
 void onproximityIn(void Function(int serial, int tablet, int surface) handler) {
   _proximityInHandler = handler;
 }

 void Function(int serial, int tablet, int surface)? _proximityInHandler;

 /// proximity out event
/// 
/// Notification that this tool has either left proximity, or is no
/// longer focused on a certain surface.
/// 
/// When the tablet tool leaves proximity of the tablet, button release
/// events are sent for each button that was held down at the time of
/// leaving proximity. These events are sent before the proximity_out
/// event but within the same wp_tablet.frame.
/// 
/// If the tool stays within proximity of the tablet, but the focus
/// changes from one surface to another, a button release event may not
/// be sent until the button is actually released or the tool leaves the
/// proximity of the tablet.
/// 
 void onproximityOut(void Function() handler) {
   _proximityOutHandler = handler;
 }

 void Function()? _proximityOutHandler;

 /// tablet tool is making contact
/// 
/// Sent whenever the tablet tool comes in contact with the surface of the
/// tablet.
/// 
/// If the tool is already in contact with the tablet when entering the
/// input region, the client owning said region will receive a
/// wp_tablet.proximity_in event, followed by a wp_tablet.down
/// event and a wp_tablet.frame event.
/// 
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool in
/// logical contact until a minimum physical pressure threshold is
/// exceeded.
/// 
 void ondown(void Function(int serial) handler) {
   _downHandler = handler;
 }

 void Function(int serial)? _downHandler;

 /// tablet tool is no longer making contact
/// 
/// Sent whenever the tablet tool stops making contact with the surface of
/// the tablet, or when the tablet tool moves out of the input region
/// and the compositor grab (if any) is dismissed.
/// 
/// If the tablet tool moves out of the input region while in contact
/// with the surface of the tablet and the compositor does not have an
/// ongoing grab on the surface, the client owning said region will
/// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
/// event and a wp_tablet.frame event. If the compositor has an ongoing
/// grab on this device, this event sequence is sent whenever the grab
/// is dismissed in the future.
/// 
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool out
/// of logical contact until physical pressure falls below a specific
/// threshold.
/// 
 void onup(void Function() handler) {
   _upHandler = handler;
 }

 void Function()? _upHandler;

 /// motion event
/// 
/// Sent whenever a tablet tool moves.
/// 
 void onmotion(void Function(double x, double y) handler) {
   _motionHandler = handler;
 }

 void Function(double x, double y)? _motionHandler;

 /// pressure change event
/// 
/// Sent whenever the pressure axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
/// 
/// Note that pressure may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
/// 
 void onpressure(void Function(int pressure) handler) {
   _pressureHandler = handler;
 }

 void Function(int pressure)? _pressureHandler;

 /// distance change event
/// 
/// Sent whenever the distance axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
/// 
/// Note that distance may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
/// 
 void ondistance(void Function(int distance) handler) {
   _distanceHandler = handler;
 }

 void Function(int distance)? _distanceHandler;

 /// tilt change event
/// 
/// Sent whenever one or both of the tilt axes on a tool change. Each tilt
/// value is in 0.01 of a degree, relative to the z-axis of the tablet.
/// The angle is positive when the top of a tool tilts along the
/// positive x or y axis.
/// 
 void ontilt(void Function(int tiltX, int tiltY) handler) {
   _tiltHandler = handler;
 }

 void Function(int tiltX, int tiltY)? _tiltHandler;

 /// z-rotation change event
/// 
/// Sent whenever the z-rotation axis on the tool changes. The
/// rotation value is in 0.01 of a degree clockwise from the tool's
/// logical neutral position.
/// 
 void onrotation(void Function(int degrees) handler) {
   _rotationHandler = handler;
 }

 void Function(int degrees)? _rotationHandler;

 /// Slider position change event
/// 
/// Sent whenever the slider position on the tool changes. The
/// value is normalized between -65535 and 65535, with 0 as the logical
/// neutral position of the slider.
/// 
/// The slider is available on e.g. the Wacom Airbrush tool.
/// 
 void onslider(void Function(int position) handler) {
   _sliderHandler = handler;
 }

 void Function(int position)? _sliderHandler;

 /// Wheel delta event
/// 
/// Sent whenever the wheel on the tool emits an event. This event
/// contains two values for the same axis change. The degrees value is
/// in 0.01 of a degree in the same orientation as the
/// wl_pointer.vertical_scroll axis. The clicks value is in discrete
/// logical clicks of the mouse wheel. This value may be zero if the
/// movement of the wheel was less than one logical click.
/// 
/// Clients should choose either value and avoid mixing degrees and
/// clicks. The compositor may accumulate values smaller than a logical
/// click and emulate click events when a certain threshold is met.
/// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
/// have different degrees values.
/// 
 void onwheel(void Function(int degrees, int clicks) handler) {
   _wheelHandler = handler;
 }

 void Function(int degrees, int clicks)? _wheelHandler;

 /// button event
/// 
/// Sent whenever a button on the tool is pressed or released.
/// 
/// If a button is held down when the tool moves in or out of proximity,
/// button events are generated by the compositor. See
/// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
/// details.
/// 
 void onbutton(void Function(int serial, int button, int state) handler) {
   _buttonHandler = handler;
 }

 void Function(int serial, int button, int state)? _buttonHandler;

 /// frame event
/// 
/// Marks the end of a series of axis and/or button updates from the
/// tablet. The Wayland protocol requires axis updates to be sent
/// sequentially, however all events within a frame should be considered
/// one hardware event.
/// 
 void onframe(void Function(int time) handler) {
   _frameHandler = handler;
 }

 void Function(int time)? _frameHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_typeHandler != null) {
         _typeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_hardwareSerialHandler != null) {
         _hardwareSerialHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 2:
       if (_hardwareIdWacomHandler != null) {
         _hardwareIdWacomHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 3:
       if (_capabilityHandler != null) {
         _capabilityHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 4:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 5:
       if (_removedHandler != null) {
         _removedHandler!(
         );
       }
       break;
     case 6:
       if (_proximityInHandler != null) {
         _proximityInHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           context.getProxy(ByteData.view(data.buffer).getUint32(4, Endian.host)).id,
           context.getProxy(ByteData.view(data.buffer).getUint32(8, Endian.host)).id,
         );
       }
       break;
     case 7:
       if (_proximityOutHandler != null) {
         _proximityOutHandler!(
         );
       }
       break;
     case 8:
       if (_downHandler != null) {
         _downHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 9:
       if (_upHandler != null) {
         _upHandler!(
         );
       }
       break;
     case 10:
       if (_motionHandler != null) {
         _motionHandler!(
           fixedToDouble(ByteData.view(data.buffer).getInt32(0, Endian.host)),
           fixedToDouble(ByteData.view(data.buffer).getInt32(4, Endian.host)),
         );
       }
       break;
     case 11:
       if (_pressureHandler != null) {
         _pressureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 12:
       if (_distanceHandler != null) {
         _distanceHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 13:
       if (_tiltHandler != null) {
         _tiltHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 14:
       if (_rotationHandler != null) {
         _rotationHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 15:
       if (_sliderHandler != null) {
         _sliderHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 16:
       if (_wheelHandler != null) {
         _wheelHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 17:
       if (_buttonHandler != null) {
         _buttonHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
     case 18:
       if (_frameHandler != null) {
         _frameHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
   }
 }
}

/// a physical tool type
/// 
/// Describes the physical type of a tool. The physical type of a tool
/// generally defines its base usage.
/// 
/// The mouse tool represents a mouse-shaped tool that is not a relative
/// device but bound to the tablet's surface, providing absolute
/// coordinates.
/// 
/// The lens tool is a mouse-shaped tool with an attached lens to
/// provide precision focus.
/// 

enum ZwpTabletToolV1type {
  /// Pen
  pen,
  /// Eraser
  eraser,
  /// Brush
  brush,
  /// Pencil
  pencil,
  /// Airbrush
  airbrush,
  /// Finger
  finger,
  /// Mouse
  mouse,
  /// Lens
  lens,
}

/// capability flags for a tool
/// 
/// Describes extra capabilities on a tablet.
/// 
/// Any tool must provide x and y values, extra axes are
/// device-specific.
/// 

enum ZwpTabletToolV1capability {
  /// Tilt axes
  tilt,
  /// Pressure axis
  pressure,
  /// Distance axis
  distance,
  /// Z-rotation axis
  rotation,
  /// Slider axis
  slider,
  /// Wheel axis
  wheel,
}

/// physical button state
/// 
/// Describes the physical state of a button that produced the button event.
/// 

enum ZwpTabletToolV1buttonState {
  /// button is not pressed
  released,
  /// button is pressed
  pressed,
}

/// 
/// 

enum ZwpTabletToolV1error {
  /// given wl_surface has another role
  role,
}

/// graphics tablet device
/// 
/// The wp_tablet interface represents one graphics tablet device. The
/// tablet interface itself does not generate events; all events are
/// generated by wp_tablet_tool objects when in proximity above a tablet.
/// 
/// A tablet has a number of static characteristics, e.g. device name and
/// pid/vid. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.tablet_added event. This initial event sequence is
/// terminated by a wp_tablet.done event.
/// 
class ZwpTabletV1 extends Proxy implements Dispatcher{
  final Context context;

  ZwpTabletV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// tablet device name
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onname(void Function(String name) handler) {
   _nameHandler = handler;
 }

 void Function(String name)? _nameHandler;

 /// tablet device USB vendor/product id
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onid(void Function(int vid, int pid) handler) {
   _idHandler = handler;
 }

 void Function(int vid, int pid)? _idHandler;

 /// path to the device
/// 
/// A system-specific device path that indicates which device is behind
/// this wp_tablet. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
/// 
/// A device may have more than one device path. If so, multiple
/// wp_tablet.path events are sent. A device may be emulated and not
/// have a device path, and in that case this event will not be sent.
/// 
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
/// 
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
/// 
 void onpath(void Function(String path) handler) {
   _pathHandler = handler;
 }

 void Function(String path)? _pathHandler;

 /// tablet description events sequence complete
/// 
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// tablet removed event
/// 
/// Sent when the tablet has been removed from the system. When a tablet
/// is removed, some tools may be removed.
/// 
/// When this event is received, the client must wp_tablet.destroy
/// the object.
/// 
 void onremoved(void Function() handler) {
   _removedHandler = handler;
 }

 void Function()? _removedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_nameHandler != null) {
         _nameHandler!(
           getString(data, 0),
         );
       }
       break;
     case 1:
       if (_idHandler != null) {
         _idHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
         );
       }
       break;
     case 2:
       if (_pathHandler != null) {
         _pathHandler!(
           getString(data, 0),
         );
       }
       break;
     case 3:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 4:
       if (_removedHandler != null) {
         _removedHandler!(
         );
       }
       break;
   }
 }
}

