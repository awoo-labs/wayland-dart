// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/ext-session-lock/ext-session-lock-v1.xml
//
// ext_session_lock_v1 Protocol Copyright: 
/// 
/// Copyright 2021 Isaac Freund
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice shall be included in
/// all copies or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
/// THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// used to lock the session
/// 
/// This interface is used to request that the session be locked.
/// 
class ExtSessionLockManagerV1 extends Proxy{
  final Context context;

  ExtSessionLockManagerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> lock() async {
  var id =  ExtSessionLockManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

}

/// manage lock state and create lock surfaces
/// 
/// In response to the creation of this object the compositor must send
/// either the locked or finished event.
/// 
/// The locked event indicates that the session is locked. This means
/// that the compositor must stop rendering and providing input to normal
/// clients. Instead the compositor must blank all outputs with an opaque
/// color such that their normal content is fully hidden.
/// 
/// The only surfaces that should be rendered while the session is locked
/// are the lock surfaces created through this interface and optionally,
/// at the compositor's discretion, special privileged surfaces such as
/// input methods or portions of desktop shell UIs.
/// 
/// The locked event must not be sent until a new "locked" frame (either
/// from a session lock surface or the compositor blanking the output) has
/// been presented on all outputs and no security sensitive normal/unlocked
/// content is possibly visible.
/// 
/// The finished event should be sent immediately on creation of this
/// object if the compositor decides that the locked event will not be sent.
/// 
/// The compositor may wait for the client to create and render session lock
/// surfaces before sending the locked event to avoid displaying intermediate
/// blank frames. However, it must impose a reasonable time limit if
/// waiting and send the locked event as soon as the hard requirements
/// described above can be met if the time limit expires. Clients should
/// immediately create lock surfaces for all outputs on creation of this
/// object to make this possible.
/// 
/// This behavior of the locked event is required in order to prevent
/// possible race conditions with clients that wish to suspend the system
/// or similar after locking the session. Without these semantics, clients
/// triggering a suspend after receiving the locked event would race with
/// the first "locked" frame being presented and normal/unlocked frames
/// might be briefly visible as the system is resumed if the suspend
/// operation wins the race.
/// 
/// If the client dies while the session is locked, the compositor must not
/// unlock the session in response. It is acceptable for the session to be
/// permanently locked if this happens. The compositor may choose to continue
/// to display the lock surfaces the client had mapped before it died or
/// alternatively fall back to a solid color, this is compositor policy.
/// 
/// Compositors may also allow a secure way to recover the session, the
/// details of this are compositor policy. Compositors may allow a new
/// client to create a ext_session_lock_v1 object and take responsibility
/// for unlocking the session, they may even start a new lock client
/// instance automatically.
/// 
class ExtSessionLockV1 extends Proxy implements Dispatcher{
  final Context context;

  ExtSessionLockV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getLockSurface(Surface surface, Output output) async {
  var id =  ExtSessionLockV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        surface,
        output,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> unlockAndDestroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// session successfully locked
/// 
/// This client is now responsible for displaying graphics while the
/// session is locked and deciding when to unlock the session.
/// 
/// The locked event must not be sent until a new "locked" frame has been
/// presented on all outputs and no security sensitive normal/unlocked
/// content is possibly visible.
/// 
/// If this event is sent, making the destroy request is a protocol error,
/// the lock object must be destroyed using the unlock_and_destroy request.
/// 
 void onlocked(void Function() handler) {
   _lockedHandler = handler;
 }

 void Function()? _lockedHandler;

 /// the session lock object should be destroyed
/// 
/// The compositor has decided that the session lock should be destroyed
/// as it will no longer be used by the compositor. Exactly when this
/// event is sent is compositor policy, but it must never be sent more
/// than once for a given session lock object.
/// 
/// This might be sent because there is already another ext_session_lock_v1
/// object held by a client, or the compositor has decided to deny the
/// request to lock the session for some other reason. This might also
/// be sent because the compositor implements some alternative, secure
/// way to authenticate and unlock the session.
/// 
/// The finished event should be sent immediately on creation of this
/// object if the compositor decides that the locked event will not
/// be sent.
/// 
/// If the locked event is sent on creation of this object the finished
/// event may still be sent at some later time in this object's
/// lifetime. This is compositor policy.
/// 
/// Upon receiving this event, the client should make either the destroy
/// request or the unlock_and_destroy request, depending on whether or
/// not the locked event was received on this object.
/// 
 void onfinished(void Function() handler) {
   _finishedHandler = handler;
 }

 void Function()? _finishedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_lockedHandler != null) {
         _lockedHandler!(
         );
       }
       break;
     case 1:
       if (_finishedHandler != null) {
         _finishedHandler!(
         );
       }
       break;
   }
 }
}

/// 
/// 

enum ExtSessionLockV1error {
  /// attempted to destroy session lock while locked
  invalidDestroy,
  /// unlock requested but locked event was never sent
  invalidUnlock,
  /// given wl_surface already has a role
  role,
  /// given output already has a lock surface
  duplicateOutput,
  /// given wl_surface has a buffer attached or committed
  alreadyConstructed,
}

/// a surface displayed while the session is locked
/// 
/// The client may use lock surfaces to display a screensaver, render a
/// dialog to enter a password and unlock the session, or however else it
/// sees fit.
/// 
/// On binding this interface the compositor will immediately send the
/// first configure event. After making the ack_configure request in
/// response to this event the client should attach and commit the first
/// buffer. Committing the surface before acking the first configure is a
/// protocol error. Committing the surface with a null buffer at any time
/// is a protocol error.
/// 
/// The compositor is free to handle keyboard/pointer focus for lock
/// surfaces however it chooses. A reasonable way to do this would be to
/// give the first lock surface created keyboard focus and change keyboard
/// focus if the user clicks on other surfaces.
/// 
class ExtSessionLockSurfaceV1 extends Proxy implements Dispatcher{
  final Context context;

  ExtSessionLockSurfaceV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> ackConfigure(int serial) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        serial,
      ],
      [
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

 /// the client should resize its surface
/// 
/// This event is sent once on binding the interface and may be sent again
/// at the compositor's discretion, for example if output geometry changes.
/// 
/// The width and height are in surface-local coordinates and are exact
/// requirements. Failing to match these surface dimensions in the next
/// commit after acking a configure is a protocol error.
/// 
 void onconfigure(void Function(int serial, int width, int height) handler) {
   _configureHandler = handler;
 }

 void Function(int serial, int width, int height)? _configureHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_configureHandler != null) {
         _configureHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
           ByteData.view(data.buffer).getInt32(4, Endian.host),
           ByteData.view(data.buffer).getInt32(8, Endian.host),
         );
       }
       break;
   }
 }
}

/// 
/// 

enum ExtSessionLockSurfaceV1error {
  /// surface committed before first ack_configure request
  commitBeforeFirstAck,
  /// surface committed with a null buffer
  nullBuffer,
  /// failed to match ack'd width/height
  dimensionsMismatch,
  /// serial provided in ack_configure is invalid
  invalidSerial,
}

