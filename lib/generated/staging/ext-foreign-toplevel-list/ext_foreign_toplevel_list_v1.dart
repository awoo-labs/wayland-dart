// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/ext-foreign-toplevel-list/ext-foreign-toplevel-list-v1.xml
//
// ext_foreign_toplevel_list_v1 Protocol Copyright: 
/// 
/// Copyright © 2018 Ilia Bozhinov
/// Copyright © 2020 Isaac Freund
/// Copyright © 2022 wb9688
/// Copyright © 2023 i509VCB
/// 
/// Permission to use, copy, modify, distribute, and sell this
/// software and its documentation for any purpose is hereby granted
/// without fee, provided that the above copyright notice appear in
/// all copies and that both that copyright notice and this permission
/// notice appear in supporting documentation, and that the name of
/// the copyright holders not be used in advertising or publicity
/// pertaining to distribution of the software without specific,
/// written prior permission.  The copyright holders make no
/// representations about the suitability of this software for any
/// purpose.  It is provided "as is" without express or implied
/// warranty.
/// 
/// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
/// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
/// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
/// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
/// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
/// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
/// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
/// THIS SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// list toplevels
/// 
/// A toplevel is defined as a surface with a role similar to xdg_toplevel.
/// XWayland surfaces may be treated like toplevels in this protocol.
/// 
/// After a client binds the ext_foreign_toplevel_list_v1, each mapped
/// toplevel window will be sent using the ext_foreign_toplevel_list_v1.toplevel
/// event.
/// 
/// Clients which only care about the current state can perform a roundtrip after
/// binding this global.
/// 
/// For each instance of ext_foreign_toplevel_list_v1, the compositor must
/// create a new ext_foreign_toplevel_handle_v1 object for each mapped toplevel.
/// 
/// If a compositor implementation sends the ext_foreign_toplevel_list_v1.finished
/// event after the global is bound, the compositor must not send any
/// ext_foreign_toplevel_list_v1.toplevel events.
/// 
class ExtForeignToplevelListV1 extends Proxy implements Dispatcher{
  final Context context;

  ExtForeignToplevelListV1(this.context) : super(context.allocateClientId());

  Future<void> stop() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// a toplevel has been created
/// 
/// This event is emitted whenever a new toplevel window is created. It is
/// emitted for all toplevels, regardless of the app that has created them.
/// 
/// All initial properties of the toplevel (identifier, title, app_id) will be sent
/// immediately after this event using the corresponding events for
/// ext_foreign_toplevel_handle_v1. The compositor will use the
/// ext_foreign_toplevel_handle_v1.done event to indicate when all data has
/// been sent.
/// 
 void ontoplevel(void Function(int toplevel) handler) {
   _toplevelHandler = handler;
 }

 void Function(int toplevel)? _toplevelHandler;

 /// the compositor has finished with the toplevel manager
/// 
/// This event indicates that the compositor is done sending events
/// to this object. The client should destroy the object.
/// See ext_foreign_toplevel_list_v1.destroy for more information.
/// 
/// The compositor must not send any more toplevel events after this event.
/// 
 void onfinished(void Function() handler) {
   _finishedHandler = handler;
 }

 void Function()? _finishedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_toplevelHandler != null) {
         _toplevelHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 1:
       if (_finishedHandler != null) {
         _finishedHandler!(
         );
       }
       break;
   }
 }
}

/// a mapped toplevel
/// 
/// A ext_foreign_toplevel_handle_v1 object represents a mapped toplevel
/// window. A single app may have multiple mapped toplevels.
/// 
class ExtForeignToplevelHandleV1 extends Proxy implements Dispatcher{
  final Context context;

  ExtForeignToplevelHandleV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// the toplevel has been closed
/// 
/// The server will emit no further events on the ext_foreign_toplevel_handle_v1
/// after this event. Any requests received aside from the destroy request must
/// be ignored. Upon receiving this event, the client should destroy the handle.
/// 
/// Other protocols which extend the ext_foreign_toplevel_handle_v1
/// interface must also ignore requests other than destructors.
/// 
 void onclosed(void Function() handler) {
   _closedHandler = handler;
 }

 void Function()? _closedHandler;

 /// all information about the toplevel has been sent
/// 
/// This event is sent after all changes in the toplevel state have
/// been sent.
/// 
/// This allows changes to the ext_foreign_toplevel_handle_v1 properties
/// to be atomically applied. Other protocols which extend the
/// ext_foreign_toplevel_handle_v1 interface may use this event to also
/// atomically apply any pending state.
/// 
/// This event must not be sent after the ext_foreign_toplevel_handle_v1.closed
/// event.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// title change
/// 
/// The title of the toplevel has changed.
/// 
/// The configured state must not be applied immediately. See
/// ext_foreign_toplevel_handle_v1.done for details.
/// 
 void ontitle(void Function(String title) handler) {
   _titleHandler = handler;
 }

 void Function(String title)? _titleHandler;

 /// app_id change
/// 
/// The app id of the toplevel has changed.
/// 
/// The configured state must not be applied immediately. See
/// ext_foreign_toplevel_handle_v1.done for details.
/// 
 void onappId(void Function(String appId) handler) {
   _appIdHandler = handler;
 }

 void Function(String appId)? _appIdHandler;

 /// a stable identifier for a toplevel
/// 
/// This identifier is used to check if two or more toplevel handles belong
/// to the same toplevel.
/// 
/// The identifier is useful for command line tools or privileged clients
/// which may need to reference an exact toplevel across processes or
/// instances of the ext_foreign_toplevel_list_v1 global.
/// 
/// The compositor must only send this event when the handle is created.
/// 
/// The identifier must be unique per toplevel and it's handles. Two different
/// toplevels must not have the same identifier. The identifier is only valid
/// as long as the toplevel is mapped. If the toplevel is unmapped the identifier
/// must not be reused. An identifier must not be reused by the compositor to
/// ensure there are no races when sharing identifiers between processes.
/// 
/// An identifier is a string that contains up to 32 printable ASCII bytes.
/// An identifier must not be an empty string. It is recommended that a
/// compositor includes an opaque generation value in identifiers. How the
/// generation value is used when generating the identifier is implementation
/// dependent.
/// 
 void onidentifier(void Function(String identifier) handler) {
   _identifierHandler = handler;
 }

 void Function(String identifier)? _identifierHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_closedHandler != null) {
         _closedHandler!(
         );
       }
       break;
     case 1:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 2:
       if (_titleHandler != null) {
         _titleHandler!(
           getString(data, 0),
         );
       }
       break;
     case 3:
       if (_appIdHandler != null) {
         _appIdHandler!(
           getString(data, 0),
         );
       }
       break;
     case 4:
       if (_identifierHandler != null) {
         _identifierHandler!(
           getString(data, 0),
         );
       }
       break;
   }
 }
}

