// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/drm-lease/drm-lease-v1.xml
//
// drm_lease_v1 Protocol Copyright: 
/// 
/// Copyright © 2018 NXP
/// Copyright © 2019 Status Research & Development GmbH.
/// Copyright © 2021 Xaver Hugl
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// lease device
/// 
/// This protocol is used by Wayland compositors which act as Direct
/// Rendering Manager (DRM) masters to lease DRM resources to Wayland
/// clients.
/// 
/// The compositor will advertise one wp_drm_lease_device_v1 global for each
/// DRM node. Some time after a client binds to the wp_drm_lease_device_v1
/// global, the compositor will send a drm_fd event followed by zero, one or
/// more connector events. After all currently available connectors have been
/// sent, the compositor will send a wp_drm_lease_device_v1.done event.
/// 
/// When the list of connectors available for lease changes the compositor
/// will send wp_drm_lease_device_v1.connector events for added connectors and
/// wp_drm_lease_connector_v1.withdrawn events for removed connectors,
/// followed by a wp_drm_lease_device_v1.done event.
/// 
/// The compositor will indicate when a device is gone by removing the global
/// via a wl_registry.global_remove event. Upon receiving this event, the
/// client should destroy any matching wp_drm_lease_device_v1 object.
/// 
/// To destroy a wp_drm_lease_device_v1 object, the client must first issue
/// a release request. Upon receiving this request, the compositor will
/// immediately send a released event and destroy the object. The client must
/// continue to process and discard drm_fd and connector events until it
/// receives the released event. Upon receiving the released event, the
/// client can safely cleanup any client-side resources.
/// 
/// Warning! The protocol described in this file is currently in the testing
/// phase. Backward compatible changes may be added together with the
/// corresponding interface version bump. Backward incompatible changes can
/// only be done by creating a new major version of the extension.
/// 
class WpDrmLeaseDeviceV1 extends Proxy implements Dispatcher{
  final Context context;

  WpDrmLeaseDeviceV1(this.context) : super(context.allocateClientId());

  Future<void> createLeaseRequest() async {
  var id =  WpDrmLeaseDeviceV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> release() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// open a non-master fd for this DRM node
/// 
/// The compositor will send this event when the wp_drm_lease_device_v1
/// global is bound, although there are no guarantees as to how long this
/// takes - the compositor might need to wait until regaining DRM master.
/// The included fd is a non-master DRM file descriptor opened for this
/// device and the compositor must not authenticate it.
/// The purpose of this event is to give the client the ability to
/// query DRM and discover information which may help them pick the
/// appropriate DRM device or select the appropriate connectors therein.
/// 
 void ondrmFd(void Function(int fd) handler) {
   _drmFdHandler = handler;
 }

 void Function(int fd)? _drmFdHandler;

 /// advertise connectors available for leases
/// 
/// The compositor will use this event to advertise connectors available for
/// lease by clients. This object may be passed into a lease request to
/// indicate the client would like to lease that connector, see
/// wp_drm_lease_request_v1.request_connector for details. While the
/// compositor will make a best effort to not send disconnected connectors,
/// no guarantees can be made.
/// 
/// The compositor must send the drm_fd event before sending connectors.
/// After the drm_fd event it will send all available connectors but may
/// send additional connectors at any time.
/// 
 void onconnector(void Function(int id) handler) {
   _connectorHandler = handler;
 }

 void Function(int id)? _connectorHandler;

 /// signals grouping of connectors
/// 
/// The compositor will send this event to indicate that it has sent all
/// currently available connectors after the client binds to the global or
/// when it updates the connector list, for example on hotplug, drm master
/// change or when a leased connector becomes available again. It will
/// similarly send this event to group wp_drm_lease_connector_v1.withdrawn
/// events of connectors of this device.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// the compositor has finished using the device
/// 
/// This event is sent in response to the release request and indicates
/// that the compositor is done sending connector events.
/// The compositor will destroy this object immediately after sending the
/// event and it will become invalid. The client should release any
/// resources associated with this device after receiving this event.
/// 
 void onreleased(void Function() handler) {
   _releasedHandler = handler;
 }

 void Function()? _releasedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_drmFdHandler != null) {
         _drmFdHandler!(
           fd,
         );
       }
       break;
     case 1:
       if (_connectorHandler != null) {
         _connectorHandler!(
           context.getProxy(ByteData.view(data.buffer).getUint32(0, Endian.host)).id,
         );
       }
       break;
     case 2:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 3:
       if (_releasedHandler != null) {
         _releasedHandler!(
         );
       }
       break;
   }
 }
}

/// a leasable DRM connector
/// 
/// Represents a DRM connector which is available for lease. These objects are
/// created via wp_drm_lease_device_v1.connector events, and should be passed
/// to lease requests via wp_drm_lease_request_v1.request_connector.
/// Immediately after the wp_drm_lease_connector_v1 object is created the
/// compositor will send a name, a description, a connector_id and a done
/// event. When the description is updated the compositor will send a
/// description event followed by a done event.
/// 
class WpDrmLeaseConnectorV1 extends Proxy implements Dispatcher{
  final Context context;

  WpDrmLeaseConnectorV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// name
/// 
/// The compositor sends this event once the connector is created to
/// indicate the name of this connector. This will not change for the
/// duration of the Wayland session, but is not guaranteed to be consistent
/// between sessions.
/// 
/// If the compositor supports wl_output version 4 and this connector
/// corresponds to a wl_output, the compositor should use the same name as
/// for the wl_output.
/// 
 void onname(void Function(String name) handler) {
   _nameHandler = handler;
 }

 void Function(String name)? _nameHandler;

 /// description
/// 
/// The compositor sends this event once the connector is created to provide
/// a human-readable description for this connector, which may be presented
/// to the user. The compositor may send this event multiple times over the
/// lifetime of this object to reflect changes in the description.
/// 
 void ondescription(void Function(String description) handler) {
   _descriptionHandler = handler;
 }

 void Function(String description)? _descriptionHandler;

 /// connector_id
/// 
/// The compositor sends this event once the connector is created to
/// indicate the DRM object ID which represents the underlying connector
/// that is being offered. Note that the final lease may include additional
/// object IDs, such as CRTCs and planes.
/// 
 void onconnectorId(void Function(int connectorId) handler) {
   _connectorIdHandler = handler;
 }

 void Function(int connectorId)? _connectorIdHandler;

 /// all properties have been sent
/// 
/// This event is sent after all properties of a connector have been sent.
/// This allows changes to the properties to be seen as atomic even if they
/// happen via multiple events.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 /// lease offer withdrawn
/// 
/// Sent to indicate that the compositor will no longer honor requests for
/// DRM leases which include this connector. The client may still issue a
/// lease request including this connector, but the compositor will send
/// wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
/// encouraged to send this event when they lose access to connector, for
/// example when the connector is hot-unplugged, when the connector gets
/// leased to a client or when the compositor loses DRM master.
/// 
 void onwithdrawn(void Function() handler) {
   _withdrawnHandler = handler;
 }

 void Function()? _withdrawnHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_nameHandler != null) {
         _nameHandler!(
           getString(data, 0),
         );
       }
       break;
     case 1:
       if (_descriptionHandler != null) {
         _descriptionHandler!(
           getString(data, 0),
         );
       }
       break;
     case 2:
       if (_connectorIdHandler != null) {
         _connectorIdHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 3:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
     case 4:
       if (_withdrawnHandler != null) {
         _withdrawnHandler!(
         );
       }
       break;
   }
 }
}

/// DRM lease request
/// 
/// A client that wishes to lease DRM resources will attach the list of
/// connectors advertised with wp_drm_lease_device_v1.connector that they
/// wish to lease, then use wp_drm_lease_request_v1.submit to submit the
/// request.
/// 
class WpDrmLeaseRequestV1 extends Proxy{
  final Context context;

  WpDrmLeaseRequestV1(this.context) : super(context.allocateClientId());

  Future<void> requestConnector(WpDrmLeaseConnectorV1 connector) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
        connector,
      ],
      [
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> submit() async {
  var id =  WpDrmLeaseRequestV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum WpDrmLeaseRequestV1error {
  /// requested a connector from a different lease device
  wrongDevice,
  /// requested a connector twice
  duplicateConnector,
  /// requested a lease without requesting a connector
  emptyLease,
}

/// a DRM lease
/// 
/// A DRM lease object is used to transfer the DRM file descriptor to the
/// client and manage the lifetime of the lease.
/// 
/// Some time after the wp_drm_lease_v1 object is created, the compositor
/// will reply with the lease request's result. If the lease request is
/// granted, the compositor will send a lease_fd event. If the lease request
/// is denied, the compositor will send a finished event without a lease_fd
/// event.
/// 
class WpDrmLeaseV1 extends Proxy implements Dispatcher{
  final Context context;

  WpDrmLeaseV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

 /// shares the DRM file descriptor
/// 
/// This event returns a file descriptor suitable for use with DRM-related
/// ioctls. The client should use drmModeGetLease to enumerate the DRM
/// objects which have been leased to them. The compositor guarantees it
/// will not use the leased DRM objects itself until it sends the finished
/// event. If the compositor cannot or will not grant a lease for the
/// requested connectors, it will not send this event, instead sending the
/// finished event.
/// 
/// The compositor will send this event at most once during this objects
/// lifetime.
/// 
 void onleaseFd(void Function(int leasedFd) handler) {
   _leaseFdHandler = handler;
 }

 void Function(int leasedFd)? _leaseFdHandler;

 /// sent when the lease has been revoked
/// 
/// The compositor uses this event to either reject a lease request, or if
/// it previously sent a lease_fd, to notify the client that the lease has
/// been revoked. If the client requires a new lease, they should destroy
/// this object and submit a new lease request. The compositor will send
/// no further events for this object after sending the finish event.
/// Compositors should revoke the lease when any of the leased resources
/// become unavailable, namely when a hot-unplug occurs or when the
/// compositor loses DRM master.
/// 
 void onfinished(void Function() handler) {
   _finishedHandler = handler;
 }

 void Function()? _finishedHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_leaseFdHandler != null) {
         _leaseFdHandler!(
           fd,
         );
       }
       break;
     case 1:
       if (_finishedHandler != null) {
         _finishedHandler!(
         );
       }
       break;
   }
 }
}

