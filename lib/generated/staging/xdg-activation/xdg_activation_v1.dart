// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/xdg-activation/xdg-activation-v1.xml
//
// xdg_activation_v1 Protocol Copyright: 
/// 
/// Copyright © 2020 Aleix Pol Gonzalez <aleixpol@kde.org>
/// Copyright © 2020 Carlos Garnacho <carlosg@gnome.org>
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:async';
import 'dart:typed_data';


/// interface for activating surfaces
/// 
/// A global interface used for informing the compositor about applications
/// being activated or started, or for applications to request to be
/// activated.
/// 
class XdgActivationV1 extends Proxy{
  final Context context;

  XdgActivationV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// destroy the xdg_activation object
/// 
/// Notify the compositor that the xdg_activation object will no longer be
/// used.
/// 
/// The child objects created via this interface are unaffected and should
/// be destroyed separately.
/// 
  Future<void> destroy() async {
    print("XdgActivationV1::destroy ");
    final message = WaylandMessage(
      objectId,
      0,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// requests a token
/// 
/// Creates an xdg_activation_token_v1 object that will provide
/// the initiating client with a unique token for this activation. This
/// token should be offered to the clients to be activated.
/// 
/// [id]:
  Future<XdgActivationTokenV1> getActivationToken() async {
  var id =  XdgActivationTokenV1(context);
    print("XdgActivationV1::getActivationToken  id: $id");
    final message = WaylandMessage(
      objectId,
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    await context.sendMessage(message);
    return id;
  }

/// notify new interaction being available
/// 
/// Requests surface activation. It's up to the compositor to display
/// this information as desired, for example by placing the surface above
/// the rest.
/// 
/// The compositor may know who requested this by checking the activation
/// token and might decide not to follow through with the activation if it's
/// considered unwanted.
/// 
/// Compositors can ignore unknown activation tokens when an invalid
/// token is passed.
/// 
/// [token]: the activation token of the initiating client
/// [surface]: the wl_surface to activate
  Future<void> activate(String token, Surface surface) async {
    print("XdgActivationV1::activate  token: $token surface: $surface");
    final message = WaylandMessage(
      objectId,
      2,
      [
        token,
        surface,
      ],
      [
        WaylandType.string,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
  }

}


/// the exported activation token
/// 
/// The 'done' event contains the unique token of this activation request
/// and notifies that the provider is done.
/// 
class XdgActivationTokenV1DoneEvent {
/// the exported activation token
  final String token;

  XdgActivationTokenV1DoneEvent(
this.token,

);

@override
String toString(){
  return """XdgActivationTokenV1DoneEvent: {
    token: $token,
  }""";
}

}

typedef XdgActivationTokenV1DoneEventHandler = void Function(XdgActivationTokenV1DoneEvent);


/// an exported activation handle
/// 
/// An object for setting up a token and receiving a token handle that can
/// be passed as an activation token to another client.
/// 
/// The object is created using the xdg_activation_v1.get_activation_token
/// request. This object should then be populated with the app_id, surface
/// and serial information and committed. The compositor shall then issue a
/// done event with the token. In case the request's parameters are invalid,
/// the compositor will provide an invalid token.
/// 
class XdgActivationTokenV1 extends Proxy implements Dispatcher{
  final Context context;

  XdgActivationTokenV1(this.context) : super(context.allocateClientId()){
    context.register(this);
  }

/// specifies the seat and serial of the activating event
/// 
/// Provides information about the seat and serial event that requested the
/// token.
/// 
/// The serial can come from an input or focus event. For instance, if a
/// click triggers the launch of a third-party client, the launcher client
/// should send a set_serial request with the serial and seat from the
/// wl_pointer.button event.
/// 
/// Some compositors might refuse to activate toplevels when the token
/// doesn't have a valid and recent enough event serial.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [serial]: the serial of the event that triggered the activation
/// [seat]: the wl_seat of the event
  Future<void> setSerial(int serial, Seat seat) async {
    print("XdgActivationTokenV1::setSerial  serial: $serial seat: $seat");
    final message = WaylandMessage(
      objectId,
      0,
      [
        serial,
        seat,
      ],
      [
        WaylandType.uint,
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
  }

/// specifies the application being activated
/// 
/// The requesting client can specify an app_id to associate the token
/// being created with it.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [app_id]: the application id of the client being activated.
  Future<void> setAppId(String appId) async {
    print("XdgActivationTokenV1::setAppId  appId: $appId");
    final message = WaylandMessage(
      objectId,
      1,
      [
        appId,
      ],
      [
        WaylandType.string,
      ],
    );
    await context.sendMessage(message);
  }

/// specifies the surface requesting activation
/// 
/// This request sets the surface requesting the activation. Note, this is
/// different from the surface that will be activated.
/// 
/// Some compositors might refuse to activate toplevels when the token
/// doesn't have a requesting surface.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [surface]: the requesting surface
  Future<void> setSurface(Surface surface) async {
    print("XdgActivationTokenV1::setSurface  surface: $surface");
    final message = WaylandMessage(
      objectId,
      2,
      [
        surface,
      ],
      [
        WaylandType.object,
      ],
    );
    await context.sendMessage(message);
  }

/// issues the token request
/// 
/// Requests an activation token based on the different parameters that
/// have been offered through set_serial, set_surface and set_app_id.
/// 
  Future<void> commit() async {
    print("XdgActivationTokenV1::commit ");
    final message = WaylandMessage(
      objectId,
      3,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// destroy the xdg_activation_token_v1 object
/// 
/// Notify the compositor that the xdg_activation_token_v1 object will no
/// longer be used. The received token stays valid.
/// 
  Future<void> destroy() async {
    print("XdgActivationTokenV1::destroy ");
    final message = WaylandMessage(
      objectId,
      4,
      [
      ],
      [
      ],
    );
    await context.sendMessage(message);
  }

/// the exported activation token
/// 
/// The 'done' event contains the unique token of this activation request
/// and notifies that the provider is done.
/// 
/// Event handler for Done
/// - [token]: the exported activation token
 void onDone(XdgActivationTokenV1DoneEventHandler handler) {
   _doneHandler = handler;
 }

 XdgActivationTokenV1DoneEventHandler? _doneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_doneHandler != null) {
var event = XdgActivationTokenV1DoneEvent(
           getString(data, 0),
        );
         _doneHandler!(event);
       }
       break;
   }
 }
}

/// 
/// 

enum XdgActivationTokenV1error {
/// The token has already been used previously
  alreadyUsed,
}

