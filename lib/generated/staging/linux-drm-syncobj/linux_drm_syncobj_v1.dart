// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/linux-drm-syncobj/linux-drm-syncobj-v1.xml
//
// linux_drm_syncobj_v1 Protocol Copyright: 
/// 
/// Copyright 2016 The Chromium Authors.
/// Copyright 2017 Intel Corporation
/// Copyright 2018 Collabora, Ltd
/// Copyright 2021 Simon Ser
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'dart:typed_data';
/// global for providing explicit synchronization
/// 
/// This global is a factory interface, allowing clients to request
/// explicit synchronization for buffers on a per-surface basis.
/// 
/// See wp_linux_drm_syncobj_surface_v1 for more information.
/// 
class WpLinuxDrmSyncobjManagerV1 extends Proxy{
  final Context context;

  WpLinuxDrmSyncobjManagerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> getSurface(Surface surface) async {
  var id =  WpLinuxDrmSyncobjManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
        surface,
      ],
      [
        WaylandType.newId,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> importTimeline(int fd) async {
  var id =  WpLinuxDrmSyncobjManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        id,
        fd,
      ],
      [
        WaylandType.newId,
        WaylandType.fd,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum WpLinuxDrmSyncobjManagerV1error {
  /// the surface already has a synchronization object associated
  surfaceExists,
  /// the timeline object could not be imported
  invalidTimeline,
}

/// synchronization object timeline
/// 
/// This object represents an explicit synchronization object timeline
/// imported by the client to the compositor.
/// 
class WpLinuxDrmSyncobjTimelineV1 extends Proxy{
  final Context context;

  WpLinuxDrmSyncobjTimelineV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

}

/// per-surface explicit synchronization
/// 
/// This object is an add-on interface for wl_surface to enable explicit
/// synchronization.
/// 
/// Each surface can be associated with only one object of this interface at
/// any time.
/// 
/// Explicit synchronization is guaranteed to be supported for buffers
/// created with any version of the linux-dmabuf protocol. Compositors are
/// free to support explicit synchronization for additional buffer types.
/// If at surface commit time the attached buffer does not support explicit
/// synchronization, an unsupported_buffer error is raised.
/// 
/// As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the
/// compositor may ignore implicit synchronization for buffers attached and
/// committed to the wl_surface. The delivery of wl_buffer.release events
/// for buffers attached to the surface becomes undefined.
/// 
/// Clients must set both acquire and release points if and only if a
/// non-null buffer is attached in the same surface commit. See the
/// no_buffer, no_acquire_point and no_release_point protocol errors.
/// 
/// If at surface commit time the acquire and release DRM syncobj timelines
/// are identical, the acquire point value must be strictly less than the
/// release point value, or else the conflicting_points protocol error is
/// raised.
/// 
class WpLinuxDrmSyncobjSurfaceV1 extends Proxy{
  final Context context;

  WpLinuxDrmSyncobjSurfaceV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setAcquirePoint(WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        timeline,
        pointHi,
        pointLo,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setReleasePoint(WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        timeline,
        pointHi,
        pointLo,
      ],
      [
        WaylandType.object,
        WaylandType.uint,
        WaylandType.uint,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum WpLinuxDrmSyncobjSurfaceV1error {
  /// the associated wl_surface was destroyed
  noSurface,
  /// the buffer does not support explicit synchronization
  unsupportedBuffer,
  /// no buffer was attached
  noBuffer,
  /// no acquire timeline point was set
  noAcquirePoint,
  /// no release timeline point was set
  noReleasePoint,
  /// acquire and release timeline points are in conflict
  conflictingPoints,
}

