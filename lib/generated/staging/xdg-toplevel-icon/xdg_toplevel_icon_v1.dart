// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/xdg-toplevel-icon/xdg-toplevel-icon-v1.xml
//
// xdg_toplevel_icon_v1 Protocol Copyright: 
/// 
/// Copyright © 2023-2024 Matthias Klumpp
/// Copyright ©      2024 David Edmundson
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/generated/wayland.dart';
import 'package:wayland/generated/stable/xdg-shell/xdg_shell.dart';
import 'dart:typed_data';
/// interface to manage toplevel icons
/// 
/// This interface allows clients to create toplevel window icons and set
/// them on toplevel windows to be displayed to the user.
/// 
class XdgToplevelIconManagerV1 extends Proxy implements Dispatcher{
  final Context context;

  XdgToplevelIconManagerV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> createIcon() async {
  var id =  XdgToplevelIconManagerV1(context);
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        id,
      ],
      [
        WaylandType.newId,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setIcon(XdgToplevel toplevel, XdgToplevelIconV1 icon) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        toplevel,
        icon,
      ],
      [
        WaylandType.object,
        WaylandType.object,
      ],
    );
    context.sendMessage(message);
  }

 /// describes a supported & preferred icon size
/// 
/// This event indicates an icon size the compositor prefers to be
/// available if the client has scalable icons and can render to any size.
/// 
/// When the 'xdg_toplevel_icon_manager_v1' object is created, the
/// compositor may send one or more 'icon_size' events to describe the list
/// of preferred icon sizes. If the compositor has no size preference, it
/// may not send any 'icon_size' event, and it is up to the client to
/// decide a suitable icon size.
/// 
/// A sequence of 'icon_size' events must be finished with a 'done' event.
/// If the compositor has no size preferences, it must still send the
/// 'done' event, without any preceding 'icon_size' events.
/// 
 void oniconSize(void Function(int size) handler) {
   _iconSizeHandler = handler;
 }

 void Function(int size)? _iconSizeHandler;

 /// all information has been sent
/// 
/// This event is sent after all 'icon_size' events have been sent.
/// 
 void ondone(void Function() handler) {
   _doneHandler = handler;
 }

 void Function()? _doneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
   switch (opcode) {
     case 0:
       if (_iconSizeHandler != null) {
         _iconSizeHandler!(
           ByteData.view(data.buffer).getInt32(0, Endian.host),
         );
       }
       break;
     case 1:
       if (_doneHandler != null) {
         _doneHandler!(
         );
       }
       break;
   }
 }
}

/// a toplevel window icon
/// 
/// This interface defines a toplevel icon.
/// An icon can have a name, and multiple buffers.
/// In order to be applied, the icon must have either a name, or at least
/// one buffer assigned. Applying an empty icon (with no buffer or name) to
/// a toplevel should reset its icon to the default icon.
/// 
/// It is up to compositor policy whether to prefer using a buffer or loading
/// an icon via its name. See 'set_name' and 'add_buffer' for details.
/// 
class XdgToplevelIconV1 extends Proxy{
  final Context context;

  XdgToplevelIconV1(this.context) : super(context.allocateClientId());

  Future<void> destroy() async {
    final message = WaylandMessage(
      context.allocateClientId(),
      0,
      [
      ],
      [
      ],
    );
    context.sendMessage(message);
  }

  Future<void> setName(String iconName) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      1,
      [
        iconName,
      ],
      [
        WaylandType.string,
      ],
    );
    context.sendMessage(message);
  }

  Future<void> addBuffer(Buffer buffer, int scale) async {
    final message = WaylandMessage(
      context.allocateClientId(),
      2,
      [
        buffer,
        scale,
      ],
      [
        WaylandType.object,
        WaylandType.int,
      ],
    );
    context.sendMessage(message);
  }

}

/// 
/// 

enum XdgToplevelIconV1error {
  /// the provided buffer does not satisfy requirements
  invalidBuffer,
  /// the icon has already been assigned to a toplevel and must not be changed
  immutable,
}

