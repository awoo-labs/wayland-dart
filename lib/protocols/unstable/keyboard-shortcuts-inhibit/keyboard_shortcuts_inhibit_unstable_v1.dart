// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/keyboard-shortcuts-inhibit/keyboard-shortcuts-inhibit-unstable-v1.xml
//
// keyboard_shortcuts_inhibit_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2017 Red Hat Inc.
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:result_dart/result_dart.dart';


/// context object for keyboard grab_manager
/// 
/// A global interface used for inhibiting the compositor keyboard shortcuts.
/// 
class ZwpKeyboardShortcutsInhibitManagerV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  ZwpKeyboardShortcutsInhibitManagerV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "ZwpKeyboardShortcutsInhibitManagerV1 {name: 'zwp_keyboard_shortcuts_inhibit_manager_v1', id: '$objectId', version: '1',}";
}

/// destroy the keyboard shortcuts inhibitor object
/// 
/// Destroy the keyboard shortcuts inhibitor manager.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("ZwpKeyboardShortcutsInhibitManagerV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpKeyboardShortcutsInhibitManagerV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// create a new keyboard shortcuts inhibitor object
/// 
/// Create a new keyboard shortcuts inhibitor object associated with
/// the given surface for the given seat.
/// 
/// If shortcuts are already inhibited for the specified seat and surface,
/// a protocol error "already_inhibited" is raised by the compositor.
/// 
/// [id]:
/// [surface]: the surface that inhibits the keyboard shortcuts behavior
/// [seat]: the wl_seat for which keyboard shortcuts should be disabled
  Result<ZwpKeyboardShortcutsInhibitorV1,Object> inhibitShortcuts(Surface surface, Seat seat) {
  var id =  ZwpKeyboardShortcutsInhibitorV1(innerContext);
    logLn("ZwpKeyboardShortcutsInhibitManagerV1::inhibitShortcuts  id: $id surface: $surface seat: $seat");
var arguments = [id, surface, seat];var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpKeyboardShortcutsInhibitManagerV1::inhibitShortcuts: $e");
   return Failure(e);
    }
    return Success(id);
  }

}

/// 
/// 

enum ZwpKeyboardShortcutsInhibitManagerV1Error {
/// the shortcuts are already inhibited for this surface
  alreadyInhibited("already_inhibited", 0);
const ZwpKeyboardShortcutsInhibitManagerV1Error(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "ZwpKeyboardShortcutsInhibitManagerV1Error {name: $enumName, value: $enumValue}";
}
}


/// shortcuts are inhibited
/// 
/// This event indicates that the shortcut inhibitor is active.
/// 
/// The compositor sends this event every time compositor shortcuts
/// are inhibited on behalf of the surface. When active, the client
/// may receive input events normally reserved by the compositor
/// (see zwp_keyboard_shortcuts_inhibitor_v1).
/// 
/// This occurs typically when the initial request "inhibit_shortcuts"
/// first becomes active or when the user instructs the compositor to
/// re-enable and existing shortcuts inhibitor using any mechanism
/// offered by the compositor.
/// 
class ZwpKeyboardShortcutsInhibitorV1ActiveEvent {
  ZwpKeyboardShortcutsInhibitorV1ActiveEvent(
);

@override
toString(){
return "ZwpKeyboardShortcutsInhibitorV1ActiveEvent ()";
}
}

typedef ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler = void Function(ZwpKeyboardShortcutsInhibitorV1ActiveEvent);

/// shortcuts are restored
/// 
/// This event indicates that the shortcuts inhibitor is inactive,
/// normal shortcuts processing is restored by the compositor.
/// 
class ZwpKeyboardShortcutsInhibitorV1InactiveEvent {
  ZwpKeyboardShortcutsInhibitorV1InactiveEvent(
);

@override
toString(){
return "ZwpKeyboardShortcutsInhibitorV1InactiveEvent ()";
}
}

typedef ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler = void Function(ZwpKeyboardShortcutsInhibitorV1InactiveEvent);


/// context object for keyboard shortcuts inhibitor
/// 
/// A keyboard shortcuts inhibitor instructs the compositor to ignore
/// its own keyboard shortcuts when the associated surface has keyboard
/// focus. As a result, when the surface has keyboard focus on the given
/// seat, it will receive all key events originating from the specified
/// seat, even those which would normally be caught by the compositor for
/// its own shortcuts.
/// 
/// The Wayland compositor is however under no obligation to disable
/// all of its shortcuts, and may keep some special key combo for its own
/// use, including but not limited to one allowing the user to forcibly
/// restore normal keyboard events routing in the case of an unwilling
/// client. The compositor may also use the same key combo to reactivate
/// an existing shortcut inhibitor that was previously deactivated on
/// user request.
/// 
/// When the compositor restores its own keyboard shortcuts, an
/// "inactive" event is emitted to notify the client that the keyboard
/// shortcuts inhibitor is not effectively active for the surface and
/// seat any more, and the client should not expect to receive all
/// keyboard events.
/// 
/// When the keyboard shortcuts inhibitor is inactive, the client has
/// no way to forcibly reactivate the keyboard shortcuts inhibitor.
/// 
/// The user can chose to re-enable a previously deactivated keyboard
/// shortcuts inhibitor using any mechanism the compositor may offer,
/// in which case the compositor will send an "active" event to notify
/// the client.
/// 
/// If the surface is destroyed, unmapped, or loses the seat's keyboard
/// focus, the keyboard shortcuts inhibitor becomes irrelevant and the
/// compositor will restore its own keyboard shortcuts but no "inactive"
/// event is emitted in this case.
/// 
class ZwpKeyboardShortcutsInhibitorV1 extends Proxy implements Dispatcher{
  final Context innerContext;
  final version = 1;

  ZwpKeyboardShortcutsInhibitorV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "ZwpKeyboardShortcutsInhibitorV1 {name: 'zwp_keyboard_shortcuts_inhibitor_v1', id: '$objectId', version: '1',}";
}

/// destroy the keyboard shortcuts inhibitor object
/// 
/// Remove the keyboard shortcuts inhibitor from the associated wl_surface.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("ZwpKeyboardShortcutsInhibitorV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpKeyboardShortcutsInhibitorV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// shortcuts are inhibited
/// 
/// This event indicates that the shortcut inhibitor is active.
/// 
/// The compositor sends this event every time compositor shortcuts
/// are inhibited on behalf of the surface. When active, the client
/// may receive input events normally reserved by the compositor
/// (see zwp_keyboard_shortcuts_inhibitor_v1).
/// 
/// This occurs typically when the initial request "inhibit_shortcuts"
/// first becomes active or when the user instructs the compositor to
/// re-enable and existing shortcuts inhibitor using any mechanism
/// offered by the compositor.
/// 
/// Event handler for Active
 void onActive(ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler handler) {
   _activeHandler = handler;
 }

 ZwpKeyboardShortcutsInhibitorV1ActiveEventHandler? _activeHandler;

/// shortcuts are restored
/// 
/// This event indicates that the shortcuts inhibitor is inactive,
/// normal shortcuts processing is restored by the compositor.
/// 
/// Event handler for Inactive
 void onInactive(ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler handler) {
   _inactiveHandler = handler;
 }

 ZwpKeyboardShortcutsInhibitorV1InactiveEventHandler? _inactiveHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
logLn("ZwpKeyboardShortcutsInhibitorV1.dispatch($opcode, $fd, $data)");
   switch (opcode) {     case 0:

       if (_activeHandler != null) {
         _activeHandler!(ZwpKeyboardShortcutsInhibitorV1ActiveEvent());
       }
       break;
     case 1:

       if (_inactiveHandler != null) {
         _inactiveHandler!(ZwpKeyboardShortcutsInhibitorV1InactiveEvent());
       }
       break;
   }
 }
}

