// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/tablet/tablet-unstable-v1.xml
//
// tablet_unstable_v1 Protocol Copyright:
///
/// Copyright 2014 © Stephen "Lyude" Chandler Paul
/// Copyright 2015-2016 © Red Hat, Inc.
///
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files
/// (the "Software"), to deal in the Software without restriction,
/// including without limitation the rights to use, copy, modify, merge,
/// publish, distribute, sublicense, and/or sell copies of the Software,
/// and to permit persons to whom the Software is furnished to do so,
/// subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the
/// next paragraph) shall be included in all copies or substantial
/// portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
/// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
/// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// controller object for graphic tablet devices
///
/// An object that provides access to the graphics tablets available on this
/// system. All tablets are associated with a seat, to get access to the
/// actual tablets, use wp_tablet_manager.get_tablet_seat.
///
class ZwpTabletManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZwpTabletManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletManagerV1 {name: 'zwp_tablet_manager_v1', id: '$objectId', version: '1',}";
  }

  /// get the tablet seat
  ///
  /// Get the wp_tablet_seat object for the given seat. This object
  /// provides access to all graphics tablets in this seat.
  ///
  /// [tablet_seat]:
  /// [seat]: The wl_seat object to retrieve the tablets for
  ZwpTabletSeatV1 getTabletSeat(Seat seat) {
    var tabletSeat = ZwpTabletSeatV1(innerContext);
    logLn(
        "ZwpTabletManagerV1::getTabletSeat  tabletSeat: $tabletSeat seat: $seat");
    var arguments = [tabletSeat, seat];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([tabletSeat.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return tabletSeat;
  }

  /// release the memory for the tablet manager object
  ///
  /// Destroy the wp_tablet_manager object. Objects created from this
  /// object are unaffected and should be destroyed separately.
  ///
  void destroy() {
    logLn("ZwpTabletManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }
}

/// new device notification
///
/// This event is sent whenever a new tablet becomes available on this
/// seat. This event only provides the object id of the tablet, any
/// static information about the tablet (device name, vid/pid, etc.) is
/// sent through the wp_tablet interface.
///
class ZwpTabletSeatV1TabletAddedEvent {
  /// the newly added graphics tablet
  final int id;

  ZwpTabletSeatV1TabletAddedEvent(
    this.id,
  );

  @override
  toString() {
    return "ZwpTabletSeatV1TabletAddedEvent (id: $id)";
  }
}

typedef ZwpTabletSeatV1TabletAddedEventHandler = void Function(
    ZwpTabletSeatV1TabletAddedEvent);

/// a new tool has been used with a tablet
///
/// This event is sent whenever a tool that has not previously been used
/// with a tablet comes into use. This event only provides the object id
/// of the tool; any static information about the tool (capabilities,
/// type, etc.) is sent through the wp_tablet_tool interface.
///
class ZwpTabletSeatV1ToolAddedEvent {
  /// the newly added tablet tool
  final int id;

  ZwpTabletSeatV1ToolAddedEvent(
    this.id,
  );

  @override
  toString() {
    return "ZwpTabletSeatV1ToolAddedEvent (id: $id)";
  }
}

typedef ZwpTabletSeatV1ToolAddedEventHandler = void Function(
    ZwpTabletSeatV1ToolAddedEvent);

/// controller object for graphic tablet devices of a seat
///
/// An object that provides access to the graphics tablets available on this
/// seat. After binding to this interface, the compositor sends a set of
/// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
///
class ZwpTabletSeatV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletSeatV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletSeatV1 {name: 'zwp_tablet_seat_v1', id: '$objectId', version: '1',}";
  }

  /// release the memory for the tablet seat object
  ///
  /// Destroy the wp_tablet_seat object. Objects created from this
  /// object are unaffected and should be destroyed separately.
  ///
  void destroy() {
    logLn("ZwpTabletSeatV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// new device notification
  ///
  /// This event is sent whenever a new tablet becomes available on this
  /// seat. This event only provides the object id of the tablet, any
  /// static information about the tablet (device name, vid/pid, etc.) is
  /// sent through the wp_tablet interface.
  ///
  /// Event handler for TabletAdded
  /// - [id]: the newly added graphics tablet
  void onTabletAdded(ZwpTabletSeatV1TabletAddedEventHandler handler) {
    _tabletAddedHandler = handler;
  }

  ZwpTabletSeatV1TabletAddedEventHandler? _tabletAddedHandler;

  /// a new tool has been used with a tablet
  ///
  /// This event is sent whenever a tool that has not previously been used
  /// with a tablet comes into use. This event only provides the object id
  /// of the tool; any static information about the tool (capabilities,
  /// type, etc.) is sent through the wp_tablet_tool interface.
  ///
  /// Event handler for ToolAdded
  /// - [id]: the newly added tablet tool
  void onToolAdded(ZwpTabletSeatV1ToolAddedEventHandler handler) {
    _toolAddedHandler = handler;
  }

  ZwpTabletSeatV1ToolAddedEventHandler? _toolAddedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletSeatV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_tabletAddedHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletSeatV1TabletAddedEvent(
            id,
          );
          _tabletAddedHandler!(event);
        }
        break;
      case 1:
        if (_toolAddedHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletSeatV1ToolAddedEvent(
            id,
          );
          _toolAddedHandler!(event);
        }
        break;
    }
  }
}

/// tool type
///
/// The tool type is the high-level type of the tool and usually decides
/// the interaction expected from this tool.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV1TypeEvent {
  /// the physical tool type
  final int toolType;

  ZwpTabletToolV1TypeEvent(
    this.toolType,
  );

  @override
  toString() {
    return "ZwpTabletToolV1TypeEvent (toolType: $toolType)";
  }
}

typedef ZwpTabletToolV1TypeEventHandler = void Function(
    ZwpTabletToolV1TypeEvent);

/// unique hardware serial number of the tool
///
/// If the physical tool can be identified by a unique 64-bit serial
/// number, this event notifies the client of this serial number.
///
/// If multiple tablets are available in the same seat and the tool is
/// uniquely identifiable by the serial number, that tool may move
/// between tablets.
///
/// Otherwise, if the tool has no serial number and this event is
/// missing, the tool is tied to the tablet it first comes into
/// proximity with. Even if the physical tool is used on multiple
/// tablets, separate wp_tablet_tool objects will be created, one per
/// tablet.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV1HardwareSerialEvent {
  /// the unique serial number of the tool, most significant bits
  final int hardwareSerialHi;

  /// the unique serial number of the tool, least significant bits
  final int hardwareSerialLo;

  ZwpTabletToolV1HardwareSerialEvent(
    this.hardwareSerialHi,
    this.hardwareSerialLo,
  );

  @override
  toString() {
    return "ZwpTabletToolV1HardwareSerialEvent (hardwareSerialHi: $hardwareSerialHi, hardwareSerialLo: $hardwareSerialLo)";
  }
}

typedef ZwpTabletToolV1HardwareSerialEventHandler = void Function(
    ZwpTabletToolV1HardwareSerialEvent);

/// hardware id notification in Wacom's format
///
/// This event notifies the client of a hardware id available on this tool.
///
/// The hardware id is a device-specific 64-bit id that provides extra
/// information about the tool in use, beyond the wl_tool.type
/// enumeration. The format of the id is specific to tablets made by
/// Wacom Inc. For example, the hardware id of a Wacom Grip
/// Pen (a stylus) is 0x802.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV1HardwareIdWacomEvent {
  /// the hardware id, most significant bits
  final int hardwareIdHi;

  /// the hardware id, least significant bits
  final int hardwareIdLo;

  ZwpTabletToolV1HardwareIdWacomEvent(
    this.hardwareIdHi,
    this.hardwareIdLo,
  );

  @override
  toString() {
    return "ZwpTabletToolV1HardwareIdWacomEvent (hardwareIdHi: $hardwareIdHi, hardwareIdLo: $hardwareIdLo)";
  }
}

typedef ZwpTabletToolV1HardwareIdWacomEventHandler = void Function(
    ZwpTabletToolV1HardwareIdWacomEvent);

/// tool capability notification
///
/// This event notifies the client of any capabilities of this tool,
/// beyond the main set of x/y axes and tip up/down detection.
///
/// One event is sent for each extra capability available on this tool.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV1CapabilityEvent {
  /// the capability
  final int capability;

  ZwpTabletToolV1CapabilityEvent(
    this.capability,
  );

  @override
  toString() {
    return "ZwpTabletToolV1CapabilityEvent (capability: $capability)";
  }
}

typedef ZwpTabletToolV1CapabilityEventHandler = void Function(
    ZwpTabletToolV1CapabilityEvent);

/// tool description events sequence complete
///
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the tool to
/// be complete and finalize initialization of the tool.
///
class ZwpTabletToolV1DoneEvent {
  ZwpTabletToolV1DoneEvent();

  @override
  toString() {
    return "ZwpTabletToolV1DoneEvent ()";
  }
}

typedef ZwpTabletToolV1DoneEventHandler = void Function(
    ZwpTabletToolV1DoneEvent);

/// tool removed
///
/// This event is sent when the tool is removed from the system and will
/// send no further events. Should the physical tool come back into
/// proximity later, a new wp_tablet_tool object will be created.
///
/// It is compositor-dependent when a tool is removed. A compositor may
/// remove a tool on proximity out, tablet removal or any other reason.
/// A compositor may also keep a tool alive until shutdown.
///
/// If the tool is currently in proximity, a proximity_out event will be
/// sent before the removed event. See wp_tablet_tool.proximity_out for
/// the handling of any buttons logically down.
///
/// When this event is received, the client must wp_tablet_tool.destroy
/// the object.
///
class ZwpTabletToolV1RemovedEvent {
  ZwpTabletToolV1RemovedEvent();

  @override
  toString() {
    return "ZwpTabletToolV1RemovedEvent ()";
  }
}

typedef ZwpTabletToolV1RemovedEventHandler = void Function(
    ZwpTabletToolV1RemovedEvent);

/// proximity in event
///
/// Notification that this tool is focused on a certain surface.
///
/// This event can be received when the tool has moved from one surface to
/// another, or when the tool has come back into proximity above the
/// surface.
///
/// If any button is logically down when the tool comes into proximity,
/// the respective button event is sent after the proximity_in event but
/// within the same frame as the proximity_in event.
///
class ZwpTabletToolV1ProximityInEvent {
  ///
  final int serial;

  /// The tablet the tool is in proximity of
  final int tablet;

  /// The current surface the tablet tool is over
  final int surface;

  ZwpTabletToolV1ProximityInEvent(
    this.serial,
    this.tablet,
    this.surface,
  );

  @override
  toString() {
    return "ZwpTabletToolV1ProximityInEvent (serial: $serial, tablet: $tablet, surface: $surface)";
  }
}

typedef ZwpTabletToolV1ProximityInEventHandler = void Function(
    ZwpTabletToolV1ProximityInEvent);

/// proximity out event
///
/// Notification that this tool has either left proximity, or is no
/// longer focused on a certain surface.
///
/// When the tablet tool leaves proximity of the tablet, button release
/// events are sent for each button that was held down at the time of
/// leaving proximity. These events are sent before the proximity_out
/// event but within the same wp_tablet.frame.
///
/// If the tool stays within proximity of the tablet, but the focus
/// changes from one surface to another, a button release event may not
/// be sent until the button is actually released or the tool leaves the
/// proximity of the tablet.
///
class ZwpTabletToolV1ProximityOutEvent {
  ZwpTabletToolV1ProximityOutEvent();

  @override
  toString() {
    return "ZwpTabletToolV1ProximityOutEvent ()";
  }
}

typedef ZwpTabletToolV1ProximityOutEventHandler = void Function(
    ZwpTabletToolV1ProximityOutEvent);

/// tablet tool is making contact
///
/// Sent whenever the tablet tool comes in contact with the surface of the
/// tablet.
///
/// If the tool is already in contact with the tablet when entering the
/// input region, the client owning said region will receive a
/// wp_tablet.proximity_in event, followed by a wp_tablet.down
/// event and a wp_tablet.frame event.
///
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool in
/// logical contact until a minimum physical pressure threshold is
/// exceeded.
///
class ZwpTabletToolV1DownEvent {
  ///
  final int serial;

  ZwpTabletToolV1DownEvent(
    this.serial,
  );

  @override
  toString() {
    return "ZwpTabletToolV1DownEvent (serial: $serial)";
  }
}

typedef ZwpTabletToolV1DownEventHandler = void Function(
    ZwpTabletToolV1DownEvent);

/// tablet tool is no longer making contact
///
/// Sent whenever the tablet tool stops making contact with the surface of
/// the tablet, or when the tablet tool moves out of the input region
/// and the compositor grab (if any) is dismissed.
///
/// If the tablet tool moves out of the input region while in contact
/// with the surface of the tablet and the compositor does not have an
/// ongoing grab on the surface, the client owning said region will
/// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
/// event and a wp_tablet.frame event. If the compositor has an ongoing
/// grab on this device, this event sequence is sent whenever the grab
/// is dismissed in the future.
///
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool out
/// of logical contact until physical pressure falls below a specific
/// threshold.
///
class ZwpTabletToolV1UpEvent {
  ZwpTabletToolV1UpEvent();

  @override
  toString() {
    return "ZwpTabletToolV1UpEvent ()";
  }
}

typedef ZwpTabletToolV1UpEventHandler = void Function(ZwpTabletToolV1UpEvent);

/// motion event
///
/// Sent whenever a tablet tool moves.
///
class ZwpTabletToolV1MotionEvent {
  /// surface-local x coordinate
  final double x;

  /// surface-local y coordinate
  final double y;

  ZwpTabletToolV1MotionEvent(
    this.x,
    this.y,
  );

  @override
  toString() {
    return "ZwpTabletToolV1MotionEvent (x: $x, y: $y)";
  }
}

typedef ZwpTabletToolV1MotionEventHandler = void Function(
    ZwpTabletToolV1MotionEvent);

/// pressure change event
///
/// Sent whenever the pressure axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
///
/// Note that pressure may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
///
class ZwpTabletToolV1PressureEvent {
  /// The current pressure value
  final int pressure;

  ZwpTabletToolV1PressureEvent(
    this.pressure,
  );

  @override
  toString() {
    return "ZwpTabletToolV1PressureEvent (pressure: $pressure)";
  }
}

typedef ZwpTabletToolV1PressureEventHandler = void Function(
    ZwpTabletToolV1PressureEvent);

/// distance change event
///
/// Sent whenever the distance axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
///
/// Note that distance may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
///
class ZwpTabletToolV1DistanceEvent {
  /// The current distance value
  final int distance;

  ZwpTabletToolV1DistanceEvent(
    this.distance,
  );

  @override
  toString() {
    return "ZwpTabletToolV1DistanceEvent (distance: $distance)";
  }
}

typedef ZwpTabletToolV1DistanceEventHandler = void Function(
    ZwpTabletToolV1DistanceEvent);

/// tilt change event
///
/// Sent whenever one or both of the tilt axes on a tool change. Each tilt
/// value is in 0.01 of a degree, relative to the z-axis of the tablet.
/// The angle is positive when the top of a tool tilts along the
/// positive x or y axis.
///
class ZwpTabletToolV1TiltEvent {
  /// The current value of the X tilt axis
  final int tiltX;

  /// The current value of the Y tilt axis
  final int tiltY;

  ZwpTabletToolV1TiltEvent(
    this.tiltX,
    this.tiltY,
  );

  @override
  toString() {
    return "ZwpTabletToolV1TiltEvent (tiltX: $tiltX, tiltY: $tiltY)";
  }
}

typedef ZwpTabletToolV1TiltEventHandler = void Function(
    ZwpTabletToolV1TiltEvent);

/// z-rotation change event
///
/// Sent whenever the z-rotation axis on the tool changes. The
/// rotation value is in 0.01 of a degree clockwise from the tool's
/// logical neutral position.
///
class ZwpTabletToolV1RotationEvent {
  /// The current rotation of the Z axis
  final int degrees;

  ZwpTabletToolV1RotationEvent(
    this.degrees,
  );

  @override
  toString() {
    return "ZwpTabletToolV1RotationEvent (degrees: $degrees)";
  }
}

typedef ZwpTabletToolV1RotationEventHandler = void Function(
    ZwpTabletToolV1RotationEvent);

/// Slider position change event
///
/// Sent whenever the slider position on the tool changes. The
/// value is normalized between -65535 and 65535, with 0 as the logical
/// neutral position of the slider.
///
/// The slider is available on e.g. the Wacom Airbrush tool.
///
class ZwpTabletToolV1SliderEvent {
  /// The current position of slider
  final int position;

  ZwpTabletToolV1SliderEvent(
    this.position,
  );

  @override
  toString() {
    return "ZwpTabletToolV1SliderEvent (position: $position)";
  }
}

typedef ZwpTabletToolV1SliderEventHandler = void Function(
    ZwpTabletToolV1SliderEvent);

/// Wheel delta event
///
/// Sent whenever the wheel on the tool emits an event. This event
/// contains two values for the same axis change. The degrees value is
/// in 0.01 of a degree in the same orientation as the
/// wl_pointer.vertical_scroll axis. The clicks value is in discrete
/// logical clicks of the mouse wheel. This value may be zero if the
/// movement of the wheel was less than one logical click.
///
/// Clients should choose either value and avoid mixing degrees and
/// clicks. The compositor may accumulate values smaller than a logical
/// click and emulate click events when a certain threshold is met.
/// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
/// have different degrees values.
///
class ZwpTabletToolV1WheelEvent {
  /// The wheel delta in 0.01 of a degree
  final int degrees;

  /// The wheel delta in discrete clicks
  final int clicks;

  ZwpTabletToolV1WheelEvent(
    this.degrees,
    this.clicks,
  );

  @override
  toString() {
    return "ZwpTabletToolV1WheelEvent (degrees: $degrees, clicks: $clicks)";
  }
}

typedef ZwpTabletToolV1WheelEventHandler = void Function(
    ZwpTabletToolV1WheelEvent);

/// button event
///
/// Sent whenever a button on the tool is pressed or released.
///
/// If a button is held down when the tool moves in or out of proximity,
/// button events are generated by the compositor. See
/// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
/// details.
///
class ZwpTabletToolV1ButtonEvent {
  ///
  final int serial;

  /// The button whose state has changed
  final int button;

  /// Whether the button was pressed or released
  final int state;

  ZwpTabletToolV1ButtonEvent(
    this.serial,
    this.button,
    this.state,
  );

  @override
  toString() {
    return "ZwpTabletToolV1ButtonEvent (serial: $serial, button: $button, state: $state)";
  }
}

typedef ZwpTabletToolV1ButtonEventHandler = void Function(
    ZwpTabletToolV1ButtonEvent);

/// frame event
///
/// Marks the end of a series of axis and/or button updates from the
/// tablet. The Wayland protocol requires axis updates to be sent
/// sequentially, however all events within a frame should be considered
/// one hardware event.
///
class ZwpTabletToolV1FrameEvent {
  /// The time of the event with millisecond granularity
  final int time;

  ZwpTabletToolV1FrameEvent(
    this.time,
  );

  @override
  toString() {
    return "ZwpTabletToolV1FrameEvent (time: $time)";
  }
}

typedef ZwpTabletToolV1FrameEventHandler = void Function(
    ZwpTabletToolV1FrameEvent);

/// a physical tablet tool
///
/// An object that represents a physical tool that has been, or is
/// currently in use with a tablet in this seat. Each wp_tablet_tool
/// object stays valid until the client destroys it; the compositor
/// reuses the wp_tablet_tool object to indicate that the object's
/// respective physical tool has come into proximity of a tablet again.
///
/// A wp_tablet_tool object's relation to a physical tool depends on the
/// tablet's ability to report serial numbers. If the tablet supports
/// this capability, then the object represents a specific physical tool
/// and can be identified even when used on multiple tablets.
///
/// A tablet tool has a number of static characteristics, e.g. tool type,
/// hardware_serial and capabilities. These capabilities are sent in an
/// event sequence after the wp_tablet_seat.tool_added event before any
/// actual events from this tool. This initial event sequence is
/// terminated by a wp_tablet_tool.done event.
///
/// Tablet tool events are grouped by wp_tablet_tool.frame events.
/// Any events received before a wp_tablet_tool.frame event should be
/// considered part of the same hardware state change.
///
class ZwpTabletToolV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletToolV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletToolV1 {name: 'zwp_tablet_tool_v1', id: '$objectId', version: '1',}";
  }

  /// set the tablet tool's surface
  ///
  /// Sets the surface of the cursor used for this tool on the given
  /// tablet. This request only takes effect if the tool is in proximity
  /// of one of the requesting client's surfaces or the surface parameter
  /// is the current pointer surface. If there was a previous surface set
  /// with this request it is replaced. If surface is NULL, the cursor
  /// image is hidden.
  ///
  /// The parameters hotspot_x and hotspot_y define the position of the
  /// pointer surface relative to the pointer location. Its top-left corner
  /// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
  /// coordinates of the pointer location, in surface-local coordinates.
  ///
  /// On surface.attach requests to the pointer surface, hotspot_x and
  /// hotspot_y are decremented by the x and y parameters passed to the
  /// request. Attach must be confirmed by wl_surface.commit as usual.
  ///
  /// The hotspot can also be updated by passing the currently set pointer
  /// surface to this request with new values for hotspot_x and hotspot_y.
  ///
  /// The current and pending input regions of the wl_surface are cleared,
  /// and wl_surface.set_input_region is ignored until the wl_surface is no
  /// longer used as the cursor. When the use as a cursor ends, the current
  /// and pending input regions become undefined, and the wl_surface is
  /// unmapped.
  ///
  /// This request gives the surface the role of a cursor. The role
  /// assigned by this request is the same as assigned by
  /// wl_pointer.set_cursor meaning the same surface can be
  /// used both as a wl_pointer cursor and a wp_tablet cursor. If the
  /// surface already has another role, it raises a protocol error.
  /// The surface may be used on multiple tablets and across multiple
  /// seats.
  ///
  /// [serial]: serial of the enter event
  /// [surface]:
  /// [hotspot_x]: surface-local x coordinate
  /// [hotspot_y]: surface-local y coordinate
  void setCursor(int serial, Surface surface, int hotspotX, int hotspotY) {
    logLn(
        "ZwpTabletToolV1::setCursor  serial: $serial surface: $surface hotspotX: $hotspotX hotspotY: $hotspotY");
    var arguments = [serial, surface, hotspotX, hotspotY];
    var argTypes = <WaylandType>[
      WaylandType.uint,
      WaylandType.object,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([hotspotX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([hotspotY]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// destroy the tool object
  ///
  /// This destroys the client's resource for this tool object.
  ///
  void destroy() {
    logLn("ZwpTabletToolV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// tool type
  ///
  /// The tool type is the high-level type of the tool and usually decides
  /// the interaction expected from this tool.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for Type
  /// - [tool_type]: the physical tool type
  void onType(ZwpTabletToolV1TypeEventHandler handler) {
    _typeHandler = handler;
  }

  ZwpTabletToolV1TypeEventHandler? _typeHandler;

  /// unique hardware serial number of the tool
  ///
  /// If the physical tool can be identified by a unique 64-bit serial
  /// number, this event notifies the client of this serial number.
  ///
  /// If multiple tablets are available in the same seat and the tool is
  /// uniquely identifiable by the serial number, that tool may move
  /// between tablets.
  ///
  /// Otherwise, if the tool has no serial number and this event is
  /// missing, the tool is tied to the tablet it first comes into
  /// proximity with. Even if the physical tool is used on multiple
  /// tablets, separate wp_tablet_tool objects will be created, one per
  /// tablet.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for HardwareSerial
  /// - [hardware_serial_hi]: the unique serial number of the tool, most significant bits
  /// - [hardware_serial_lo]: the unique serial number of the tool, least significant bits
  void onHardwareSerial(ZwpTabletToolV1HardwareSerialEventHandler handler) {
    _hardwareSerialHandler = handler;
  }

  ZwpTabletToolV1HardwareSerialEventHandler? _hardwareSerialHandler;

  /// hardware id notification in Wacom's format
  ///
  /// This event notifies the client of a hardware id available on this tool.
  ///
  /// The hardware id is a device-specific 64-bit id that provides extra
  /// information about the tool in use, beyond the wl_tool.type
  /// enumeration. The format of the id is specific to tablets made by
  /// Wacom Inc. For example, the hardware id of a Wacom Grip
  /// Pen (a stylus) is 0x802.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for HardwareIdWacom
  /// - [hardware_id_hi]: the hardware id, most significant bits
  /// - [hardware_id_lo]: the hardware id, least significant bits
  void onHardwareIdWacom(ZwpTabletToolV1HardwareIdWacomEventHandler handler) {
    _hardwareIdWacomHandler = handler;
  }

  ZwpTabletToolV1HardwareIdWacomEventHandler? _hardwareIdWacomHandler;

  /// tool capability notification
  ///
  /// This event notifies the client of any capabilities of this tool,
  /// beyond the main set of x/y axes and tip up/down detection.
  ///
  /// One event is sent for each extra capability available on this tool.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for Capability
  /// - [capability]: the capability
  void onCapability(ZwpTabletToolV1CapabilityEventHandler handler) {
    _capabilityHandler = handler;
  }

  ZwpTabletToolV1CapabilityEventHandler? _capabilityHandler;

  /// tool description events sequence complete
  ///
  /// This event signals the end of the initial burst of descriptive
  /// events. A client may consider the static description of the tool to
  /// be complete and finalize initialization of the tool.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletToolV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletToolV1DoneEventHandler? _doneHandler;

  /// tool removed
  ///
  /// This event is sent when the tool is removed from the system and will
  /// send no further events. Should the physical tool come back into
  /// proximity later, a new wp_tablet_tool object will be created.
  ///
  /// It is compositor-dependent when a tool is removed. A compositor may
  /// remove a tool on proximity out, tablet removal or any other reason.
  /// A compositor may also keep a tool alive until shutdown.
  ///
  /// If the tool is currently in proximity, a proximity_out event will be
  /// sent before the removed event. See wp_tablet_tool.proximity_out for
  /// the handling of any buttons logically down.
  ///
  /// When this event is received, the client must wp_tablet_tool.destroy
  /// the object.
  ///
  /// Event handler for Removed
  void onRemoved(ZwpTabletToolV1RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ZwpTabletToolV1RemovedEventHandler? _removedHandler;

  /// proximity in event
  ///
  /// Notification that this tool is focused on a certain surface.
  ///
  /// This event can be received when the tool has moved from one surface to
  /// another, or when the tool has come back into proximity above the
  /// surface.
  ///
  /// If any button is logically down when the tool comes into proximity,
  /// the respective button event is sent after the proximity_in event but
  /// within the same frame as the proximity_in event.
  ///
  /// Event handler for ProximityIn
  /// - [serial]:
  /// - [tablet]: The tablet the tool is in proximity of
  /// - [surface]: The current surface the tablet tool is over
  void onProximityIn(ZwpTabletToolV1ProximityInEventHandler handler) {
    _proximityInHandler = handler;
  }

  ZwpTabletToolV1ProximityInEventHandler? _proximityInHandler;

  /// proximity out event
  ///
  /// Notification that this tool has either left proximity, or is no
  /// longer focused on a certain surface.
  ///
  /// When the tablet tool leaves proximity of the tablet, button release
  /// events are sent for each button that was held down at the time of
  /// leaving proximity. These events are sent before the proximity_out
  /// event but within the same wp_tablet.frame.
  ///
  /// If the tool stays within proximity of the tablet, but the focus
  /// changes from one surface to another, a button release event may not
  /// be sent until the button is actually released or the tool leaves the
  /// proximity of the tablet.
  ///
  /// Event handler for ProximityOut
  void onProximityOut(ZwpTabletToolV1ProximityOutEventHandler handler) {
    _proximityOutHandler = handler;
  }

  ZwpTabletToolV1ProximityOutEventHandler? _proximityOutHandler;

  /// tablet tool is making contact
  ///
  /// Sent whenever the tablet tool comes in contact with the surface of the
  /// tablet.
  ///
  /// If the tool is already in contact with the tablet when entering the
  /// input region, the client owning said region will receive a
  /// wp_tablet.proximity_in event, followed by a wp_tablet.down
  /// event and a wp_tablet.frame event.
  ///
  /// Note that this event describes logical contact, not physical
  /// contact. On some devices, a compositor may not consider a tool in
  /// logical contact until a minimum physical pressure threshold is
  /// exceeded.
  ///
  /// Event handler for Down
  /// - [serial]:
  void onDown(ZwpTabletToolV1DownEventHandler handler) {
    _downHandler = handler;
  }

  ZwpTabletToolV1DownEventHandler? _downHandler;

  /// tablet tool is no longer making contact
  ///
  /// Sent whenever the tablet tool stops making contact with the surface of
  /// the tablet, or when the tablet tool moves out of the input region
  /// and the compositor grab (if any) is dismissed.
  ///
  /// If the tablet tool moves out of the input region while in contact
  /// with the surface of the tablet and the compositor does not have an
  /// ongoing grab on the surface, the client owning said region will
  /// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
  /// event and a wp_tablet.frame event. If the compositor has an ongoing
  /// grab on this device, this event sequence is sent whenever the grab
  /// is dismissed in the future.
  ///
  /// Note that this event describes logical contact, not physical
  /// contact. On some devices, a compositor may not consider a tool out
  /// of logical contact until physical pressure falls below a specific
  /// threshold.
  ///
  /// Event handler for Up
  void onUp(ZwpTabletToolV1UpEventHandler handler) {
    _upHandler = handler;
  }

  ZwpTabletToolV1UpEventHandler? _upHandler;

  /// motion event
  ///
  /// Sent whenever a tablet tool moves.
  ///
  /// Event handler for Motion
  /// - [x]: surface-local x coordinate
  /// - [y]: surface-local y coordinate
  void onMotion(ZwpTabletToolV1MotionEventHandler handler) {
    _motionHandler = handler;
  }

  ZwpTabletToolV1MotionEventHandler? _motionHandler;

  /// pressure change event
  ///
  /// Sent whenever the pressure axis on a tool changes. The value of this
  /// event is normalized to a value between 0 and 65535.
  ///
  /// Note that pressure may be nonzero even when a tool is not in logical
  /// contact. See the down and up events for more details.
  ///
  /// Event handler for Pressure
  /// - [pressure]: The current pressure value
  void onPressure(ZwpTabletToolV1PressureEventHandler handler) {
    _pressureHandler = handler;
  }

  ZwpTabletToolV1PressureEventHandler? _pressureHandler;

  /// distance change event
  ///
  /// Sent whenever the distance axis on a tool changes. The value of this
  /// event is normalized to a value between 0 and 65535.
  ///
  /// Note that distance may be nonzero even when a tool is not in logical
  /// contact. See the down and up events for more details.
  ///
  /// Event handler for Distance
  /// - [distance]: The current distance value
  void onDistance(ZwpTabletToolV1DistanceEventHandler handler) {
    _distanceHandler = handler;
  }

  ZwpTabletToolV1DistanceEventHandler? _distanceHandler;

  /// tilt change event
  ///
  /// Sent whenever one or both of the tilt axes on a tool change. Each tilt
  /// value is in 0.01 of a degree, relative to the z-axis of the tablet.
  /// The angle is positive when the top of a tool tilts along the
  /// positive x or y axis.
  ///
  /// Event handler for Tilt
  /// - [tilt_x]: The current value of the X tilt axis
  /// - [tilt_y]: The current value of the Y tilt axis
  void onTilt(ZwpTabletToolV1TiltEventHandler handler) {
    _tiltHandler = handler;
  }

  ZwpTabletToolV1TiltEventHandler? _tiltHandler;

  /// z-rotation change event
  ///
  /// Sent whenever the z-rotation axis on the tool changes. The
  /// rotation value is in 0.01 of a degree clockwise from the tool's
  /// logical neutral position.
  ///
  /// Event handler for Rotation
  /// - [degrees]: The current rotation of the Z axis
  void onRotation(ZwpTabletToolV1RotationEventHandler handler) {
    _rotationHandler = handler;
  }

  ZwpTabletToolV1RotationEventHandler? _rotationHandler;

  /// Slider position change event
  ///
  /// Sent whenever the slider position on the tool changes. The
  /// value is normalized between -65535 and 65535, with 0 as the logical
  /// neutral position of the slider.
  ///
  /// The slider is available on e.g. the Wacom Airbrush tool.
  ///
  /// Event handler for Slider
  /// - [position]: The current position of slider
  void onSlider(ZwpTabletToolV1SliderEventHandler handler) {
    _sliderHandler = handler;
  }

  ZwpTabletToolV1SliderEventHandler? _sliderHandler;

  /// Wheel delta event
  ///
  /// Sent whenever the wheel on the tool emits an event. This event
  /// contains two values for the same axis change. The degrees value is
  /// in 0.01 of a degree in the same orientation as the
  /// wl_pointer.vertical_scroll axis. The clicks value is in discrete
  /// logical clicks of the mouse wheel. This value may be zero if the
  /// movement of the wheel was less than one logical click.
  ///
  /// Clients should choose either value and avoid mixing degrees and
  /// clicks. The compositor may accumulate values smaller than a logical
  /// click and emulate click events when a certain threshold is met.
  /// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
  /// have different degrees values.
  ///
  /// Event handler for Wheel
  /// - [degrees]: The wheel delta in 0.01 of a degree
  /// - [clicks]: The wheel delta in discrete clicks
  void onWheel(ZwpTabletToolV1WheelEventHandler handler) {
    _wheelHandler = handler;
  }

  ZwpTabletToolV1WheelEventHandler? _wheelHandler;

  /// button event
  ///
  /// Sent whenever a button on the tool is pressed or released.
  ///
  /// If a button is held down when the tool moves in or out of proximity,
  /// button events are generated by the compositor. See
  /// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
  /// details.
  ///
  /// Event handler for Button
  /// - [serial]:
  /// - [button]: The button whose state has changed
  /// - [state]: Whether the button was pressed or released
  void onButton(ZwpTabletToolV1ButtonEventHandler handler) {
    _buttonHandler = handler;
  }

  ZwpTabletToolV1ButtonEventHandler? _buttonHandler;

  /// frame event
  ///
  /// Marks the end of a series of axis and/or button updates from the
  /// tablet. The Wayland protocol requires axis updates to be sent
  /// sequentially, however all events within a frame should be considered
  /// one hardware event.
  ///
  /// Event handler for Frame
  /// - [time]: The time of the event with millisecond granularity
  void onFrame(ZwpTabletToolV1FrameEventHandler handler) {
    _frameHandler = handler;
  }

  ZwpTabletToolV1FrameEventHandler? _frameHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletToolV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_typeHandler != null) {
          var offset = 0;
          final toolType =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1TypeEvent(
            toolType,
          );
          _typeHandler!(event);
        }
        break;
      case 1:
        if (_hardwareSerialHandler != null) {
          var offset = 0;
          final hardwareSerialHi =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final hardwareSerialLo =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1HardwareSerialEvent(
            hardwareSerialHi,
            hardwareSerialLo,
          );
          _hardwareSerialHandler!(event);
        }
        break;
      case 2:
        if (_hardwareIdWacomHandler != null) {
          var offset = 0;
          final hardwareIdHi =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final hardwareIdLo =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1HardwareIdWacomEvent(
            hardwareIdHi,
            hardwareIdLo,
          );
          _hardwareIdWacomHandler!(event);
        }
        break;
      case 3:
        if (_capabilityHandler != null) {
          var offset = 0;
          final capability =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1CapabilityEvent(
            capability,
          );
          _capabilityHandler!(event);
        }
        break;
      case 4:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletToolV1DoneEvent());
        }
        break;
      case 5:
        if (_removedHandler != null) {
          _removedHandler!(ZwpTabletToolV1RemovedEvent());
        }
        break;
      case 6:
        if (_proximityInHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final tablet = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletToolV1ProximityInEvent(
            serial,
            tablet,
            surface,
          );
          _proximityInHandler!(event);
        }
        break;
      case 7:
        if (_proximityOutHandler != null) {
          _proximityOutHandler!(ZwpTabletToolV1ProximityOutEvent());
        }
        break;
      case 8:
        if (_downHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1DownEvent(
            serial,
          );
          _downHandler!(event);
        }
        break;
      case 9:
        if (_upHandler != null) {
          _upHandler!(ZwpTabletToolV1UpEvent());
        }
        break;
      case 10:
        if (_motionHandler != null) {
          var offset = 0;
          final x = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          final y = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          var event = ZwpTabletToolV1MotionEvent(
            x,
            y,
          );
          _motionHandler!(event);
        }
        break;
      case 11:
        if (_pressureHandler != null) {
          var offset = 0;
          final pressure =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1PressureEvent(
            pressure,
          );
          _pressureHandler!(event);
        }
        break;
      case 12:
        if (_distanceHandler != null) {
          var offset = 0;
          final distance =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1DistanceEvent(
            distance,
          );
          _distanceHandler!(event);
        }
        break;
      case 13:
        if (_tiltHandler != null) {
          var offset = 0;
          final tiltX =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final tiltY =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1TiltEvent(
            tiltX,
            tiltY,
          );
          _tiltHandler!(event);
        }
        break;
      case 14:
        if (_rotationHandler != null) {
          var offset = 0;
          final degrees =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1RotationEvent(
            degrees,
          );
          _rotationHandler!(event);
        }
        break;
      case 15:
        if (_sliderHandler != null) {
          var offset = 0;
          final position =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1SliderEvent(
            position,
          );
          _sliderHandler!(event);
        }
        break;
      case 16:
        if (_wheelHandler != null) {
          var offset = 0;
          final degrees =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final clicks =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1WheelEvent(
            degrees,
            clicks,
          );
          _wheelHandler!(event);
        }
        break;
      case 17:
        if (_buttonHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final button =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1ButtonEvent(
            serial,
            button,
            state,
          );
          _buttonHandler!(event);
        }
        break;
      case 18:
        if (_frameHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV1FrameEvent(
            time,
          );
          _frameHandler!(event);
        }
        break;
    }
  }
}

/// a physical tool type
///
/// Describes the physical type of a tool. The physical type of a tool
/// generally defines its base usage.
///
/// The mouse tool represents a mouse-shaped tool that is not a relative
/// device but bound to the tablet's surface, providing absolute
/// coordinates.
///
/// The lens tool is a mouse-shaped tool with an attached lens to
/// provide precision focus.
///

enum ZwpTabletToolV1Type {
  /// Pen
  pen("pen", 0x140),

  /// Eraser
  eraser("eraser", 0x141),

  /// Brush
  brush("brush", 0x142),

  /// Pencil
  pencil("pencil", 0x143),

  /// Airbrush
  airbrush("airbrush", 0x144),

  /// Finger
  finger("finger", 0x145),

  /// Mouse
  mouse("mouse", 0x146),

  /// Lens
  lens("lens", 0x147);

  const ZwpTabletToolV1Type(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV1Type {name: $enumName, value: $enumValue}";
  }
}

/// capability flags for a tool
///
/// Describes extra capabilities on a tablet.
///
/// Any tool must provide x and y values, extra axes are
/// device-specific.
///

enum ZwpTabletToolV1Capability {
  /// Tilt axes
  tilt("tilt", 1),

  /// Pressure axis
  pressure("pressure", 2),

  /// Distance axis
  distance("distance", 3),

  /// Z-rotation axis
  rotation("rotation", 4),

  /// Slider axis
  slider("slider", 5),

  /// Wheel axis
  wheel("wheel", 6);

  const ZwpTabletToolV1Capability(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV1Capability {name: $enumName, value: $enumValue}";
  }
}

/// physical button state
///
/// Describes the physical state of a button that produced the button event.
///

enum ZwpTabletToolV1ButtonState {
  /// button is not pressed
  released("released", 0),

  /// button is pressed
  pressed("pressed", 1);

  const ZwpTabletToolV1ButtonState(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV1ButtonState {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ZwpTabletToolV1Error {
  /// given wl_surface has another role
  role("role", 0);

  const ZwpTabletToolV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV1Error {name: $enumName, value: $enumValue}";
  }
}

/// tablet device name
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV1NameEvent {
  /// the device name
  final String name;

  ZwpTabletV1NameEvent(
    this.name,
  );

  @override
  toString() {
    return "ZwpTabletV1NameEvent (name: $name)";
  }
}

typedef ZwpTabletV1NameEventHandler = void Function(ZwpTabletV1NameEvent);

/// tablet device USB vendor/product id
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV1IdEvent {
  /// USB vendor id
  final int vid;

  /// USB product id
  final int pid;

  ZwpTabletV1IdEvent(
    this.vid,
    this.pid,
  );

  @override
  toString() {
    return "ZwpTabletV1IdEvent (vid: $vid, pid: $pid)";
  }
}

typedef ZwpTabletV1IdEventHandler = void Function(ZwpTabletV1IdEvent);

/// path to the device
///
/// A system-specific device path that indicates which device is behind
/// this wp_tablet. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
///
/// A device may have more than one device path. If so, multiple
/// wp_tablet.path events are sent. A device may be emulated and not
/// have a device path, and in that case this event will not be sent.
///
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV1PathEvent {
  /// path to local device
  final String path;

  ZwpTabletV1PathEvent(
    this.path,
  );

  @override
  toString() {
    return "ZwpTabletV1PathEvent (path: $path)";
  }
}

typedef ZwpTabletV1PathEventHandler = void Function(ZwpTabletV1PathEvent);

/// tablet description events sequence complete
///
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet.
///
class ZwpTabletV1DoneEvent {
  ZwpTabletV1DoneEvent();

  @override
  toString() {
    return "ZwpTabletV1DoneEvent ()";
  }
}

typedef ZwpTabletV1DoneEventHandler = void Function(ZwpTabletV1DoneEvent);

/// tablet removed event
///
/// Sent when the tablet has been removed from the system. When a tablet
/// is removed, some tools may be removed.
///
/// When this event is received, the client must wp_tablet.destroy
/// the object.
///
class ZwpTabletV1RemovedEvent {
  ZwpTabletV1RemovedEvent();

  @override
  toString() {
    return "ZwpTabletV1RemovedEvent ()";
  }
}

typedef ZwpTabletV1RemovedEventHandler = void Function(ZwpTabletV1RemovedEvent);

/// graphics tablet device
///
/// The wp_tablet interface represents one graphics tablet device. The
/// tablet interface itself does not generate events; all events are
/// generated by wp_tablet_tool objects when in proximity above a tablet.
///
/// A tablet has a number of static characteristics, e.g. device name and
/// pid/vid. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.tablet_added event. This initial event sequence is
/// terminated by a wp_tablet.done event.
///
class ZwpTabletV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletV1 {name: 'zwp_tablet_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the tablet object
  ///
  /// This destroys the client's resource for this tablet object.
  ///
  void destroy() {
    logLn("ZwpTabletV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// tablet device name
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Name
  /// - [name]: the device name
  void onName(ZwpTabletV1NameEventHandler handler) {
    _nameHandler = handler;
  }

  ZwpTabletV1NameEventHandler? _nameHandler;

  /// tablet device USB vendor/product id
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Id
  /// - [vid]: USB vendor id
  /// - [pid]: USB product id
  void onId(ZwpTabletV1IdEventHandler handler) {
    _idHandler = handler;
  }

  ZwpTabletV1IdEventHandler? _idHandler;

  /// path to the device
  ///
  /// A system-specific device path that indicates which device is behind
  /// this wp_tablet. This information may be used to gather additional
  /// information about the device, e.g. through libwacom.
  ///
  /// A device may have more than one device path. If so, multiple
  /// wp_tablet.path events are sent. A device may be emulated and not
  /// have a device path, and in that case this event will not be sent.
  ///
  /// The format of the path is unspecified, it may be a device node, a
  /// sysfs path, or some other identifier. It is up to the client to
  /// identify the string provided.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Path
  /// - [path]: path to local device
  void onPath(ZwpTabletV1PathEventHandler handler) {
    _pathHandler = handler;
  }

  ZwpTabletV1PathEventHandler? _pathHandler;

  /// tablet description events sequence complete
  ///
  /// This event is sent immediately to signal the end of the initial
  /// burst of descriptive events. A client may consider the static
  /// description of the tablet to be complete and finalize initialization
  /// of the tablet.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletV1DoneEventHandler? _doneHandler;

  /// tablet removed event
  ///
  /// Sent when the tablet has been removed from the system. When a tablet
  /// is removed, some tools may be removed.
  ///
  /// When this event is received, the client must wp_tablet.destroy
  /// the object.
  ///
  /// Event handler for Removed
  void onRemoved(ZwpTabletV1RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ZwpTabletV1RemovedEventHandler? _removedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_nameHandler != null) {
          var offset = 0;
          final nameLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final name =
              utf8.decode(data.sublist(offset, offset + nameLength - 1));
          offset += nameLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletV1NameEvent(
            name,
          );
          _nameHandler!(event);
        }
        break;
      case 1:
        if (_idHandler != null) {
          var offset = 0;
          final vid =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final pid =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletV1IdEvent(
            vid,
            pid,
          );
          _idHandler!(event);
        }
        break;
      case 2:
        if (_pathHandler != null) {
          var offset = 0;
          final pathLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final path =
              utf8.decode(data.sublist(offset, offset + pathLength - 1));
          offset += pathLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletV1PathEvent(
            path,
          );
          _pathHandler!(event);
        }
        break;
      case 3:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletV1DoneEvent());
        }
        break;
      case 4:
        if (_removedHandler != null) {
          _removedHandler!(ZwpTabletV1RemovedEvent());
        }
        break;
    }
  }
}
