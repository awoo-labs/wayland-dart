// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/tablet/tablet-unstable-v2.xml
//
// tablet_unstable_v2 Protocol Copyright:
///
/// Copyright 2014 © Stephen "Lyude" Chandler Paul
/// Copyright 2015-2016 © Red Hat, Inc.
///
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files
/// (the "Software"), to deal in the Software without restriction,
/// including without limitation the rights to use, copy, modify, merge,
/// publish, distribute, sublicense, and/or sell copies of the Software,
/// and to permit persons to whom the Software is furnished to do so,
/// subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the
/// next paragraph) shall be included in all copies or substantial
/// portions of the Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
/// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
/// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
/// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
/// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
/// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
/// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// controller object for graphic tablet devices
///
/// An object that provides access to the graphics tablets available on this
/// system. All tablets are associated with a seat, to get access to the
/// actual tablets, use wp_tablet_manager.get_tablet_seat.
///
class ZwpTabletManagerV2 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZwpTabletManagerV2(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletManagerV2 {name: 'zwp_tablet_manager_v2', id: '$objectId', version: '1',}";
  }

  /// get the tablet seat
  ///
  /// Get the wp_tablet_seat object for the given seat. This object
  /// provides access to all graphics tablets in this seat.
  ///
  /// [tablet_seat]:
  /// [seat]: The wl_seat object to retrieve the tablets for
  Result<ZwpTabletSeatV2, Object> getTabletSeat(Seat seat) {
    var tabletSeat = ZwpTabletSeatV2(innerContext);
    logLn(
        "ZwpTabletManagerV2::getTabletSeat  tabletSeat: $tabletSeat seat: $seat");
    var arguments = [tabletSeat, seat];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([tabletSeat.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletManagerV2::getTabletSeat: $e");
      return Failure(e);
    }
    return Success(tabletSeat);
  }

  /// release the memory for the tablet manager object
  ///
  /// Destroy the wp_tablet_manager object. Objects created from this
  /// object are unaffected and should be destroyed separately.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletManagerV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletManagerV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// new device notification
///
/// This event is sent whenever a new tablet becomes available on this
/// seat. This event only provides the object id of the tablet, any
/// static information about the tablet (device name, vid/pid, etc.) is
/// sent through the wp_tablet interface.
///
class ZwpTabletSeatV2TabletAddedEvent {
  /// the newly added graphics tablet
  final int id;

  ZwpTabletSeatV2TabletAddedEvent(
    this.id,
  );

  @override
  toString() {
    return "ZwpTabletSeatV2TabletAddedEvent (id: $id)";
  }
}

typedef ZwpTabletSeatV2TabletAddedEventHandler = void Function(
    ZwpTabletSeatV2TabletAddedEvent);

/// a new tool has been used with a tablet
///
/// This event is sent whenever a tool that has not previously been used
/// with a tablet comes into use. This event only provides the object id
/// of the tool; any static information about the tool (capabilities,
/// type, etc.) is sent through the wp_tablet_tool interface.
///
class ZwpTabletSeatV2ToolAddedEvent {
  /// the newly added tablet tool
  final int id;

  ZwpTabletSeatV2ToolAddedEvent(
    this.id,
  );

  @override
  toString() {
    return "ZwpTabletSeatV2ToolAddedEvent (id: $id)";
  }
}

typedef ZwpTabletSeatV2ToolAddedEventHandler = void Function(
    ZwpTabletSeatV2ToolAddedEvent);

/// new pad notification
///
/// This event is sent whenever a new pad is known to the system. Typically,
/// pads are physically attached to tablets and a pad_added event is
/// sent immediately after the wp_tablet_seat.tablet_added.
/// However, some standalone pad devices logically attach to tablets at
/// runtime, and the client must wait for wp_tablet_pad.enter to know
/// the tablet a pad is attached to.
///
/// This event only provides the object id of the pad. All further
/// features (buttons, strips, rings) are sent through the wp_tablet_pad
/// interface.
///
class ZwpTabletSeatV2PadAddedEvent {
  /// the newly added pad
  final int id;

  ZwpTabletSeatV2PadAddedEvent(
    this.id,
  );

  @override
  toString() {
    return "ZwpTabletSeatV2PadAddedEvent (id: $id)";
  }
}

typedef ZwpTabletSeatV2PadAddedEventHandler = void Function(
    ZwpTabletSeatV2PadAddedEvent);

/// controller object for graphic tablet devices of a seat
///
/// An object that provides access to the graphics tablets available on this
/// seat. After binding to this interface, the compositor sends a set of
/// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
///
class ZwpTabletSeatV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletSeatV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletSeatV2 {name: 'zwp_tablet_seat_v2', id: '$objectId', version: '1',}";
  }

  /// release the memory for the tablet seat object
  ///
  /// Destroy the wp_tablet_seat object. Objects created from this
  /// object are unaffected and should be destroyed separately.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletSeatV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletSeatV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// new device notification
  ///
  /// This event is sent whenever a new tablet becomes available on this
  /// seat. This event only provides the object id of the tablet, any
  /// static information about the tablet (device name, vid/pid, etc.) is
  /// sent through the wp_tablet interface.
  ///
  /// Event handler for TabletAdded
  /// - [id]: the newly added graphics tablet
  void onTabletAdded(ZwpTabletSeatV2TabletAddedEventHandler handler) {
    _tabletAddedHandler = handler;
  }

  ZwpTabletSeatV2TabletAddedEventHandler? _tabletAddedHandler;

  /// a new tool has been used with a tablet
  ///
  /// This event is sent whenever a tool that has not previously been used
  /// with a tablet comes into use. This event only provides the object id
  /// of the tool; any static information about the tool (capabilities,
  /// type, etc.) is sent through the wp_tablet_tool interface.
  ///
  /// Event handler for ToolAdded
  /// - [id]: the newly added tablet tool
  void onToolAdded(ZwpTabletSeatV2ToolAddedEventHandler handler) {
    _toolAddedHandler = handler;
  }

  ZwpTabletSeatV2ToolAddedEventHandler? _toolAddedHandler;

  /// new pad notification
  ///
  /// This event is sent whenever a new pad is known to the system. Typically,
  /// pads are physically attached to tablets and a pad_added event is
  /// sent immediately after the wp_tablet_seat.tablet_added.
  /// However, some standalone pad devices logically attach to tablets at
  /// runtime, and the client must wait for wp_tablet_pad.enter to know
  /// the tablet a pad is attached to.
  ///
  /// This event only provides the object id of the pad. All further
  /// features (buttons, strips, rings) are sent through the wp_tablet_pad
  /// interface.
  ///
  /// Event handler for PadAdded
  /// - [id]: the newly added pad
  void onPadAdded(ZwpTabletSeatV2PadAddedEventHandler handler) {
    _padAddedHandler = handler;
  }

  ZwpTabletSeatV2PadAddedEventHandler? _padAddedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletSeatV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_tabletAddedHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletSeatV2TabletAddedEvent(
            id,
          );
          _tabletAddedHandler!(event);
        }
        break;
      case 1:
        if (_toolAddedHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletSeatV2ToolAddedEvent(
            id,
          );
          _toolAddedHandler!(event);
        }
        break;
      case 2:
        if (_padAddedHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletSeatV2PadAddedEvent(
            id,
          );
          _padAddedHandler!(event);
        }
        break;
    }
  }
}

/// tool type
///
/// The tool type is the high-level type of the tool and usually decides
/// the interaction expected from this tool.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV2TypeEvent {
  /// the physical tool type
  final int toolType;

  ZwpTabletToolV2TypeEvent(
    this.toolType,
  );

  @override
  toString() {
    return "ZwpTabletToolV2TypeEvent (toolType: $toolType)";
  }
}

typedef ZwpTabletToolV2TypeEventHandler = void Function(
    ZwpTabletToolV2TypeEvent);

/// unique hardware serial number of the tool
///
/// If the physical tool can be identified by a unique 64-bit serial
/// number, this event notifies the client of this serial number.
///
/// If multiple tablets are available in the same seat and the tool is
/// uniquely identifiable by the serial number, that tool may move
/// between tablets.
///
/// Otherwise, if the tool has no serial number and this event is
/// missing, the tool is tied to the tablet it first comes into
/// proximity with. Even if the physical tool is used on multiple
/// tablets, separate wp_tablet_tool objects will be created, one per
/// tablet.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV2HardwareSerialEvent {
  /// the unique serial number of the tool, most significant bits
  final int hardwareSerialHi;

  /// the unique serial number of the tool, least significant bits
  final int hardwareSerialLo;

  ZwpTabletToolV2HardwareSerialEvent(
    this.hardwareSerialHi,
    this.hardwareSerialLo,
  );

  @override
  toString() {
    return "ZwpTabletToolV2HardwareSerialEvent (hardwareSerialHi: $hardwareSerialHi, hardwareSerialLo: $hardwareSerialLo)";
  }
}

typedef ZwpTabletToolV2HardwareSerialEventHandler = void Function(
    ZwpTabletToolV2HardwareSerialEvent);

/// hardware id notification in Wacom's format
///
/// This event notifies the client of a hardware id available on this tool.
///
/// The hardware id is a device-specific 64-bit id that provides extra
/// information about the tool in use, beyond the wl_tool.type
/// enumeration. The format of the id is specific to tablets made by
/// Wacom Inc. For example, the hardware id of a Wacom Grip
/// Pen (a stylus) is 0x802.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV2HardwareIdWacomEvent {
  /// the hardware id, most significant bits
  final int hardwareIdHi;

  /// the hardware id, least significant bits
  final int hardwareIdLo;

  ZwpTabletToolV2HardwareIdWacomEvent(
    this.hardwareIdHi,
    this.hardwareIdLo,
  );

  @override
  toString() {
    return "ZwpTabletToolV2HardwareIdWacomEvent (hardwareIdHi: $hardwareIdHi, hardwareIdLo: $hardwareIdLo)";
  }
}

typedef ZwpTabletToolV2HardwareIdWacomEventHandler = void Function(
    ZwpTabletToolV2HardwareIdWacomEvent);

/// tool capability notification
///
/// This event notifies the client of any capabilities of this tool,
/// beyond the main set of x/y axes and tip up/down detection.
///
/// One event is sent for each extra capability available on this tool.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_tool.done event.
///
class ZwpTabletToolV2CapabilityEvent {
  /// the capability
  final int capability;

  ZwpTabletToolV2CapabilityEvent(
    this.capability,
  );

  @override
  toString() {
    return "ZwpTabletToolV2CapabilityEvent (capability: $capability)";
  }
}

typedef ZwpTabletToolV2CapabilityEventHandler = void Function(
    ZwpTabletToolV2CapabilityEvent);

/// tool description events sequence complete
///
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the tool to
/// be complete and finalize initialization of the tool.
///
class ZwpTabletToolV2DoneEvent {
  ZwpTabletToolV2DoneEvent();

  @override
  toString() {
    return "ZwpTabletToolV2DoneEvent ()";
  }
}

typedef ZwpTabletToolV2DoneEventHandler = void Function(
    ZwpTabletToolV2DoneEvent);

/// tool removed
///
/// This event is sent when the tool is removed from the system and will
/// send no further events. Should the physical tool come back into
/// proximity later, a new wp_tablet_tool object will be created.
///
/// It is compositor-dependent when a tool is removed. A compositor may
/// remove a tool on proximity out, tablet removal or any other reason.
/// A compositor may also keep a tool alive until shutdown.
///
/// If the tool is currently in proximity, a proximity_out event will be
/// sent before the removed event. See wp_tablet_tool.proximity_out for
/// the handling of any buttons logically down.
///
/// When this event is received, the client must wp_tablet_tool.destroy
/// the object.
///
class ZwpTabletToolV2RemovedEvent {
  ZwpTabletToolV2RemovedEvent();

  @override
  toString() {
    return "ZwpTabletToolV2RemovedEvent ()";
  }
}

typedef ZwpTabletToolV2RemovedEventHandler = void Function(
    ZwpTabletToolV2RemovedEvent);

/// proximity in event
///
/// Notification that this tool is focused on a certain surface.
///
/// This event can be received when the tool has moved from one surface to
/// another, or when the tool has come back into proximity above the
/// surface.
///
/// If any button is logically down when the tool comes into proximity,
/// the respective button event is sent after the proximity_in event but
/// within the same frame as the proximity_in event.
///
class ZwpTabletToolV2ProximityInEvent {
  ///
  final int serial;

  /// The tablet the tool is in proximity of
  final int tablet;

  /// The current surface the tablet tool is over
  final int surface;

  ZwpTabletToolV2ProximityInEvent(
    this.serial,
    this.tablet,
    this.surface,
  );

  @override
  toString() {
    return "ZwpTabletToolV2ProximityInEvent (serial: $serial, tablet: $tablet, surface: $surface)";
  }
}

typedef ZwpTabletToolV2ProximityInEventHandler = void Function(
    ZwpTabletToolV2ProximityInEvent);

/// proximity out event
///
/// Notification that this tool has either left proximity, or is no
/// longer focused on a certain surface.
///
/// When the tablet tool leaves proximity of the tablet, button release
/// events are sent for each button that was held down at the time of
/// leaving proximity. These events are sent before the proximity_out
/// event but within the same wp_tablet.frame.
///
/// If the tool stays within proximity of the tablet, but the focus
/// changes from one surface to another, a button release event may not
/// be sent until the button is actually released or the tool leaves the
/// proximity of the tablet.
///
class ZwpTabletToolV2ProximityOutEvent {
  ZwpTabletToolV2ProximityOutEvent();

  @override
  toString() {
    return "ZwpTabletToolV2ProximityOutEvent ()";
  }
}

typedef ZwpTabletToolV2ProximityOutEventHandler = void Function(
    ZwpTabletToolV2ProximityOutEvent);

/// tablet tool is making contact
///
/// Sent whenever the tablet tool comes in contact with the surface of the
/// tablet.
///
/// If the tool is already in contact with the tablet when entering the
/// input region, the client owning said region will receive a
/// wp_tablet.proximity_in event, followed by a wp_tablet.down
/// event and a wp_tablet.frame event.
///
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool in
/// logical contact until a minimum physical pressure threshold is
/// exceeded.
///
class ZwpTabletToolV2DownEvent {
  ///
  final int serial;

  ZwpTabletToolV2DownEvent(
    this.serial,
  );

  @override
  toString() {
    return "ZwpTabletToolV2DownEvent (serial: $serial)";
  }
}

typedef ZwpTabletToolV2DownEventHandler = void Function(
    ZwpTabletToolV2DownEvent);

/// tablet tool is no longer making contact
///
/// Sent whenever the tablet tool stops making contact with the surface of
/// the tablet, or when the tablet tool moves out of the input region
/// and the compositor grab (if any) is dismissed.
///
/// If the tablet tool moves out of the input region while in contact
/// with the surface of the tablet and the compositor does not have an
/// ongoing grab on the surface, the client owning said region will
/// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
/// event and a wp_tablet.frame event. If the compositor has an ongoing
/// grab on this device, this event sequence is sent whenever the grab
/// is dismissed in the future.
///
/// Note that this event describes logical contact, not physical
/// contact. On some devices, a compositor may not consider a tool out
/// of logical contact until physical pressure falls below a specific
/// threshold.
///
class ZwpTabletToolV2UpEvent {
  ZwpTabletToolV2UpEvent();

  @override
  toString() {
    return "ZwpTabletToolV2UpEvent ()";
  }
}

typedef ZwpTabletToolV2UpEventHandler = void Function(ZwpTabletToolV2UpEvent);

/// motion event
///
/// Sent whenever a tablet tool moves.
///
class ZwpTabletToolV2MotionEvent {
  /// surface-local x coordinate
  final double x;

  /// surface-local y coordinate
  final double y;

  ZwpTabletToolV2MotionEvent(
    this.x,
    this.y,
  );

  @override
  toString() {
    return "ZwpTabletToolV2MotionEvent (x: $x, y: $y)";
  }
}

typedef ZwpTabletToolV2MotionEventHandler = void Function(
    ZwpTabletToolV2MotionEvent);

/// pressure change event
///
/// Sent whenever the pressure axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
///
/// Note that pressure may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
///
class ZwpTabletToolV2PressureEvent {
  /// The current pressure value
  final int pressure;

  ZwpTabletToolV2PressureEvent(
    this.pressure,
  );

  @override
  toString() {
    return "ZwpTabletToolV2PressureEvent (pressure: $pressure)";
  }
}

typedef ZwpTabletToolV2PressureEventHandler = void Function(
    ZwpTabletToolV2PressureEvent);

/// distance change event
///
/// Sent whenever the distance axis on a tool changes. The value of this
/// event is normalized to a value between 0 and 65535.
///
/// Note that distance may be nonzero even when a tool is not in logical
/// contact. See the down and up events for more details.
///
class ZwpTabletToolV2DistanceEvent {
  /// The current distance value
  final int distance;

  ZwpTabletToolV2DistanceEvent(
    this.distance,
  );

  @override
  toString() {
    return "ZwpTabletToolV2DistanceEvent (distance: $distance)";
  }
}

typedef ZwpTabletToolV2DistanceEventHandler = void Function(
    ZwpTabletToolV2DistanceEvent);

/// tilt change event
///
/// Sent whenever one or both of the tilt axes on a tool change. Each tilt
/// value is in degrees, relative to the z-axis of the tablet.
/// The angle is positive when the top of a tool tilts along the
/// positive x or y axis.
///
class ZwpTabletToolV2TiltEvent {
  /// The current value of the X tilt axis
  final double tiltX;

  /// The current value of the Y tilt axis
  final double tiltY;

  ZwpTabletToolV2TiltEvent(
    this.tiltX,
    this.tiltY,
  );

  @override
  toString() {
    return "ZwpTabletToolV2TiltEvent (tiltX: $tiltX, tiltY: $tiltY)";
  }
}

typedef ZwpTabletToolV2TiltEventHandler = void Function(
    ZwpTabletToolV2TiltEvent);

/// z-rotation change event
///
/// Sent whenever the z-rotation axis on the tool changes. The
/// rotation value is in degrees clockwise from the tool's
/// logical neutral position.
///
class ZwpTabletToolV2RotationEvent {
  /// The current rotation of the Z axis
  final double degrees;

  ZwpTabletToolV2RotationEvent(
    this.degrees,
  );

  @override
  toString() {
    return "ZwpTabletToolV2RotationEvent (degrees: $degrees)";
  }
}

typedef ZwpTabletToolV2RotationEventHandler = void Function(
    ZwpTabletToolV2RotationEvent);

/// Slider position change event
///
/// Sent whenever the slider position on the tool changes. The
/// value is normalized between -65535 and 65535, with 0 as the logical
/// neutral position of the slider.
///
/// The slider is available on e.g. the Wacom Airbrush tool.
///
class ZwpTabletToolV2SliderEvent {
  /// The current position of slider
  final int position;

  ZwpTabletToolV2SliderEvent(
    this.position,
  );

  @override
  toString() {
    return "ZwpTabletToolV2SliderEvent (position: $position)";
  }
}

typedef ZwpTabletToolV2SliderEventHandler = void Function(
    ZwpTabletToolV2SliderEvent);

/// Wheel delta event
///
/// Sent whenever the wheel on the tool emits an event. This event
/// contains two values for the same axis change. The degrees value is
/// in the same orientation as the wl_pointer.vertical_scroll axis. The
/// clicks value is in discrete logical clicks of the mouse wheel. This
/// value may be zero if the movement of the wheel was less
/// than one logical click.
///
/// Clients should choose either value and avoid mixing degrees and
/// clicks. The compositor may accumulate values smaller than a logical
/// click and emulate click events when a certain threshold is met.
/// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
/// have different degrees values.
///
class ZwpTabletToolV2WheelEvent {
  /// The wheel delta in degrees
  final double degrees;

  /// The wheel delta in discrete clicks
  final int clicks;

  ZwpTabletToolV2WheelEvent(
    this.degrees,
    this.clicks,
  );

  @override
  toString() {
    return "ZwpTabletToolV2WheelEvent (degrees: $degrees, clicks: $clicks)";
  }
}

typedef ZwpTabletToolV2WheelEventHandler = void Function(
    ZwpTabletToolV2WheelEvent);

/// button event
///
/// Sent whenever a button on the tool is pressed or released.
///
/// If a button is held down when the tool moves in or out of proximity,
/// button events are generated by the compositor. See
/// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
/// details.
///
class ZwpTabletToolV2ButtonEvent {
  ///
  final int serial;

  /// The button whose state has changed
  final int button;

  /// Whether the button was pressed or released
  final int state;

  ZwpTabletToolV2ButtonEvent(
    this.serial,
    this.button,
    this.state,
  );

  @override
  toString() {
    return "ZwpTabletToolV2ButtonEvent (serial: $serial, button: $button, state: $state)";
  }
}

typedef ZwpTabletToolV2ButtonEventHandler = void Function(
    ZwpTabletToolV2ButtonEvent);

/// frame event
///
/// Marks the end of a series of axis and/or button updates from the
/// tablet. The Wayland protocol requires axis updates to be sent
/// sequentially, however all events within a frame should be considered
/// one hardware event.
///
class ZwpTabletToolV2FrameEvent {
  /// The time of the event with millisecond granularity
  final int time;

  ZwpTabletToolV2FrameEvent(
    this.time,
  );

  @override
  toString() {
    return "ZwpTabletToolV2FrameEvent (time: $time)";
  }
}

typedef ZwpTabletToolV2FrameEventHandler = void Function(
    ZwpTabletToolV2FrameEvent);

/// a physical tablet tool
///
/// An object that represents a physical tool that has been, or is
/// currently in use with a tablet in this seat. Each wp_tablet_tool
/// object stays valid until the client destroys it; the compositor
/// reuses the wp_tablet_tool object to indicate that the object's
/// respective physical tool has come into proximity of a tablet again.
///
/// A wp_tablet_tool object's relation to a physical tool depends on the
/// tablet's ability to report serial numbers. If the tablet supports
/// this capability, then the object represents a specific physical tool
/// and can be identified even when used on multiple tablets.
///
/// A tablet tool has a number of static characteristics, e.g. tool type,
/// hardware_serial and capabilities. These capabilities are sent in an
/// event sequence after the wp_tablet_seat.tool_added event before any
/// actual events from this tool. This initial event sequence is
/// terminated by a wp_tablet_tool.done event.
///
/// Tablet tool events are grouped by wp_tablet_tool.frame events.
/// Any events received before a wp_tablet_tool.frame event should be
/// considered part of the same hardware state change.
///
class ZwpTabletToolV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletToolV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletToolV2 {name: 'zwp_tablet_tool_v2', id: '$objectId', version: '1',}";
  }

  /// set the tablet tool's surface
  ///
  /// Sets the surface of the cursor used for this tool on the given
  /// tablet. This request only takes effect if the tool is in proximity
  /// of one of the requesting client's surfaces or the surface parameter
  /// is the current pointer surface. If there was a previous surface set
  /// with this request it is replaced. If surface is NULL, the cursor
  /// image is hidden.
  ///
  /// The parameters hotspot_x and hotspot_y define the position of the
  /// pointer surface relative to the pointer location. Its top-left corner
  /// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
  /// coordinates of the pointer location, in surface-local coordinates.
  ///
  /// On surface.attach requests to the pointer surface, hotspot_x and
  /// hotspot_y are decremented by the x and y parameters passed to the
  /// request. Attach must be confirmed by wl_surface.commit as usual.
  ///
  /// The hotspot can also be updated by passing the currently set pointer
  /// surface to this request with new values for hotspot_x and hotspot_y.
  ///
  /// The current and pending input regions of the wl_surface are cleared,
  /// and wl_surface.set_input_region is ignored until the wl_surface is no
  /// longer used as the cursor. When the use as a cursor ends, the current
  /// and pending input regions become undefined, and the wl_surface is
  /// unmapped.
  ///
  /// This request gives the surface the role of a wp_tablet_tool cursor. A
  /// surface may only ever be used as the cursor surface for one
  /// wp_tablet_tool. If the surface already has another role or has
  /// previously been used as cursor surface for a different tool, a
  /// protocol error is raised.
  ///
  /// [serial]: serial of the proximity_in event
  /// [surface]:
  /// [hotspot_x]: surface-local x coordinate
  /// [hotspot_y]: surface-local y coordinate
  Result<void, Object> setCursor(
      int serial, Surface surface, int hotspotX, int hotspotY) {
    logLn(
        "ZwpTabletToolV2::setCursor  serial: $serial surface: $surface hotspotX: $hotspotX hotspotY: $hotspotY");
    var arguments = [serial, surface, hotspotX, hotspotY];
    var argTypes = <WaylandType>[
      WaylandType.uint,
      WaylandType.object,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([hotspotX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([hotspotY]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletToolV2::setCursor: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy the tool object
  ///
  /// This destroys the client's resource for this tool object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletToolV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletToolV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// tool type
  ///
  /// The tool type is the high-level type of the tool and usually decides
  /// the interaction expected from this tool.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for Type
  /// - [tool_type]: the physical tool type
  void onType(ZwpTabletToolV2TypeEventHandler handler) {
    _typeHandler = handler;
  }

  ZwpTabletToolV2TypeEventHandler? _typeHandler;

  /// unique hardware serial number of the tool
  ///
  /// If the physical tool can be identified by a unique 64-bit serial
  /// number, this event notifies the client of this serial number.
  ///
  /// If multiple tablets are available in the same seat and the tool is
  /// uniquely identifiable by the serial number, that tool may move
  /// between tablets.
  ///
  /// Otherwise, if the tool has no serial number and this event is
  /// missing, the tool is tied to the tablet it first comes into
  /// proximity with. Even if the physical tool is used on multiple
  /// tablets, separate wp_tablet_tool objects will be created, one per
  /// tablet.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for HardwareSerial
  /// - [hardware_serial_hi]: the unique serial number of the tool, most significant bits
  /// - [hardware_serial_lo]: the unique serial number of the tool, least significant bits
  void onHardwareSerial(ZwpTabletToolV2HardwareSerialEventHandler handler) {
    _hardwareSerialHandler = handler;
  }

  ZwpTabletToolV2HardwareSerialEventHandler? _hardwareSerialHandler;

  /// hardware id notification in Wacom's format
  ///
  /// This event notifies the client of a hardware id available on this tool.
  ///
  /// The hardware id is a device-specific 64-bit id that provides extra
  /// information about the tool in use, beyond the wl_tool.type
  /// enumeration. The format of the id is specific to tablets made by
  /// Wacom Inc. For example, the hardware id of a Wacom Grip
  /// Pen (a stylus) is 0x802.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for HardwareIdWacom
  /// - [hardware_id_hi]: the hardware id, most significant bits
  /// - [hardware_id_lo]: the hardware id, least significant bits
  void onHardwareIdWacom(ZwpTabletToolV2HardwareIdWacomEventHandler handler) {
    _hardwareIdWacomHandler = handler;
  }

  ZwpTabletToolV2HardwareIdWacomEventHandler? _hardwareIdWacomHandler;

  /// tool capability notification
  ///
  /// This event notifies the client of any capabilities of this tool,
  /// beyond the main set of x/y axes and tip up/down detection.
  ///
  /// One event is sent for each extra capability available on this tool.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_tool.done event.
  ///
  /// Event handler for Capability
  /// - [capability]: the capability
  void onCapability(ZwpTabletToolV2CapabilityEventHandler handler) {
    _capabilityHandler = handler;
  }

  ZwpTabletToolV2CapabilityEventHandler? _capabilityHandler;

  /// tool description events sequence complete
  ///
  /// This event signals the end of the initial burst of descriptive
  /// events. A client may consider the static description of the tool to
  /// be complete and finalize initialization of the tool.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletToolV2DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletToolV2DoneEventHandler? _doneHandler;

  /// tool removed
  ///
  /// This event is sent when the tool is removed from the system and will
  /// send no further events. Should the physical tool come back into
  /// proximity later, a new wp_tablet_tool object will be created.
  ///
  /// It is compositor-dependent when a tool is removed. A compositor may
  /// remove a tool on proximity out, tablet removal or any other reason.
  /// A compositor may also keep a tool alive until shutdown.
  ///
  /// If the tool is currently in proximity, a proximity_out event will be
  /// sent before the removed event. See wp_tablet_tool.proximity_out for
  /// the handling of any buttons logically down.
  ///
  /// When this event is received, the client must wp_tablet_tool.destroy
  /// the object.
  ///
  /// Event handler for Removed
  void onRemoved(ZwpTabletToolV2RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ZwpTabletToolV2RemovedEventHandler? _removedHandler;

  /// proximity in event
  ///
  /// Notification that this tool is focused on a certain surface.
  ///
  /// This event can be received when the tool has moved from one surface to
  /// another, or when the tool has come back into proximity above the
  /// surface.
  ///
  /// If any button is logically down when the tool comes into proximity,
  /// the respective button event is sent after the proximity_in event but
  /// within the same frame as the proximity_in event.
  ///
  /// Event handler for ProximityIn
  /// - [serial]:
  /// - [tablet]: The tablet the tool is in proximity of
  /// - [surface]: The current surface the tablet tool is over
  void onProximityIn(ZwpTabletToolV2ProximityInEventHandler handler) {
    _proximityInHandler = handler;
  }

  ZwpTabletToolV2ProximityInEventHandler? _proximityInHandler;

  /// proximity out event
  ///
  /// Notification that this tool has either left proximity, or is no
  /// longer focused on a certain surface.
  ///
  /// When the tablet tool leaves proximity of the tablet, button release
  /// events are sent for each button that was held down at the time of
  /// leaving proximity. These events are sent before the proximity_out
  /// event but within the same wp_tablet.frame.
  ///
  /// If the tool stays within proximity of the tablet, but the focus
  /// changes from one surface to another, a button release event may not
  /// be sent until the button is actually released or the tool leaves the
  /// proximity of the tablet.
  ///
  /// Event handler for ProximityOut
  void onProximityOut(ZwpTabletToolV2ProximityOutEventHandler handler) {
    _proximityOutHandler = handler;
  }

  ZwpTabletToolV2ProximityOutEventHandler? _proximityOutHandler;

  /// tablet tool is making contact
  ///
  /// Sent whenever the tablet tool comes in contact with the surface of the
  /// tablet.
  ///
  /// If the tool is already in contact with the tablet when entering the
  /// input region, the client owning said region will receive a
  /// wp_tablet.proximity_in event, followed by a wp_tablet.down
  /// event and a wp_tablet.frame event.
  ///
  /// Note that this event describes logical contact, not physical
  /// contact. On some devices, a compositor may not consider a tool in
  /// logical contact until a minimum physical pressure threshold is
  /// exceeded.
  ///
  /// Event handler for Down
  /// - [serial]:
  void onDown(ZwpTabletToolV2DownEventHandler handler) {
    _downHandler = handler;
  }

  ZwpTabletToolV2DownEventHandler? _downHandler;

  /// tablet tool is no longer making contact
  ///
  /// Sent whenever the tablet tool stops making contact with the surface of
  /// the tablet, or when the tablet tool moves out of the input region
  /// and the compositor grab (if any) is dismissed.
  ///
  /// If the tablet tool moves out of the input region while in contact
  /// with the surface of the tablet and the compositor does not have an
  /// ongoing grab on the surface, the client owning said region will
  /// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
  /// event and a wp_tablet.frame event. If the compositor has an ongoing
  /// grab on this device, this event sequence is sent whenever the grab
  /// is dismissed in the future.
  ///
  /// Note that this event describes logical contact, not physical
  /// contact. On some devices, a compositor may not consider a tool out
  /// of logical contact until physical pressure falls below a specific
  /// threshold.
  ///
  /// Event handler for Up
  void onUp(ZwpTabletToolV2UpEventHandler handler) {
    _upHandler = handler;
  }

  ZwpTabletToolV2UpEventHandler? _upHandler;

  /// motion event
  ///
  /// Sent whenever a tablet tool moves.
  ///
  /// Event handler for Motion
  /// - [x]: surface-local x coordinate
  /// - [y]: surface-local y coordinate
  void onMotion(ZwpTabletToolV2MotionEventHandler handler) {
    _motionHandler = handler;
  }

  ZwpTabletToolV2MotionEventHandler? _motionHandler;

  /// pressure change event
  ///
  /// Sent whenever the pressure axis on a tool changes. The value of this
  /// event is normalized to a value between 0 and 65535.
  ///
  /// Note that pressure may be nonzero even when a tool is not in logical
  /// contact. See the down and up events for more details.
  ///
  /// Event handler for Pressure
  /// - [pressure]: The current pressure value
  void onPressure(ZwpTabletToolV2PressureEventHandler handler) {
    _pressureHandler = handler;
  }

  ZwpTabletToolV2PressureEventHandler? _pressureHandler;

  /// distance change event
  ///
  /// Sent whenever the distance axis on a tool changes. The value of this
  /// event is normalized to a value between 0 and 65535.
  ///
  /// Note that distance may be nonzero even when a tool is not in logical
  /// contact. See the down and up events for more details.
  ///
  /// Event handler for Distance
  /// - [distance]: The current distance value
  void onDistance(ZwpTabletToolV2DistanceEventHandler handler) {
    _distanceHandler = handler;
  }

  ZwpTabletToolV2DistanceEventHandler? _distanceHandler;

  /// tilt change event
  ///
  /// Sent whenever one or both of the tilt axes on a tool change. Each tilt
  /// value is in degrees, relative to the z-axis of the tablet.
  /// The angle is positive when the top of a tool tilts along the
  /// positive x or y axis.
  ///
  /// Event handler for Tilt
  /// - [tilt_x]: The current value of the X tilt axis
  /// - [tilt_y]: The current value of the Y tilt axis
  void onTilt(ZwpTabletToolV2TiltEventHandler handler) {
    _tiltHandler = handler;
  }

  ZwpTabletToolV2TiltEventHandler? _tiltHandler;

  /// z-rotation change event
  ///
  /// Sent whenever the z-rotation axis on the tool changes. The
  /// rotation value is in degrees clockwise from the tool's
  /// logical neutral position.
  ///
  /// Event handler for Rotation
  /// - [degrees]: The current rotation of the Z axis
  void onRotation(ZwpTabletToolV2RotationEventHandler handler) {
    _rotationHandler = handler;
  }

  ZwpTabletToolV2RotationEventHandler? _rotationHandler;

  /// Slider position change event
  ///
  /// Sent whenever the slider position on the tool changes. The
  /// value is normalized between -65535 and 65535, with 0 as the logical
  /// neutral position of the slider.
  ///
  /// The slider is available on e.g. the Wacom Airbrush tool.
  ///
  /// Event handler for Slider
  /// - [position]: The current position of slider
  void onSlider(ZwpTabletToolV2SliderEventHandler handler) {
    _sliderHandler = handler;
  }

  ZwpTabletToolV2SliderEventHandler? _sliderHandler;

  /// Wheel delta event
  ///
  /// Sent whenever the wheel on the tool emits an event. This event
  /// contains two values for the same axis change. The degrees value is
  /// in the same orientation as the wl_pointer.vertical_scroll axis. The
  /// clicks value is in discrete logical clicks of the mouse wheel. This
  /// value may be zero if the movement of the wheel was less
  /// than one logical click.
  ///
  /// Clients should choose either value and avoid mixing degrees and
  /// clicks. The compositor may accumulate values smaller than a logical
  /// click and emulate click events when a certain threshold is met.
  /// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
  /// have different degrees values.
  ///
  /// Event handler for Wheel
  /// - [degrees]: The wheel delta in degrees
  /// - [clicks]: The wheel delta in discrete clicks
  void onWheel(ZwpTabletToolV2WheelEventHandler handler) {
    _wheelHandler = handler;
  }

  ZwpTabletToolV2WheelEventHandler? _wheelHandler;

  /// button event
  ///
  /// Sent whenever a button on the tool is pressed or released.
  ///
  /// If a button is held down when the tool moves in or out of proximity,
  /// button events are generated by the compositor. See
  /// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
  /// details.
  ///
  /// Event handler for Button
  /// - [serial]:
  /// - [button]: The button whose state has changed
  /// - [state]: Whether the button was pressed or released
  void onButton(ZwpTabletToolV2ButtonEventHandler handler) {
    _buttonHandler = handler;
  }

  ZwpTabletToolV2ButtonEventHandler? _buttonHandler;

  /// frame event
  ///
  /// Marks the end of a series of axis and/or button updates from the
  /// tablet. The Wayland protocol requires axis updates to be sent
  /// sequentially, however all events within a frame should be considered
  /// one hardware event.
  ///
  /// Event handler for Frame
  /// - [time]: The time of the event with millisecond granularity
  void onFrame(ZwpTabletToolV2FrameEventHandler handler) {
    _frameHandler = handler;
  }

  ZwpTabletToolV2FrameEventHandler? _frameHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletToolV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_typeHandler != null) {
          var offset = 0;
          final toolType =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2TypeEvent(
            toolType,
          );
          _typeHandler!(event);
        }
        break;
      case 1:
        if (_hardwareSerialHandler != null) {
          var offset = 0;
          final hardwareSerialHi =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final hardwareSerialLo =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2HardwareSerialEvent(
            hardwareSerialHi,
            hardwareSerialLo,
          );
          _hardwareSerialHandler!(event);
        }
        break;
      case 2:
        if (_hardwareIdWacomHandler != null) {
          var offset = 0;
          final hardwareIdHi =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final hardwareIdLo =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2HardwareIdWacomEvent(
            hardwareIdHi,
            hardwareIdLo,
          );
          _hardwareIdWacomHandler!(event);
        }
        break;
      case 3:
        if (_capabilityHandler != null) {
          var offset = 0;
          final capability =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2CapabilityEvent(
            capability,
          );
          _capabilityHandler!(event);
        }
        break;
      case 4:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletToolV2DoneEvent());
        }
        break;
      case 5:
        if (_removedHandler != null) {
          _removedHandler!(ZwpTabletToolV2RemovedEvent());
        }
        break;
      case 6:
        if (_proximityInHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final tablet = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletToolV2ProximityInEvent(
            serial,
            tablet,
            surface,
          );
          _proximityInHandler!(event);
        }
        break;
      case 7:
        if (_proximityOutHandler != null) {
          _proximityOutHandler!(ZwpTabletToolV2ProximityOutEvent());
        }
        break;
      case 8:
        if (_downHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2DownEvent(
            serial,
          );
          _downHandler!(event);
        }
        break;
      case 9:
        if (_upHandler != null) {
          _upHandler!(ZwpTabletToolV2UpEvent());
        }
        break;
      case 10:
        if (_motionHandler != null) {
          var offset = 0;
          final x = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          final y = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          var event = ZwpTabletToolV2MotionEvent(
            x,
            y,
          );
          _motionHandler!(event);
        }
        break;
      case 11:
        if (_pressureHandler != null) {
          var offset = 0;
          final pressure =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2PressureEvent(
            pressure,
          );
          _pressureHandler!(event);
        }
        break;
      case 12:
        if (_distanceHandler != null) {
          var offset = 0;
          final distance =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2DistanceEvent(
            distance,
          );
          _distanceHandler!(event);
        }
        break;
      case 13:
        if (_tiltHandler != null) {
          var offset = 0;
          final tiltX = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          final tiltY = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          var event = ZwpTabletToolV2TiltEvent(
            tiltX,
            tiltY,
          );
          _tiltHandler!(event);
        }
        break;
      case 14:
        if (_rotationHandler != null) {
          var offset = 0;
          final degrees = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          var event = ZwpTabletToolV2RotationEvent(
            degrees,
          );
          _rotationHandler!(event);
        }
        break;
      case 15:
        if (_sliderHandler != null) {
          var offset = 0;
          final position =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2SliderEvent(
            position,
          );
          _sliderHandler!(event);
        }
        break;
      case 16:
        if (_wheelHandler != null) {
          var offset = 0;
          final degrees = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          final clicks =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2WheelEvent(
            degrees,
            clicks,
          );
          _wheelHandler!(event);
        }
        break;
      case 17:
        if (_buttonHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final button =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2ButtonEvent(
            serial,
            button,
            state,
          );
          _buttonHandler!(event);
        }
        break;
      case 18:
        if (_frameHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletToolV2FrameEvent(
            time,
          );
          _frameHandler!(event);
        }
        break;
    }
  }
}

/// a physical tool type
///
/// Describes the physical type of a tool. The physical type of a tool
/// generally defines its base usage.
///
/// The mouse tool represents a mouse-shaped tool that is not a relative
/// device but bound to the tablet's surface, providing absolute
/// coordinates.
///
/// The lens tool is a mouse-shaped tool with an attached lens to
/// provide precision focus.
///

enum ZwpTabletToolV2Type {
  /// Pen
  pen("pen", 0x140),

  /// Eraser
  eraser("eraser", 0x141),

  /// Brush
  brush("brush", 0x142),

  /// Pencil
  pencil("pencil", 0x143),

  /// Airbrush
  airbrush("airbrush", 0x144),

  /// Finger
  finger("finger", 0x145),

  /// Mouse
  mouse("mouse", 0x146),

  /// Lens
  lens("lens", 0x147);

  const ZwpTabletToolV2Type(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV2Type {name: $enumName, value: $enumValue}";
  }
}

/// capability flags for a tool
///
/// Describes extra capabilities on a tablet.
///
/// Any tool must provide x and y values, extra axes are
/// device-specific.
///

enum ZwpTabletToolV2Capability {
  /// Tilt axes
  tilt("tilt", 1),

  /// Pressure axis
  pressure("pressure", 2),

  /// Distance axis
  distance("distance", 3),

  /// Z-rotation axis
  rotation("rotation", 4),

  /// Slider axis
  slider("slider", 5),

  /// Wheel axis
  wheel("wheel", 6);

  const ZwpTabletToolV2Capability(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV2Capability {name: $enumName, value: $enumValue}";
  }
}

/// physical button state
///
/// Describes the physical state of a button that produced the button event.
///

enum ZwpTabletToolV2ButtonState {
  /// button is not pressed
  released("released", 0),

  /// button is pressed
  pressed("pressed", 1);

  const ZwpTabletToolV2ButtonState(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV2ButtonState {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ZwpTabletToolV2Error {
  /// given wl_surface has another role
  role("role", 0);

  const ZwpTabletToolV2Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletToolV2Error {name: $enumName, value: $enumValue}";
  }
}

/// tablet device name
///
/// A descriptive name for the tablet device.
///
/// If the device has no descriptive name, this event is not sent.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV2NameEvent {
  /// the device name
  final String name;

  ZwpTabletV2NameEvent(
    this.name,
  );

  @override
  toString() {
    return "ZwpTabletV2NameEvent (name: $name)";
  }
}

typedef ZwpTabletV2NameEventHandler = void Function(ZwpTabletV2NameEvent);

/// tablet device USB vendor/product id
///
/// The USB vendor and product IDs for the tablet device.
///
/// If the device has no USB vendor/product ID, this event is not sent.
/// This can happen for virtual devices or non-USB devices, for instance.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV2IdEvent {
  /// USB vendor id
  final int vid;

  /// USB product id
  final int pid;

  ZwpTabletV2IdEvent(
    this.vid,
    this.pid,
  );

  @override
  toString() {
    return "ZwpTabletV2IdEvent (vid: $vid, pid: $pid)";
  }
}

typedef ZwpTabletV2IdEventHandler = void Function(ZwpTabletV2IdEvent);

/// path to the device
///
/// A system-specific device path that indicates which device is behind
/// this wp_tablet. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
///
/// A device may have more than one device path. If so, multiple
/// wp_tablet.path events are sent. A device may be emulated and not
/// have a device path, and in that case this event will not be sent.
///
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet.done event.
///
class ZwpTabletV2PathEvent {
  /// path to local device
  final String path;

  ZwpTabletV2PathEvent(
    this.path,
  );

  @override
  toString() {
    return "ZwpTabletV2PathEvent (path: $path)";
  }
}

typedef ZwpTabletV2PathEventHandler = void Function(ZwpTabletV2PathEvent);

/// tablet description events sequence complete
///
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet.
///
class ZwpTabletV2DoneEvent {
  ZwpTabletV2DoneEvent();

  @override
  toString() {
    return "ZwpTabletV2DoneEvent ()";
  }
}

typedef ZwpTabletV2DoneEventHandler = void Function(ZwpTabletV2DoneEvent);

/// tablet removed event
///
/// Sent when the tablet has been removed from the system. When a tablet
/// is removed, some tools may be removed.
///
/// When this event is received, the client must wp_tablet.destroy
/// the object.
///
class ZwpTabletV2RemovedEvent {
  ZwpTabletV2RemovedEvent();

  @override
  toString() {
    return "ZwpTabletV2RemovedEvent ()";
  }
}

typedef ZwpTabletV2RemovedEventHandler = void Function(ZwpTabletV2RemovedEvent);

/// graphics tablet device
///
/// The wp_tablet interface represents one graphics tablet device. The
/// tablet interface itself does not generate events; all events are
/// generated by wp_tablet_tool objects when in proximity above a tablet.
///
/// A tablet has a number of static characteristics, e.g. device name and
/// pid/vid. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.tablet_added event. This initial event sequence is
/// terminated by a wp_tablet.done event.
///
class ZwpTabletV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletV2 {name: 'zwp_tablet_v2', id: '$objectId', version: '1',}";
  }

  /// destroy the tablet object
  ///
  /// This destroys the client's resource for this tablet object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// tablet device name
  ///
  /// A descriptive name for the tablet device.
  ///
  /// If the device has no descriptive name, this event is not sent.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Name
  /// - [name]: the device name
  void onName(ZwpTabletV2NameEventHandler handler) {
    _nameHandler = handler;
  }

  ZwpTabletV2NameEventHandler? _nameHandler;

  /// tablet device USB vendor/product id
  ///
  /// The USB vendor and product IDs for the tablet device.
  ///
  /// If the device has no USB vendor/product ID, this event is not sent.
  /// This can happen for virtual devices or non-USB devices, for instance.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Id
  /// - [vid]: USB vendor id
  /// - [pid]: USB product id
  void onId(ZwpTabletV2IdEventHandler handler) {
    _idHandler = handler;
  }

  ZwpTabletV2IdEventHandler? _idHandler;

  /// path to the device
  ///
  /// A system-specific device path that indicates which device is behind
  /// this wp_tablet. This information may be used to gather additional
  /// information about the device, e.g. through libwacom.
  ///
  /// A device may have more than one device path. If so, multiple
  /// wp_tablet.path events are sent. A device may be emulated and not
  /// have a device path, and in that case this event will not be sent.
  ///
  /// The format of the path is unspecified, it may be a device node, a
  /// sysfs path, or some other identifier. It is up to the client to
  /// identify the string provided.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet.done event.
  ///
  /// Event handler for Path
  /// - [path]: path to local device
  void onPath(ZwpTabletV2PathEventHandler handler) {
    _pathHandler = handler;
  }

  ZwpTabletV2PathEventHandler? _pathHandler;

  /// tablet description events sequence complete
  ///
  /// This event is sent immediately to signal the end of the initial
  /// burst of descriptive events. A client may consider the static
  /// description of the tablet to be complete and finalize initialization
  /// of the tablet.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletV2DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletV2DoneEventHandler? _doneHandler;

  /// tablet removed event
  ///
  /// Sent when the tablet has been removed from the system. When a tablet
  /// is removed, some tools may be removed.
  ///
  /// When this event is received, the client must wp_tablet.destroy
  /// the object.
  ///
  /// Event handler for Removed
  void onRemoved(ZwpTabletV2RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ZwpTabletV2RemovedEventHandler? _removedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_nameHandler != null) {
          var offset = 0;
          final nameLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final name =
              utf8.decode(data.sublist(offset, offset + nameLength - 1));
          offset += nameLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletV2NameEvent(
            name,
          );
          _nameHandler!(event);
        }
        break;
      case 1:
        if (_idHandler != null) {
          var offset = 0;
          final vid =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final pid =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletV2IdEvent(
            vid,
            pid,
          );
          _idHandler!(event);
        }
        break;
      case 2:
        if (_pathHandler != null) {
          var offset = 0;
          final pathLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final path =
              utf8.decode(data.sublist(offset, offset + pathLength - 1));
          offset += pathLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletV2PathEvent(
            path,
          );
          _pathHandler!(event);
        }
        break;
      case 3:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletV2DoneEvent());
        }
        break;
      case 4:
        if (_removedHandler != null) {
          _removedHandler!(ZwpTabletV2RemovedEvent());
        }
        break;
    }
  }
}

/// ring event source
///
/// Source information for ring events.
///
/// This event does not occur on its own. It is sent before a
/// wp_tablet_pad_ring.frame event and carries the source information
/// for all events within that frame.
///
/// The source specifies how this event was generated. If the source is
/// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
/// will be sent when the user lifts the finger off the device.
///
/// This event is optional. If the source is unknown for an interaction,
/// no event is sent.
///
class ZwpTabletPadRingV2SourceEvent {
  /// the event source
  final int source;

  ZwpTabletPadRingV2SourceEvent(
    this.source,
  );

  @override
  toString() {
    return "ZwpTabletPadRingV2SourceEvent (source: $source)";
  }
}

typedef ZwpTabletPadRingV2SourceEventHandler = void Function(
    ZwpTabletPadRingV2SourceEvent);

/// angle changed
///
/// Sent whenever the angle on a ring changes.
///
/// The angle is provided in degrees clockwise from the logical
/// north of the ring in the pad's current rotation.
///
class ZwpTabletPadRingV2AngleEvent {
  /// the current angle in degrees
  final double degrees;

  ZwpTabletPadRingV2AngleEvent(
    this.degrees,
  );

  @override
  toString() {
    return "ZwpTabletPadRingV2AngleEvent (degrees: $degrees)";
  }
}

typedef ZwpTabletPadRingV2AngleEventHandler = void Function(
    ZwpTabletPadRingV2AngleEvent);

/// interaction stopped
///
/// Stop notification for ring events.
///
/// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
/// event is sent to notify a client that the interaction with the ring
/// has terminated. This enables the client to implement kinetic scrolling.
/// See the wp_tablet_pad_ring.source documentation for information on
/// when this event may be generated.
///
/// Any wp_tablet_pad_ring.angle events with the same source after this
/// event should be considered as the start of a new interaction.
///
class ZwpTabletPadRingV2StopEvent {
  ZwpTabletPadRingV2StopEvent();

  @override
  toString() {
    return "ZwpTabletPadRingV2StopEvent ()";
  }
}

typedef ZwpTabletPadRingV2StopEventHandler = void Function(
    ZwpTabletPadRingV2StopEvent);

/// end of a ring event sequence
///
/// Indicates the end of a set of ring events that logically belong
/// together. A client is expected to accumulate the data in all events
/// within the frame before proceeding.
///
/// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
/// logically together. For example, on termination of a finger interaction
/// on a ring the compositor will send a wp_tablet_pad_ring.source event,
/// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
///
/// A wp_tablet_pad_ring.frame event is sent for every logical event
/// group, even if the group only contains a single wp_tablet_pad_ring
/// event. Specifically, a client may get a sequence: angle, frame,
/// angle, frame, etc.
///
class ZwpTabletPadRingV2FrameEvent {
  /// timestamp with millisecond granularity
  final int time;

  ZwpTabletPadRingV2FrameEvent(
    this.time,
  );

  @override
  toString() {
    return "ZwpTabletPadRingV2FrameEvent (time: $time)";
  }
}

typedef ZwpTabletPadRingV2FrameEventHandler = void Function(
    ZwpTabletPadRingV2FrameEvent);

/// pad ring
///
/// A circular interaction area, such as the touch ring on the Wacom Intuos
/// Pro series tablets.
///
/// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
/// event.
///
class ZwpTabletPadRingV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletPadRingV2(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletPadRingV2 {name: 'zwp_tablet_pad_ring_v2', id: '$objectId', version: '1',}";
  }

  /// set compositor feedback
  ///
  /// Request that the compositor use the provided feedback string
  /// associated with this ring. This request should be issued immediately
  /// after a wp_tablet_pad_group.mode_switch event from the corresponding
  /// group is received, or whenever the ring is mapped to a different
  /// action. See wp_tablet_pad_group.mode_switch for more details.
  ///
  /// Clients are encouraged to provide context-aware descriptions for
  /// the actions associated with the ring; compositors may use this
  /// information to offer visual feedback about the button layout
  /// (eg. on-screen displays).
  ///
  /// The provided string 'description' is a UTF-8 encoded string to be
  /// associated with this ring, and is considered user-visible; general
  /// internationalization rules apply.
  ///
  /// The serial argument will be that of the last
  /// wp_tablet_pad_group.mode_switch event received for the group of this
  /// ring. Requests providing other serials than the most recent one will be
  /// ignored.
  ///
  /// [description]: ring description
  /// [serial]: serial of the mode switch event
  Result<void, Object> setFeedback(String description, int serial) {
    logLn(
        "ZwpTabletPadRingV2::setFeedback  description: $description serial: $serial");
    var arguments = [description, serial];
    var argTypes = <WaylandType>[WaylandType.string, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    final descriptionBytes = utf8.encode(description);
    bytesBuilder.add(Uint32List.fromList([descriptionBytes.length + 1])
        .buffer
        .asUint8List());
    bytesBuilder.add(descriptionBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadRingV2::setFeedback: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy the ring object
  ///
  /// This destroys the client's resource for this ring object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletPadRingV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadRingV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// ring event source
  ///
  /// Source information for ring events.
  ///
  /// This event does not occur on its own. It is sent before a
  /// wp_tablet_pad_ring.frame event and carries the source information
  /// for all events within that frame.
  ///
  /// The source specifies how this event was generated. If the source is
  /// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
  /// will be sent when the user lifts the finger off the device.
  ///
  /// This event is optional. If the source is unknown for an interaction,
  /// no event is sent.
  ///
  /// Event handler for Source
  /// - [source]: the event source
  void onSource(ZwpTabletPadRingV2SourceEventHandler handler) {
    _sourceHandler = handler;
  }

  ZwpTabletPadRingV2SourceEventHandler? _sourceHandler;

  /// angle changed
  ///
  /// Sent whenever the angle on a ring changes.
  ///
  /// The angle is provided in degrees clockwise from the logical
  /// north of the ring in the pad's current rotation.
  ///
  /// Event handler for Angle
  /// - [degrees]: the current angle in degrees
  void onAngle(ZwpTabletPadRingV2AngleEventHandler handler) {
    _angleHandler = handler;
  }

  ZwpTabletPadRingV2AngleEventHandler? _angleHandler;

  /// interaction stopped
  ///
  /// Stop notification for ring events.
  ///
  /// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
  /// event is sent to notify a client that the interaction with the ring
  /// has terminated. This enables the client to implement kinetic scrolling.
  /// See the wp_tablet_pad_ring.source documentation for information on
  /// when this event may be generated.
  ///
  /// Any wp_tablet_pad_ring.angle events with the same source after this
  /// event should be considered as the start of a new interaction.
  ///
  /// Event handler for Stop
  void onStop(ZwpTabletPadRingV2StopEventHandler handler) {
    _stopHandler = handler;
  }

  ZwpTabletPadRingV2StopEventHandler? _stopHandler;

  /// end of a ring event sequence
  ///
  /// Indicates the end of a set of ring events that logically belong
  /// together. A client is expected to accumulate the data in all events
  /// within the frame before proceeding.
  ///
  /// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
  /// logically together. For example, on termination of a finger interaction
  /// on a ring the compositor will send a wp_tablet_pad_ring.source event,
  /// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
  ///
  /// A wp_tablet_pad_ring.frame event is sent for every logical event
  /// group, even if the group only contains a single wp_tablet_pad_ring
  /// event. Specifically, a client may get a sequence: angle, frame,
  /// angle, frame, etc.
  ///
  /// Event handler for Frame
  /// - [time]: timestamp with millisecond granularity
  void onFrame(ZwpTabletPadRingV2FrameEventHandler handler) {
    _frameHandler = handler;
  }

  ZwpTabletPadRingV2FrameEventHandler? _frameHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletPadRingV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_sourceHandler != null) {
          var offset = 0;
          final source =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadRingV2SourceEvent(
            source,
          );
          _sourceHandler!(event);
        }
        break;
      case 1:
        if (_angleHandler != null) {
          var offset = 0;
          final degrees = fixedToDouble(
              ByteData.view(data.buffer).getInt32(offset, Endian.little));
          offset += 4;
          var event = ZwpTabletPadRingV2AngleEvent(
            degrees,
          );
          _angleHandler!(event);
        }
        break;
      case 2:
        if (_stopHandler != null) {
          _stopHandler!(ZwpTabletPadRingV2StopEvent());
        }
        break;
      case 3:
        if (_frameHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadRingV2FrameEvent(
            time,
          );
          _frameHandler!(event);
        }
        break;
    }
  }
}

/// ring axis source
///
/// Describes the source types for ring events. This indicates to the
/// client how a ring event was physically generated; a client may
/// adjust the user interface accordingly. For example, events
/// from a "finger" source may trigger kinetic scrolling.
///

enum ZwpTabletPadRingV2Source {
  /// finger
  finger("finger", 1);

  const ZwpTabletPadRingV2Source(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletPadRingV2Source {name: $enumName, value: $enumValue}";
  }
}

/// strip event source
///
/// Source information for strip events.
///
/// This event does not occur on its own. It is sent before a
/// wp_tablet_pad_strip.frame event and carries the source information
/// for all events within that frame.
///
/// The source specifies how this event was generated. If the source is
/// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
/// will be sent when the user lifts their finger off the device.
///
/// This event is optional. If the source is unknown for an interaction,
/// no event is sent.
///
class ZwpTabletPadStripV2SourceEvent {
  /// the event source
  final int source;

  ZwpTabletPadStripV2SourceEvent(
    this.source,
  );

  @override
  toString() {
    return "ZwpTabletPadStripV2SourceEvent (source: $source)";
  }
}

typedef ZwpTabletPadStripV2SourceEventHandler = void Function(
    ZwpTabletPadStripV2SourceEvent);

/// position changed
///
/// Sent whenever the position on a strip changes.
///
/// The position is normalized to a range of [0, 65535], the 0-value
/// represents the top-most and/or left-most position of the strip in
/// the pad's current rotation.
///
class ZwpTabletPadStripV2PositionEvent {
  /// the current position
  final int position;

  ZwpTabletPadStripV2PositionEvent(
    this.position,
  );

  @override
  toString() {
    return "ZwpTabletPadStripV2PositionEvent (position: $position)";
  }
}

typedef ZwpTabletPadStripV2PositionEventHandler = void Function(
    ZwpTabletPadStripV2PositionEvent);

/// interaction stopped
///
/// Stop notification for strip events.
///
/// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
/// event is sent to notify a client that the interaction with the strip
/// has terminated. This enables the client to implement kinetic
/// scrolling. See the wp_tablet_pad_strip.source documentation for
/// information on when this event may be generated.
///
/// Any wp_tablet_pad_strip.position events with the same source after this
/// event should be considered as the start of a new interaction.
///
class ZwpTabletPadStripV2StopEvent {
  ZwpTabletPadStripV2StopEvent();

  @override
  toString() {
    return "ZwpTabletPadStripV2StopEvent ()";
  }
}

typedef ZwpTabletPadStripV2StopEventHandler = void Function(
    ZwpTabletPadStripV2StopEvent);

/// end of a strip event sequence
///
/// Indicates the end of a set of events that represent one logical
/// hardware strip event. A client is expected to accumulate the data
/// in all events within the frame before proceeding.
///
/// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
/// logically together. For example, on termination of a finger interaction
/// on a strip the compositor will send a wp_tablet_pad_strip.source event,
/// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
/// event.
///
/// A wp_tablet_pad_strip.frame event is sent for every logical event
/// group, even if the group only contains a single wp_tablet_pad_strip
/// event. Specifically, a client may get a sequence: position, frame,
/// position, frame, etc.
///
class ZwpTabletPadStripV2FrameEvent {
  /// timestamp with millisecond granularity
  final int time;

  ZwpTabletPadStripV2FrameEvent(
    this.time,
  );

  @override
  toString() {
    return "ZwpTabletPadStripV2FrameEvent (time: $time)";
  }
}

typedef ZwpTabletPadStripV2FrameEventHandler = void Function(
    ZwpTabletPadStripV2FrameEvent);

/// pad strip
///
/// A linear interaction area, such as the strips found in Wacom Cintiq
/// models.
///
/// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
/// event.
///
class ZwpTabletPadStripV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletPadStripV2(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletPadStripV2 {name: 'zwp_tablet_pad_strip_v2', id: '$objectId', version: '1',}";
  }

  /// set compositor feedback
  ///
  /// Requests the compositor to use the provided feedback string
  /// associated with this strip. This request should be issued immediately
  /// after a wp_tablet_pad_group.mode_switch event from the corresponding
  /// group is received, or whenever the strip is mapped to a different
  /// action. See wp_tablet_pad_group.mode_switch for more details.
  ///
  /// Clients are encouraged to provide context-aware descriptions for
  /// the actions associated with the strip, and compositors may use this
  /// information to offer visual feedback about the button layout
  /// (eg. on-screen displays).
  ///
  /// The provided string 'description' is a UTF-8 encoded string to be
  /// associated with this ring, and is considered user-visible; general
  /// internationalization rules apply.
  ///
  /// The serial argument will be that of the last
  /// wp_tablet_pad_group.mode_switch event received for the group of this
  /// strip. Requests providing other serials than the most recent one will be
  /// ignored.
  ///
  /// [description]: strip description
  /// [serial]: serial of the mode switch event
  Result<void, Object> setFeedback(String description, int serial) {
    logLn(
        "ZwpTabletPadStripV2::setFeedback  description: $description serial: $serial");
    var arguments = [description, serial];
    var argTypes = <WaylandType>[WaylandType.string, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    final descriptionBytes = utf8.encode(description);
    bytesBuilder.add(Uint32List.fromList([descriptionBytes.length + 1])
        .buffer
        .asUint8List());
    bytesBuilder.add(descriptionBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadStripV2::setFeedback: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy the strip object
  ///
  /// This destroys the client's resource for this strip object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletPadStripV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadStripV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// strip event source
  ///
  /// Source information for strip events.
  ///
  /// This event does not occur on its own. It is sent before a
  /// wp_tablet_pad_strip.frame event and carries the source information
  /// for all events within that frame.
  ///
  /// The source specifies how this event was generated. If the source is
  /// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
  /// will be sent when the user lifts their finger off the device.
  ///
  /// This event is optional. If the source is unknown for an interaction,
  /// no event is sent.
  ///
  /// Event handler for Source
  /// - [source]: the event source
  void onSource(ZwpTabletPadStripV2SourceEventHandler handler) {
    _sourceHandler = handler;
  }

  ZwpTabletPadStripV2SourceEventHandler? _sourceHandler;

  /// position changed
  ///
  /// Sent whenever the position on a strip changes.
  ///
  /// The position is normalized to a range of [0, 65535], the 0-value
  /// represents the top-most and/or left-most position of the strip in
  /// the pad's current rotation.
  ///
  /// Event handler for Position
  /// - [position]: the current position
  void onPosition(ZwpTabletPadStripV2PositionEventHandler handler) {
    _positionHandler = handler;
  }

  ZwpTabletPadStripV2PositionEventHandler? _positionHandler;

  /// interaction stopped
  ///
  /// Stop notification for strip events.
  ///
  /// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
  /// event is sent to notify a client that the interaction with the strip
  /// has terminated. This enables the client to implement kinetic
  /// scrolling. See the wp_tablet_pad_strip.source documentation for
  /// information on when this event may be generated.
  ///
  /// Any wp_tablet_pad_strip.position events with the same source after this
  /// event should be considered as the start of a new interaction.
  ///
  /// Event handler for Stop
  void onStop(ZwpTabletPadStripV2StopEventHandler handler) {
    _stopHandler = handler;
  }

  ZwpTabletPadStripV2StopEventHandler? _stopHandler;

  /// end of a strip event sequence
  ///
  /// Indicates the end of a set of events that represent one logical
  /// hardware strip event. A client is expected to accumulate the data
  /// in all events within the frame before proceeding.
  ///
  /// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
  /// logically together. For example, on termination of a finger interaction
  /// on a strip the compositor will send a wp_tablet_pad_strip.source event,
  /// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
  /// event.
  ///
  /// A wp_tablet_pad_strip.frame event is sent for every logical event
  /// group, even if the group only contains a single wp_tablet_pad_strip
  /// event. Specifically, a client may get a sequence: position, frame,
  /// position, frame, etc.
  ///
  /// Event handler for Frame
  /// - [time]: timestamp with millisecond granularity
  void onFrame(ZwpTabletPadStripV2FrameEventHandler handler) {
    _frameHandler = handler;
  }

  ZwpTabletPadStripV2FrameEventHandler? _frameHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletPadStripV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_sourceHandler != null) {
          var offset = 0;
          final source =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadStripV2SourceEvent(
            source,
          );
          _sourceHandler!(event);
        }
        break;
      case 1:
        if (_positionHandler != null) {
          var offset = 0;
          final position =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadStripV2PositionEvent(
            position,
          );
          _positionHandler!(event);
        }
        break;
      case 2:
        if (_stopHandler != null) {
          _stopHandler!(ZwpTabletPadStripV2StopEvent());
        }
        break;
      case 3:
        if (_frameHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadStripV2FrameEvent(
            time,
          );
          _frameHandler!(event);
        }
        break;
    }
  }
}

/// strip axis source
///
/// Describes the source types for strip events. This indicates to the
/// client how a strip event was physically generated; a client may
/// adjust the user interface accordingly. For example, events
/// from a "finger" source may trigger kinetic scrolling.
///

enum ZwpTabletPadStripV2Source {
  /// finger
  finger("finger", 1);

  const ZwpTabletPadStripV2Source(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletPadStripV2Source {name: $enumName, value: $enumValue}";
  }
}

/// buttons announced
///
/// Sent on wp_tablet_pad_group initialization to announce the available
/// buttons in the group. Button indices start at 0, a button may only be
/// in one group at a time.
///
/// This event is first sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
///
/// Some buttons are reserved by the compositor. These buttons may not be
/// assigned to any wp_tablet_pad_group. Compositors may broadcast this
/// event in the case of changes to the mapping of these reserved buttons.
/// If the compositor happens to reserve all buttons in a group, this event
/// will be sent with an empty array.
///
class ZwpTabletPadGroupV2ButtonsEvent {
  /// buttons in this group
  final List<int> buttons;

  ZwpTabletPadGroupV2ButtonsEvent(
    this.buttons,
  );

  @override
  toString() {
    return "ZwpTabletPadGroupV2ButtonsEvent (buttons: $buttons)";
  }
}

typedef ZwpTabletPadGroupV2ButtonsEventHandler = void Function(
    ZwpTabletPadGroupV2ButtonsEvent);

/// ring announced
///
/// Sent on wp_tablet_pad_group initialization to announce available rings.
/// One event is sent for each ring available on this pad group.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
///
class ZwpTabletPadGroupV2RingEvent {
  ///
  final int ring;

  ZwpTabletPadGroupV2RingEvent(
    this.ring,
  );

  @override
  toString() {
    return "ZwpTabletPadGroupV2RingEvent (ring: $ring)";
  }
}

typedef ZwpTabletPadGroupV2RingEventHandler = void Function(
    ZwpTabletPadGroupV2RingEvent);

/// strip announced
///
/// Sent on wp_tablet_pad initialization to announce available strips.
/// One event is sent for each strip available on this pad group.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event.
///
class ZwpTabletPadGroupV2StripEvent {
  ///
  final int strip;

  ZwpTabletPadGroupV2StripEvent(
    this.strip,
  );

  @override
  toString() {
    return "ZwpTabletPadGroupV2StripEvent (strip: $strip)";
  }
}

typedef ZwpTabletPadGroupV2StripEventHandler = void Function(
    ZwpTabletPadGroupV2StripEvent);

/// mode-switch ability announced
///
/// Sent on wp_tablet_pad_group initialization to announce that the pad
/// group may switch between modes. A client may use a mode to store a
/// specific configuration for buttons, rings and strips and use the
/// wl_tablet_pad_group.mode_switch event to toggle between these
/// configurations. Mode indices start at 0.
///
/// Switching modes is compositor-dependent. See the
/// wp_tablet_pad_group.mode_switch event for more details.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad_group.done event. This event is only sent when more than
/// more than one mode is available.
///
class ZwpTabletPadGroupV2ModesEvent {
  /// the number of modes
  final int modes;

  ZwpTabletPadGroupV2ModesEvent(
    this.modes,
  );

  @override
  toString() {
    return "ZwpTabletPadGroupV2ModesEvent (modes: $modes)";
  }
}

typedef ZwpTabletPadGroupV2ModesEventHandler = void Function(
    ZwpTabletPadGroupV2ModesEvent);

/// tablet group description events sequence complete
///
/// This event is sent immediately to signal the end of the initial
/// burst of descriptive events. A client may consider the static
/// description of the tablet to be complete and finalize initialization
/// of the tablet group.
///
class ZwpTabletPadGroupV2DoneEvent {
  ZwpTabletPadGroupV2DoneEvent();

  @override
  toString() {
    return "ZwpTabletPadGroupV2DoneEvent ()";
  }
}

typedef ZwpTabletPadGroupV2DoneEventHandler = void Function(
    ZwpTabletPadGroupV2DoneEvent);

/// mode switch event
///
/// Notification that the mode was switched.
///
/// A mode applies to all buttons, rings and strips in a group
/// simultaneously, but a client is not required to assign different actions
/// for each mode. For example, a client may have mode-specific button
/// mappings but map the ring to vertical scrolling in all modes. Mode
/// indices start at 0.
///
/// Switching modes is compositor-dependent. The compositor may provide
/// visual cues to the client about the mode, e.g. by toggling LEDs on
/// the tablet device. Mode-switching may be software-controlled or
/// controlled by one or more physical buttons. For example, on a Wacom
/// Intuos Pro, the button inside the ring may be assigned to switch
/// between modes.
///
/// The compositor will also send this event after wp_tablet_pad.enter on
/// each group in order to notify of the current mode. Groups that only
/// feature one mode will use mode=0 when emitting this event.
///
/// If a button action in the new mode differs from the action in the
/// previous mode, the client should immediately issue a
/// wp_tablet_pad.set_feedback request for each changed button.
///
/// If a ring or strip action in the new mode differs from the action
/// in the previous mode, the client should immediately issue a
/// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
/// for each changed ring or strip.
///
class ZwpTabletPadGroupV2ModeSwitchEvent {
  /// the time of the event with millisecond granularity
  final int time;

  ///
  final int serial;

  /// the new mode of the pad
  final int mode;

  ZwpTabletPadGroupV2ModeSwitchEvent(
    this.time,
    this.serial,
    this.mode,
  );

  @override
  toString() {
    return "ZwpTabletPadGroupV2ModeSwitchEvent (time: $time, serial: $serial, mode: $mode)";
  }
}

typedef ZwpTabletPadGroupV2ModeSwitchEventHandler = void Function(
    ZwpTabletPadGroupV2ModeSwitchEvent);

/// a set of buttons, rings and strips
///
/// A pad group describes a distinct (sub)set of buttons, rings and strips
/// present in the tablet. The criteria of this grouping is usually positional,
/// eg. if a tablet has buttons on the left and right side, 2 groups will be
/// presented. The physical arrangement of groups is undisclosed and may
/// change on the fly.
///
/// Pad groups will announce their features during pad initialization. Between
/// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
/// pad group will announce the buttons, rings and strips contained in it,
/// plus the number of supported modes.
///
/// Modes are a mechanism to allow multiple groups of actions for every element
/// in the pad group. The number of groups and available modes in each is
/// persistent across device plugs. The current mode is user-switchable, it
/// will be announced through the wp_tablet_pad_group.mode_switch event both
/// whenever it is switched, and after wp_tablet_pad.enter.
///
/// The current mode logically applies to all elements in the pad group,
/// although it is at clients' discretion whether to actually perform different
/// actions, and/or issue the respective .set_feedback requests to notify the
/// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
///
class ZwpTabletPadGroupV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletPadGroupV2(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletPadGroupV2 {name: 'zwp_tablet_pad_group_v2', id: '$objectId', version: '1',}";
  }

  /// destroy the pad object
  ///
  /// Destroy the wp_tablet_pad_group object. Objects created from this object
  /// are unaffected and should be destroyed separately.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletPadGroupV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadGroupV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// buttons announced
  ///
  /// Sent on wp_tablet_pad_group initialization to announce the available
  /// buttons in the group. Button indices start at 0, a button may only be
  /// in one group at a time.
  ///
  /// This event is first sent in the initial burst of events before the
  /// wp_tablet_pad_group.done event.
  ///
  /// Some buttons are reserved by the compositor. These buttons may not be
  /// assigned to any wp_tablet_pad_group. Compositors may broadcast this
  /// event in the case of changes to the mapping of these reserved buttons.
  /// If the compositor happens to reserve all buttons in a group, this event
  /// will be sent with an empty array.
  ///
  /// Event handler for Buttons
  /// - [buttons]: buttons in this group
  void onButtons(ZwpTabletPadGroupV2ButtonsEventHandler handler) {
    _buttonsHandler = handler;
  }

  ZwpTabletPadGroupV2ButtonsEventHandler? _buttonsHandler;

  /// ring announced
  ///
  /// Sent on wp_tablet_pad_group initialization to announce available rings.
  /// One event is sent for each ring available on this pad group.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad_group.done event.
  ///
  /// Event handler for Ring
  /// - [ring]:
  void onRing(ZwpTabletPadGroupV2RingEventHandler handler) {
    _ringHandler = handler;
  }

  ZwpTabletPadGroupV2RingEventHandler? _ringHandler;

  /// strip announced
  ///
  /// Sent on wp_tablet_pad initialization to announce available strips.
  /// One event is sent for each strip available on this pad group.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad_group.done event.
  ///
  /// Event handler for Strip
  /// - [strip]:
  void onStrip(ZwpTabletPadGroupV2StripEventHandler handler) {
    _stripHandler = handler;
  }

  ZwpTabletPadGroupV2StripEventHandler? _stripHandler;

  /// mode-switch ability announced
  ///
  /// Sent on wp_tablet_pad_group initialization to announce that the pad
  /// group may switch between modes. A client may use a mode to store a
  /// specific configuration for buttons, rings and strips and use the
  /// wl_tablet_pad_group.mode_switch event to toggle between these
  /// configurations. Mode indices start at 0.
  ///
  /// Switching modes is compositor-dependent. See the
  /// wp_tablet_pad_group.mode_switch event for more details.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad_group.done event. This event is only sent when more than
  /// more than one mode is available.
  ///
  /// Event handler for Modes
  /// - [modes]: the number of modes
  void onModes(ZwpTabletPadGroupV2ModesEventHandler handler) {
    _modesHandler = handler;
  }

  ZwpTabletPadGroupV2ModesEventHandler? _modesHandler;

  /// tablet group description events sequence complete
  ///
  /// This event is sent immediately to signal the end of the initial
  /// burst of descriptive events. A client may consider the static
  /// description of the tablet to be complete and finalize initialization
  /// of the tablet group.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletPadGroupV2DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletPadGroupV2DoneEventHandler? _doneHandler;

  /// mode switch event
  ///
  /// Notification that the mode was switched.
  ///
  /// A mode applies to all buttons, rings and strips in a group
  /// simultaneously, but a client is not required to assign different actions
  /// for each mode. For example, a client may have mode-specific button
  /// mappings but map the ring to vertical scrolling in all modes. Mode
  /// indices start at 0.
  ///
  /// Switching modes is compositor-dependent. The compositor may provide
  /// visual cues to the client about the mode, e.g. by toggling LEDs on
  /// the tablet device. Mode-switching may be software-controlled or
  /// controlled by one or more physical buttons. For example, on a Wacom
  /// Intuos Pro, the button inside the ring may be assigned to switch
  /// between modes.
  ///
  /// The compositor will also send this event after wp_tablet_pad.enter on
  /// each group in order to notify of the current mode. Groups that only
  /// feature one mode will use mode=0 when emitting this event.
  ///
  /// If a button action in the new mode differs from the action in the
  /// previous mode, the client should immediately issue a
  /// wp_tablet_pad.set_feedback request for each changed button.
  ///
  /// If a ring or strip action in the new mode differs from the action
  /// in the previous mode, the client should immediately issue a
  /// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
  /// for each changed ring or strip.
  ///
  /// Event handler for ModeSwitch
  /// - [time]: the time of the event with millisecond granularity
  /// - [serial]:
  /// - [mode]: the new mode of the pad
  void onModeSwitch(ZwpTabletPadGroupV2ModeSwitchEventHandler handler) {
    _modeSwitchHandler = handler;
  }

  ZwpTabletPadGroupV2ModeSwitchEventHandler? _modeSwitchHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletPadGroupV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_buttonsHandler != null) {
          var offset = 0;
          final buttons = getArray(data, offset);
          var arrayLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4 + arrayLength;
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletPadGroupV2ButtonsEvent(
            buttons,
          );
          _buttonsHandler!(event);
        }
        break;
      case 1:
        if (_ringHandler != null) {
          var offset = 0;
          final ring = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletPadGroupV2RingEvent(
            ring,
          );
          _ringHandler!(event);
        }
        break;
      case 2:
        if (_stripHandler != null) {
          var offset = 0;
          final strip = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletPadGroupV2StripEvent(
            strip,
          );
          _stripHandler!(event);
        }
        break;
      case 3:
        if (_modesHandler != null) {
          var offset = 0;
          final modes =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadGroupV2ModesEvent(
            modes,
          );
          _modesHandler!(event);
        }
        break;
      case 4:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletPadGroupV2DoneEvent());
        }
        break;
      case 5:
        if (_modeSwitchHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final mode =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadGroupV2ModeSwitchEvent(
            time,
            serial,
            mode,
          );
          _modeSwitchHandler!(event);
        }
        break;
    }
  }
}

/// group announced
///
/// Sent on wp_tablet_pad initialization to announce available groups.
/// One event is sent for each pad group available.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event. At least one group will be announced.
///
class ZwpTabletPadV2GroupEvent {
  ///
  final int padGroup;

  ZwpTabletPadV2GroupEvent(
    this.padGroup,
  );

  @override
  toString() {
    return "ZwpTabletPadV2GroupEvent (padGroup: $padGroup)";
  }
}

typedef ZwpTabletPadV2GroupEventHandler = void Function(
    ZwpTabletPadV2GroupEvent);

/// path to the device
///
/// A system-specific device path that indicates which device is behind
/// this wp_tablet_pad. This information may be used to gather additional
/// information about the device, e.g. through libwacom.
///
/// The format of the path is unspecified, it may be a device node, a
/// sysfs path, or some other identifier. It is up to the client to
/// identify the string provided.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event.
///
class ZwpTabletPadV2PathEvent {
  /// path to local device
  final String path;

  ZwpTabletPadV2PathEvent(
    this.path,
  );

  @override
  toString() {
    return "ZwpTabletPadV2PathEvent (path: $path)";
  }
}

typedef ZwpTabletPadV2PathEventHandler = void Function(ZwpTabletPadV2PathEvent);

/// buttons announced
///
/// Sent on wp_tablet_pad initialization to announce the available
/// buttons.
///
/// This event is sent in the initial burst of events before the
/// wp_tablet_pad.done event. This event is only sent when at least one
/// button is available.
///
class ZwpTabletPadV2ButtonsEvent {
  /// the number of buttons
  final int buttons;

  ZwpTabletPadV2ButtonsEvent(
    this.buttons,
  );

  @override
  toString() {
    return "ZwpTabletPadV2ButtonsEvent (buttons: $buttons)";
  }
}

typedef ZwpTabletPadV2ButtonsEventHandler = void Function(
    ZwpTabletPadV2ButtonsEvent);

/// pad description event sequence complete
///
/// This event signals the end of the initial burst of descriptive
/// events. A client may consider the static description of the pad to
/// be complete and finalize initialization of the pad.
///
class ZwpTabletPadV2DoneEvent {
  ZwpTabletPadV2DoneEvent();

  @override
  toString() {
    return "ZwpTabletPadV2DoneEvent ()";
  }
}

typedef ZwpTabletPadV2DoneEventHandler = void Function(ZwpTabletPadV2DoneEvent);

/// physical button state
///
/// Sent whenever the physical state of a button changes.
///
class ZwpTabletPadV2ButtonEvent {
  /// the time of the event with millisecond granularity
  final int time;

  /// the index of the button that changed state
  final int button;

  ///
  final int state;

  ZwpTabletPadV2ButtonEvent(
    this.time,
    this.button,
    this.state,
  );

  @override
  toString() {
    return "ZwpTabletPadV2ButtonEvent (time: $time, button: $button, state: $state)";
  }
}

typedef ZwpTabletPadV2ButtonEventHandler = void Function(
    ZwpTabletPadV2ButtonEvent);

/// enter event
///
/// Notification that this pad is focused on the specified surface.
///
class ZwpTabletPadV2EnterEvent {
  /// serial number of the enter event
  final int serial;

  /// the tablet the pad is attached to
  final int tablet;

  /// surface the pad is focused on
  final int surface;

  ZwpTabletPadV2EnterEvent(
    this.serial,
    this.tablet,
    this.surface,
  );

  @override
  toString() {
    return "ZwpTabletPadV2EnterEvent (serial: $serial, tablet: $tablet, surface: $surface)";
  }
}

typedef ZwpTabletPadV2EnterEventHandler = void Function(
    ZwpTabletPadV2EnterEvent);

/// leave event
///
/// Notification that this pad is no longer focused on the specified
/// surface.
///
class ZwpTabletPadV2LeaveEvent {
  /// serial number of the leave event
  final int serial;

  /// surface the pad is no longer focused on
  final int surface;

  ZwpTabletPadV2LeaveEvent(
    this.serial,
    this.surface,
  );

  @override
  toString() {
    return "ZwpTabletPadV2LeaveEvent (serial: $serial, surface: $surface)";
  }
}

typedef ZwpTabletPadV2LeaveEventHandler = void Function(
    ZwpTabletPadV2LeaveEvent);

/// pad removed event
///
/// Sent when the pad has been removed from the system. When a tablet
/// is removed its pad(s) will be removed too.
///
/// When this event is received, the client must destroy all rings, strips
/// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
/// the pad itself.
///
class ZwpTabletPadV2RemovedEvent {
  ZwpTabletPadV2RemovedEvent();

  @override
  toString() {
    return "ZwpTabletPadV2RemovedEvent ()";
  }
}

typedef ZwpTabletPadV2RemovedEventHandler = void Function(
    ZwpTabletPadV2RemovedEvent);

/// a set of buttons, rings and strips
///
/// A pad device is a set of buttons, rings and strips
/// usually physically present on the tablet device itself. Some
/// exceptions exist where the pad device is physically detached, e.g. the
/// Wacom ExpressKey Remote.
///
/// Pad devices have no axes that control the cursor and are generally
/// auxiliary devices to the tool devices used on the tablet surface.
///
/// A pad device has a number of static characteristics, e.g. the number
/// of rings. These capabilities are sent in an event sequence after the
/// wp_tablet_seat.pad_added event before any actual events from this pad.
/// This initial event sequence is terminated by a wp_tablet_pad.done
/// event.
///
/// All pad features (buttons, rings and strips) are logically divided into
/// groups and all pads have at least one group. The available groups are
/// notified through the wp_tablet_pad.group event; the compositor will
/// emit one event per group before emitting wp_tablet_pad.done.
///
/// Groups may have multiple modes. Modes allow clients to map multiple
/// actions to a single pad feature. Only one mode can be active per group,
/// although different groups may have different active modes.
///
class ZwpTabletPadV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTabletPadV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTabletPadV2 {name: 'zwp_tablet_pad_v2', id: '$objectId', version: '1',}";
  }

  /// set compositor feedback
  ///
  /// Requests the compositor to use the provided feedback string
  /// associated with this button. This request should be issued immediately
  /// after a wp_tablet_pad_group.mode_switch event from the corresponding
  /// group is received, or whenever a button is mapped to a different
  /// action. See wp_tablet_pad_group.mode_switch for more details.
  ///
  /// Clients are encouraged to provide context-aware descriptions for
  /// the actions associated with each button, and compositors may use
  /// this information to offer visual feedback on the button layout
  /// (e.g. on-screen displays).
  ///
  /// Button indices start at 0. Setting the feedback string on a button
  /// that is reserved by the compositor (i.e. not belonging to any
  /// wp_tablet_pad_group) does not generate an error but the compositor
  /// is free to ignore the request.
  ///
  /// The provided string 'description' is a UTF-8 encoded string to be
  /// associated with this ring, and is considered user-visible; general
  /// internationalization rules apply.
  ///
  /// The serial argument will be that of the last
  /// wp_tablet_pad_group.mode_switch event received for the group of this
  /// button. Requests providing other serials than the most recent one will
  /// be ignored.
  ///
  /// [button]: button index
  /// [description]: button description
  /// [serial]: serial of the mode switch event
  Result<void, Object> setFeedback(int button, String description, int serial) {
    logLn(
        "ZwpTabletPadV2::setFeedback  button: $button description: $description serial: $serial");
    var arguments = [button, description, serial];
    var argTypes = <WaylandType>[
      WaylandType.uint,
      WaylandType.string,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([button]).buffer.asUint8List());
    final descriptionBytes = utf8.encode(description);
    bytesBuilder.add(Uint32List.fromList([descriptionBytes.length + 1])
        .buffer
        .asUint8List());
    bytesBuilder.add(descriptionBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadV2::setFeedback: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy the pad object
  ///
  /// Destroy the wp_tablet_pad object. Objects created from this object
  /// are unaffected and should be destroyed separately.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTabletPadV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTabletPadV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// group announced
  ///
  /// Sent on wp_tablet_pad initialization to announce available groups.
  /// One event is sent for each pad group available.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad.done event. At least one group will be announced.
  ///
  /// Event handler for Group
  /// - [pad_group]:
  void onGroup(ZwpTabletPadV2GroupEventHandler handler) {
    _groupHandler = handler;
  }

  ZwpTabletPadV2GroupEventHandler? _groupHandler;

  /// path to the device
  ///
  /// A system-specific device path that indicates which device is behind
  /// this wp_tablet_pad. This information may be used to gather additional
  /// information about the device, e.g. through libwacom.
  ///
  /// The format of the path is unspecified, it may be a device node, a
  /// sysfs path, or some other identifier. It is up to the client to
  /// identify the string provided.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad.done event.
  ///
  /// Event handler for Path
  /// - [path]: path to local device
  void onPath(ZwpTabletPadV2PathEventHandler handler) {
    _pathHandler = handler;
  }

  ZwpTabletPadV2PathEventHandler? _pathHandler;

  /// buttons announced
  ///
  /// Sent on wp_tablet_pad initialization to announce the available
  /// buttons.
  ///
  /// This event is sent in the initial burst of events before the
  /// wp_tablet_pad.done event. This event is only sent when at least one
  /// button is available.
  ///
  /// Event handler for Buttons
  /// - [buttons]: the number of buttons
  void onButtons(ZwpTabletPadV2ButtonsEventHandler handler) {
    _buttonsHandler = handler;
  }

  ZwpTabletPadV2ButtonsEventHandler? _buttonsHandler;

  /// pad description event sequence complete
  ///
  /// This event signals the end of the initial burst of descriptive
  /// events. A client may consider the static description of the pad to
  /// be complete and finalize initialization of the pad.
  ///
  /// Event handler for Done
  void onDone(ZwpTabletPadV2DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTabletPadV2DoneEventHandler? _doneHandler;

  /// physical button state
  ///
  /// Sent whenever the physical state of a button changes.
  ///
  /// Event handler for Button
  /// - [time]: the time of the event with millisecond granularity
  /// - [button]: the index of the button that changed state
  /// - [state]:
  void onButton(ZwpTabletPadV2ButtonEventHandler handler) {
    _buttonHandler = handler;
  }

  ZwpTabletPadV2ButtonEventHandler? _buttonHandler;

  /// enter event
  ///
  /// Notification that this pad is focused on the specified surface.
  ///
  /// Event handler for Enter
  /// - [serial]: serial number of the enter event
  /// - [tablet]: the tablet the pad is attached to
  /// - [surface]: surface the pad is focused on
  void onEnter(ZwpTabletPadV2EnterEventHandler handler) {
    _enterHandler = handler;
  }

  ZwpTabletPadV2EnterEventHandler? _enterHandler;

  /// leave event
  ///
  /// Notification that this pad is no longer focused on the specified
  /// surface.
  ///
  /// Event handler for Leave
  /// - [serial]: serial number of the leave event
  /// - [surface]: surface the pad is no longer focused on
  void onLeave(ZwpTabletPadV2LeaveEventHandler handler) {
    _leaveHandler = handler;
  }

  ZwpTabletPadV2LeaveEventHandler? _leaveHandler;

  /// pad removed event
  ///
  /// Sent when the pad has been removed from the system. When a tablet
  /// is removed its pad(s) will be removed too.
  ///
  /// When this event is received, the client must destroy all rings, strips
  /// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
  /// the pad itself.
  ///
  /// Event handler for Removed
  void onRemoved(ZwpTabletPadV2RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ZwpTabletPadV2RemovedEventHandler? _removedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTabletPadV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_groupHandler != null) {
          var offset = 0;
          final padGroup = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletPadV2GroupEvent(
            padGroup,
          );
          _groupHandler!(event);
        }
        break;
      case 1:
        if (_pathHandler != null) {
          var offset = 0;
          final pathLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final path =
              utf8.decode(data.sublist(offset, offset + pathLength - 1));
          offset += pathLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTabletPadV2PathEvent(
            path,
          );
          _pathHandler!(event);
        }
        break;
      case 2:
        if (_buttonsHandler != null) {
          var offset = 0;
          final buttons =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadV2ButtonsEvent(
            buttons,
          );
          _buttonsHandler!(event);
        }
        break;
      case 3:
        if (_doneHandler != null) {
          _doneHandler!(ZwpTabletPadV2DoneEvent());
        }
        break;
      case 4:
        if (_buttonHandler != null) {
          var offset = 0;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final button =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTabletPadV2ButtonEvent(
            time,
            button,
            state,
          );
          _buttonHandler!(event);
        }
        break;
      case 5:
        if (_enterHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final tablet = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletPadV2EnterEvent(
            serial,
            tablet,
            surface,
          );
          _enterHandler!(event);
        }
        break;
      case 6:
        if (_leaveHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTabletPadV2LeaveEvent(
            serial,
            surface,
          );
          _leaveHandler!(event);
        }
        break;
      case 7:
        if (_removedHandler != null) {
          _removedHandler!(ZwpTabletPadV2RemovedEvent());
        }
        break;
    }
  }
}

/// physical button state
///
/// Describes the physical state of a button that caused the button
/// event.
///

enum ZwpTabletPadV2ButtonState {
  /// the button is not pressed
  released("released", 0),

  /// the button is pressed
  pressed("pressed", 1);

  const ZwpTabletPadV2ButtonState(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTabletPadV2ButtonState {name: $enumName, value: $enumValue}";
  }
}
