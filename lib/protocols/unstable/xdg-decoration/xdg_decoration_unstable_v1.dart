// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-decoration/xdg-decoration-unstable-v1.xml
//
// xdg_decoration_unstable_v1 Protocol Copyright:
///
/// Copyright Â© 2018 Simon Ser
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'package:wayland/protocols/stable/xdg-shell/xdg_shell.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// window decoration manager
///
/// This interface allows a compositor to announce support for server-side
/// decorations.
///
/// A window decoration is a set of window controls as deemed appropriate by
/// the party managing them, such as user interface components used to move,
/// resize and change a window's state.
///
/// A client can use this protocol to request being decorated by a supporting
/// compositor.
///
/// If compositor and client do not negotiate the use of a server-side
/// decoration using this protocol, clients continue to self-decorate as they
/// see fit.
///
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
///
class ZxdgDecorationManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZxdgDecorationManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgDecorationManagerV1 {name: 'zxdg_decoration_manager_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the decoration manager object
  ///
  /// Destroy the decoration manager. This doesn't destroy objects created
  /// with the manager.
  ///
  void destroy() {
    logLn("ZxdgDecorationManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// create a new toplevel decoration object
  ///
  /// Create a new decoration object associated with the given toplevel.
  ///
  /// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
  /// buffer attached or committed is a client error, and any attempts by a
  /// client to attach or manipulate a buffer prior to the first
  /// xdg_toplevel_decoration.configure event must also be treated as
  /// errors.
  ///
  /// [id]:
  /// [toplevel]:
  ZxdgToplevelDecorationV1 getToplevelDecoration(XdgToplevel toplevel) {
    var id = ZxdgToplevelDecorationV1(innerContext);
    logLn(
        "ZxdgDecorationManagerV1::getToplevelDecoration  id: $id toplevel: $toplevel");
    var arguments = [id, toplevel];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([toplevel.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

/// notify a decoration mode change
///
/// The configure event configures the effective decoration mode. The
/// configured state should not be applied immediately. Clients must send an
/// ack_configure in response to this event. See xdg_surface.configure and
/// xdg_surface.ack_configure for details.
///
/// A configure event can be sent at any time. The specified mode must be
/// obeyed by the client.
///
class ZxdgToplevelDecorationV1ConfigureEvent {
  /// the decoration mode
  final int mode;

  ZxdgToplevelDecorationV1ConfigureEvent(
    this.mode,
  );

  @override
  toString() {
    return "ZxdgToplevelDecorationV1ConfigureEvent (mode: $mode)";
  }
}

typedef ZxdgToplevelDecorationV1ConfigureEventHandler = void Function(
    ZxdgToplevelDecorationV1ConfigureEvent);

/// decoration object for a toplevel surface
///
/// The decoration object allows the compositor to toggle server-side window
/// decorations for a toplevel surface. The client can request to switch to
/// another mode.
///
/// The xdg_toplevel_decoration object must be destroyed before its
/// xdg_toplevel.
///
class ZxdgToplevelDecorationV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZxdgToplevelDecorationV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgToplevelDecorationV1 {name: 'zxdg_toplevel_decoration_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the decoration object
  ///
  /// Switch back to a mode without any server-side decorations at the next
  /// commit.
  ///
  void destroy() {
    logLn("ZxdgToplevelDecorationV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// set the decoration mode
  ///
  /// Set the toplevel surface decoration mode. This informs the compositor
  /// that the client prefers the provided decoration mode.
  ///
  /// After requesting a decoration mode, the compositor will respond by
  /// emitting an xdg_surface.configure event. The client should then update
  /// its content, drawing it without decorations if the received mode is
  /// server-side decorations. The client must also acknowledge the configure
  /// when committing the new content (see xdg_surface.ack_configure).
  ///
  /// The compositor can decide not to use the client's mode and enforce a
  /// different mode instead.
  ///
  /// Clients whose decoration mode depend on the xdg_toplevel state may send
  /// a set_mode request in response to an xdg_surface.configure event and wait
  /// for the next xdg_surface.configure event to prevent unwanted state.
  /// Such clients are responsible for preventing configure loops and must
  /// make sure not to send multiple successive set_mode requests with the
  /// same decoration mode.
  ///
  /// [mode]: the decoration mode
  void setMode(int mode) {
    logLn("ZxdgToplevelDecorationV1::setMode  mode: $mode");
    var arguments = [mode];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([mode]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// unset the decoration mode
  ///
  /// Unset the toplevel surface decoration mode. This informs the compositor
  /// that the client doesn't prefer a particular decoration mode.
  ///
  /// This request has the same semantics as set_mode.
  ///
  void unsetMode() {
    logLn("ZxdgToplevelDecorationV1::unsetMode ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// notify a decoration mode change
  ///
  /// The configure event configures the effective decoration mode. The
  /// configured state should not be applied immediately. Clients must send an
  /// ack_configure in response to this event. See xdg_surface.configure and
  /// xdg_surface.ack_configure for details.
  ///
  /// A configure event can be sent at any time. The specified mode must be
  /// obeyed by the client.
  ///
  /// Event handler for Configure
  /// - [mode]: the decoration mode
  void onConfigure(ZxdgToplevelDecorationV1ConfigureEventHandler handler) {
    _configureHandler = handler;
  }

  ZxdgToplevelDecorationV1ConfigureEventHandler? _configureHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgToplevelDecorationV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_configureHandler != null) {
          var offset = 0;
          final mode =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZxdgToplevelDecorationV1ConfigureEvent(
            mode,
          );
          _configureHandler!(event);
        }
        break;
    }
  }
}

///
///

enum ZxdgToplevelDecorationV1Error {
  /// xdg_toplevel has a buffer attached before configure
  unconfiguredBuffer("unconfigured_buffer", 0),

  /// xdg_toplevel already has a decoration object
  alreadyConstructed("already_constructed", 1),

  /// xdg_toplevel destroyed before the decoration object
  orphaned("orphaned", 2);

  const ZxdgToplevelDecorationV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZxdgToplevelDecorationV1Error {name: $enumName, value: $enumValue}";
  }
}

/// window decoration modes
///
/// These values describe window decoration modes.
///

enum ZxdgToplevelDecorationV1Mode {
  /// no server-side window decoration
  clientSide("client_side", 1),

  /// server-side window decoration
  serverSide("server_side", 2);

  const ZxdgToplevelDecorationV1Mode(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZxdgToplevelDecorationV1Mode {name: $enumName, value: $enumValue}";
  }
}
