// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/idle-inhibit/idle-inhibit-unstable-v1.xml
//
// idle_inhibit_unstable_v1 Protocol Copyright: 
/// 
/// Copyright Â© 2015 Samsung Electronics Co., Ltd
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:result_dart/result_dart.dart';


/// control behavior when display idles
/// 
/// This interface permits inhibiting the idle behavior such as screen
/// blanking, locking, and screensaving.  The client binds the idle manager
/// globally, then creates idle-inhibitor objects for each surface.
/// 
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
/// 
class ZwpIdleInhibitManagerV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  ZwpIdleInhibitManagerV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "ZwpIdleInhibitManagerV1 {name: 'zwp_idle_inhibit_manager_v1', id: '$objectId', version: '1',}";
}

/// destroy the idle inhibitor object
/// 
/// Destroy the inhibit manager.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("ZwpIdleInhibitManagerV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpIdleInhibitManagerV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// create a new inhibitor object
/// 
/// Create a new inhibitor object associated with the given surface.
/// 
/// [id]:
/// [surface]: the surface that inhibits the idle behavior
  Result<ZwpIdleInhibitorV1,Object> createInhibitor(Surface surface) {
  var id =  ZwpIdleInhibitorV1(innerContext);
    logLn("ZwpIdleInhibitManagerV1::createInhibitor  id: $id surface: $surface");
var arguments = [id, surface];var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpIdleInhibitManagerV1::createInhibitor: $e");
   return Failure(e);
    }
    return Success(id);
  }

}



/// context object for inhibiting idle behavior
/// 
/// An idle inhibitor prevents the output that the associated surface is
/// visible on from being set to a state where it is not visually usable due
/// to lack of user interaction (e.g. blanked, dimmed, locked, set to power
/// save, etc.)  Any screensaver processes are also blocked from displaying.
/// 
/// If the surface is destroyed, unmapped, becomes occluded, loses
/// visibility, or otherwise becomes not visually relevant for the user, the
/// idle inhibitor will not be honored by the compositor; if the surface
/// subsequently regains visibility the inhibitor takes effect once again.
/// Likewise, the inhibitor isn't honored if the system was already idled at
/// the time the inhibitor was established, although if the system later
/// de-idles and re-idles the inhibitor will take effect.
/// 
class ZwpIdleInhibitorV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  ZwpIdleInhibitorV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "ZwpIdleInhibitorV1 {name: 'zwp_idle_inhibitor_v1', id: '$objectId', version: '1',}";
}

/// destroy the idle inhibitor object
/// 
/// Remove the inhibitor effect from the associated wl_surface.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("ZwpIdleInhibitorV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in ZwpIdleInhibitorV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

}

