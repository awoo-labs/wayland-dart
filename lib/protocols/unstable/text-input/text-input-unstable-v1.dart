// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/text-input/text-input-unstable-v1.xml
//
// text_input_unstable_v1 Protocol Copyright:
///
/// Copyright Â© 2012, 2013 Intel Corporation
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// enter event
///
/// Notify the text_input object when it received focus. Typically in
/// response to an activate request.
///
class ZwpTextInputV1EnterEvent {
  ///
  final int surface;

  ZwpTextInputV1EnterEvent(
    this.surface,
  );

  @override
  toString() {
    return "ZwpTextInputV1EnterEvent (surface: $surface)";
  }
}

typedef ZwpTextInputV1EnterEventHandler = void Function(
    ZwpTextInputV1EnterEvent);

/// leave event
///
/// Notify the text_input object when it lost focus. Either in response
/// to a deactivate request or when the assigned surface lost focus or was
/// destroyed.
///
class ZwpTextInputV1LeaveEvent {
  ZwpTextInputV1LeaveEvent();

  @override
  toString() {
    return "ZwpTextInputV1LeaveEvent ()";
  }
}

typedef ZwpTextInputV1LeaveEventHandler = void Function(
    ZwpTextInputV1LeaveEvent);

/// modifiers map
///
/// Transfer an array of 0-terminated modifier names. The position in
/// the array is the index of the modifier as used in the modifiers
/// bitmask in the keysym event.
///
class ZwpTextInputV1ModifiersMapEvent {
  ///
  final List<int> map;

  ZwpTextInputV1ModifiersMapEvent(
    this.map,
  );

  @override
  toString() {
    return "ZwpTextInputV1ModifiersMapEvent (map: $map)";
  }
}

typedef ZwpTextInputV1ModifiersMapEventHandler = void Function(
    ZwpTextInputV1ModifiersMapEvent);

/// state of the input panel
///
/// Notify when the visibility state of the input panel changed.
///
class ZwpTextInputV1InputPanelStateEvent {
  ///
  final int state;

  ZwpTextInputV1InputPanelStateEvent(
    this.state,
  );

  @override
  toString() {
    return "ZwpTextInputV1InputPanelStateEvent (state: $state)";
  }
}

typedef ZwpTextInputV1InputPanelStateEventHandler = void Function(
    ZwpTextInputV1InputPanelStateEvent);

/// pre-edit
///
/// Notify when a new composing text (pre-edit) should be set around the
/// current cursor position. Any previously set composing text should
/// be removed.
///
/// The commit text can be used to replace the preedit text on reset
/// (for example on unfocus).
///
/// The text input should also handle all preedit_style and preedit_cursor
/// events occurring directly before preedit_string.
///
class ZwpTextInputV1PreeditStringEvent {
  /// serial of the latest known text input state
  final int serial;

  ///
  final String text;

  ///
  final String commit;

  ZwpTextInputV1PreeditStringEvent(
    this.serial,
    this.text,
    this.commit,
  );

  @override
  toString() {
    return "ZwpTextInputV1PreeditStringEvent (serial: $serial, text: $text, commit: $commit)";
  }
}

typedef ZwpTextInputV1PreeditStringEventHandler = void Function(
    ZwpTextInputV1PreeditStringEvent);

/// pre-edit styling
///
/// Sets styling information on composing text. The style is applied for
/// length bytes from index relative to the beginning of the composing
/// text (as byte offset). Multiple styles can
/// be applied to a composing text by sending multiple preedit_styling
/// events.
///
/// This event is handled as part of a following preedit_string event.
///
class ZwpTextInputV1PreeditStylingEvent {
  ///
  final int index;

  ///
  final int length;

  ///
  final int style;

  ZwpTextInputV1PreeditStylingEvent(
    this.index,
    this.length,
    this.style,
  );

  @override
  toString() {
    return "ZwpTextInputV1PreeditStylingEvent (index: $index, length: $length, style: $style)";
  }
}

typedef ZwpTextInputV1PreeditStylingEventHandler = void Function(
    ZwpTextInputV1PreeditStylingEvent);

/// pre-edit cursor
///
/// Sets the cursor position inside the composing text (as byte
/// offset) relative to the start of the composing text. When index is a
/// negative number no cursor is shown.
///
/// This event is handled as part of a following preedit_string event.
///
class ZwpTextInputV1PreeditCursorEvent {
  ///
  final int index;

  ZwpTextInputV1PreeditCursorEvent(
    this.index,
  );

  @override
  toString() {
    return "ZwpTextInputV1PreeditCursorEvent (index: $index)";
  }
}

typedef ZwpTextInputV1PreeditCursorEventHandler = void Function(
    ZwpTextInputV1PreeditCursorEvent);

/// commit
///
/// Notify when text should be inserted into the editor widget. The text to
/// commit could be either just a single character after a key press or the
/// result of some composing (pre-edit). It could also be an empty text
/// when some text should be removed (see delete_surrounding_text) or when
/// the input cursor should be moved (see cursor_position).
///
/// Any previously set composing text should be removed.
///
class ZwpTextInputV1CommitStringEvent {
  /// serial of the latest known text input state
  final int serial;

  ///
  final String text;

  ZwpTextInputV1CommitStringEvent(
    this.serial,
    this.text,
  );

  @override
  toString() {
    return "ZwpTextInputV1CommitStringEvent (serial: $serial, text: $text)";
  }
}

typedef ZwpTextInputV1CommitStringEventHandler = void Function(
    ZwpTextInputV1CommitStringEvent);

/// set cursor to new position
///
/// Notify when the cursor or anchor position should be modified.
///
/// This event should be handled as part of a following commit_string
/// event.
///
class ZwpTextInputV1CursorPositionEvent {
  ///
  final int index;

  ///
  final int anchor;

  ZwpTextInputV1CursorPositionEvent(
    this.index,
    this.anchor,
  );

  @override
  toString() {
    return "ZwpTextInputV1CursorPositionEvent (index: $index, anchor: $anchor)";
  }
}

typedef ZwpTextInputV1CursorPositionEventHandler = void Function(
    ZwpTextInputV1CursorPositionEvent);

/// delete surrounding text
///
/// Notify when the text around the current cursor position should be
/// deleted.
///
/// Index is relative to the current cursor (in bytes).
/// Length is the length of deleted text (in bytes).
///
/// This event should be handled as part of a following commit_string
/// event.
///
class ZwpTextInputV1DeleteSurroundingTextEvent {
  ///
  final int index;

  ///
  final int length;

  ZwpTextInputV1DeleteSurroundingTextEvent(
    this.index,
    this.length,
  );

  @override
  toString() {
    return "ZwpTextInputV1DeleteSurroundingTextEvent (index: $index, length: $length)";
  }
}

typedef ZwpTextInputV1DeleteSurroundingTextEventHandler = void Function(
    ZwpTextInputV1DeleteSurroundingTextEvent);

/// keysym
///
/// Notify when a key event was sent. Key events should not be used
/// for normal text input operations, which should be done with
/// commit_string, delete_surrounding_text, etc. The key event follows
/// the wl_keyboard key event convention. Sym is an XKB keysym, state a
/// wl_keyboard key_state. Modifiers are a mask for effective modifiers
/// (where the modifier indices are set by the modifiers_map event)
///
class ZwpTextInputV1KeysymEvent {
  /// serial of the latest known text input state
  final int serial;

  ///
  final int time;

  ///
  final int sym;

  ///
  final int state;

  ///
  final int modifiers;

  ZwpTextInputV1KeysymEvent(
    this.serial,
    this.time,
    this.sym,
    this.state,
    this.modifiers,
  );

  @override
  toString() {
    return "ZwpTextInputV1KeysymEvent (serial: $serial, time: $time, sym: $sym, state: $state, modifiers: $modifiers)";
  }
}

typedef ZwpTextInputV1KeysymEventHandler = void Function(
    ZwpTextInputV1KeysymEvent);

/// language
///
/// Sets the language of the input text. The "language" argument is an
/// RFC-3066 format language tag.
///
class ZwpTextInputV1LanguageEvent {
  /// serial of the latest known text input state
  final int serial;

  ///
  final String language;

  ZwpTextInputV1LanguageEvent(
    this.serial,
    this.language,
  );

  @override
  toString() {
    return "ZwpTextInputV1LanguageEvent (serial: $serial, language: $language)";
  }
}

typedef ZwpTextInputV1LanguageEventHandler = void Function(
    ZwpTextInputV1LanguageEvent);

/// text direction
///
/// Sets the text direction of input text.
///
/// It is mainly needed for showing an input cursor on the correct side of
/// the editor when there is no input done yet and making sure neutral
/// direction text is laid out properly.
///
class ZwpTextInputV1TextDirectionEvent {
  /// serial of the latest known text input state
  final int serial;

  ///
  final int direction;

  ZwpTextInputV1TextDirectionEvent(
    this.serial,
    this.direction,
  );

  @override
  toString() {
    return "ZwpTextInputV1TextDirectionEvent (serial: $serial, direction: $direction)";
  }
}

typedef ZwpTextInputV1TextDirectionEventHandler = void Function(
    ZwpTextInputV1TextDirectionEvent);

/// text input
///
/// An object used for text input. Adds support for text input and input
/// methods to applications. A text_input object is created from a
/// wl_text_input_manager and corresponds typically to a text entry in an
/// application.
///
/// Requests are used to activate/deactivate the text_input object and set
/// state information like surrounding and selected text or the content type.
/// The information about entered text is sent to the text_input object via
/// the pre-edit and commit events. Using this interface removes the need
/// for applications to directly process hardware key events and compose text
/// out of them.
///
/// Text is generally UTF-8 encoded, indices and lengths are in bytes.
///
/// Serials are used to synchronize the state between the text input and
/// an input method. New serials are sent by the text input in the
/// commit_state request and are used by the input method to indicate
/// the known text input state in events like preedit_string, commit_string,
/// and keysym. The text input can then ignore events from the input method
/// which are based on an outdated state (for example after a reset).
///
/// Warning! The protocol described in this file is experimental and
/// backward incompatible changes may be made. Backward compatible changes
/// may be added together with the corresponding interface version bump.
/// Backward incompatible changes are done by bumping the version number in
/// the protocol and interface names and resetting the interface version.
/// Once the protocol is to be declared stable, the 'z' prefix and the
/// version number in the protocol and interface names are removed and the
/// interface version number is reset.
///
class ZwpTextInputV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTextInputV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTextInputV1 {name: 'zwp_text_input_v1', id: '$objectId', version: '1',}";
  }

  /// request activation
  ///
  /// Requests the text_input object to be activated (typically when the
  /// text entry gets focus).
  ///
  /// The seat argument is a wl_seat which maintains the focus for this
  /// activation. The surface argument is a wl_surface assigned to the
  /// text_input object and tracked for focus lost. The enter event
  /// is emitted on successful activation.
  ///
  /// [seat]:
  /// [surface]:
  Result<void, Object> activate(Seat seat, Surface surface) {
    logLn("ZwpTextInputV1::activate  seat: $seat surface: $surface");
    var arguments = [seat, surface];
    var argTypes = <WaylandType>[WaylandType.object, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::activate: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// request deactivation
  ///
  /// Requests the text_input object to be deactivated (typically when the
  /// text entry lost focus). The seat argument is a wl_seat which was used
  /// for activation.
  ///
  /// [seat]:
  Result<void, Object> deactivate(Seat seat) {
    logLn("ZwpTextInputV1::deactivate  seat: $seat");
    var arguments = [seat];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::deactivate: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// show input panels
  ///
  /// Requests input panels (virtual keyboard) to show.
  ///
  Result<void, Object> showInputPanel() {
    logLn("ZwpTextInputV1::showInputPanel ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::showInputPanel: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// hide input panels
  ///
  /// Requests input panels (virtual keyboard) to hide.
  ///
  Result<void, Object> hideInputPanel() {
    logLn("ZwpTextInputV1::hideInputPanel ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::hideInputPanel: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// reset
  ///
  /// Should be called by an editor widget when the input state should be
  /// reset, for example after the text was changed outside of the normal
  /// input method flow.
  ///
  Result<void, Object> reset() {
    logLn("ZwpTextInputV1::reset ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 4])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::reset: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// sets the surrounding text
  ///
  /// Sets the plain surrounding text around the input position. Text is
  /// UTF-8 encoded. Cursor is the byte offset within the
  /// surrounding text. Anchor is the byte offset of the
  /// selection anchor within the surrounding text. If there is no selected
  /// text anchor, then it is the same as cursor.
  ///
  /// [text]:
  /// [cursor]:
  /// [anchor]:
  Result<void, Object> setSurroundingText(String text, int cursor, int anchor) {
    logLn(
        "ZwpTextInputV1::setSurroundingText  text: $text cursor: $cursor anchor: $anchor");
    var arguments = [text, cursor, anchor];
    var argTypes = <WaylandType>[
      WaylandType.string,
      WaylandType.uint,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 5])
            .buffer
            .asUint8List());
    final textBytes = utf8.encode(text);
    bytesBuilder
        .add(Uint32List.fromList([textBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(textBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    bytesBuilder.add(Uint32List.fromList([cursor]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([anchor]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::setSurroundingText: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set content purpose and hint
  ///
  /// Sets the content purpose and content hint. While the purpose is the
  /// basic purpose of an input field, the hint flags allow to modify some
  /// of the behavior.
  ///
  /// When no content type is explicitly set, a normal content purpose with
  /// default hints (auto completion, auto correction, auto capitalization)
  /// should be assumed.
  ///
  /// [hint]:
  /// [purpose]:
  Result<void, Object> setContentType(int hint, int purpose) {
    logLn("ZwpTextInputV1::setContentType  hint: $hint purpose: $purpose");
    var arguments = [hint, purpose];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 6])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([hint]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([purpose]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::setContentType: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  ///
  ///
  /// [x]:
  /// [y]:
  /// [width]:
  /// [height]:
  Result<void, Object> setCursorRectangle(int x, int y, int width, int height) {
    logLn(
        "ZwpTextInputV1::setCursorRectangle  x: $x y: $y width: $width height: $height");
    var arguments = [x, y, width, height];
    var argTypes = <WaylandType>[
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 7])
            .buffer
            .asUint8List());
    bytesBuilder.add(Int32List.fromList([x]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([y]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([width]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([height]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::setCursorRectangle: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// sets preferred language
  ///
  /// Sets a specific language. This allows for example a virtual keyboard to
  /// show a language specific layout. The "language" argument is an RFC-3066
  /// format language tag.
  ///
  /// It could be used for example in a word processor to indicate the
  /// language of the currently edited document or in an instant message
  /// application which tracks languages of contacts.
  ///
  /// [language]:
  Result<void, Object> setPreferredLanguage(String language) {
    logLn("ZwpTextInputV1::setPreferredLanguage  language: $language");
    var arguments = [language];
    var argTypes = <WaylandType>[WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 8])
            .buffer
            .asUint8List());
    final languageBytes = utf8.encode(language);
    bytesBuilder.add(
        Uint32List.fromList([languageBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(languageBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::setPreferredLanguage: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  ///
  ///
  /// [serial]: used to identify the known state
  Result<void, Object> commitState(int serial) {
    logLn("ZwpTextInputV1::commitState  serial: $serial");
    var arguments = [serial];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 9])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::commitState: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  ///
  ///
  /// [button]:
  /// [index]:
  Result<void, Object> invokeAction(int button, int index) {
    logLn("ZwpTextInputV1::invokeAction  button: $button index: $index");
    var arguments = [button, index];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 10])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([button]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([index]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV1::invokeAction: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// enter event
  ///
  /// Notify the text_input object when it received focus. Typically in
  /// response to an activate request.
  ///
  /// Event handler for Enter
  /// - [surface]:
  void onEnter(ZwpTextInputV1EnterEventHandler handler) {
    _enterHandler = handler;
  }

  ZwpTextInputV1EnterEventHandler? _enterHandler;

  /// leave event
  ///
  /// Notify the text_input object when it lost focus. Either in response
  /// to a deactivate request or when the assigned surface lost focus or was
  /// destroyed.
  ///
  /// Event handler for Leave
  void onLeave(ZwpTextInputV1LeaveEventHandler handler) {
    _leaveHandler = handler;
  }

  ZwpTextInputV1LeaveEventHandler? _leaveHandler;

  /// modifiers map
  ///
  /// Transfer an array of 0-terminated modifier names. The position in
  /// the array is the index of the modifier as used in the modifiers
  /// bitmask in the keysym event.
  ///
  /// Event handler for ModifiersMap
  /// - [map]:
  void onModifiersMap(ZwpTextInputV1ModifiersMapEventHandler handler) {
    _modifiersMapHandler = handler;
  }

  ZwpTextInputV1ModifiersMapEventHandler? _modifiersMapHandler;

  /// state of the input panel
  ///
  /// Notify when the visibility state of the input panel changed.
  ///
  /// Event handler for InputPanelState
  /// - [state]:
  void onInputPanelState(ZwpTextInputV1InputPanelStateEventHandler handler) {
    _inputPanelStateHandler = handler;
  }

  ZwpTextInputV1InputPanelStateEventHandler? _inputPanelStateHandler;

  /// pre-edit
  ///
  /// Notify when a new composing text (pre-edit) should be set around the
  /// current cursor position. Any previously set composing text should
  /// be removed.
  ///
  /// The commit text can be used to replace the preedit text on reset
  /// (for example on unfocus).
  ///
  /// The text input should also handle all preedit_style and preedit_cursor
  /// events occurring directly before preedit_string.
  ///
  /// Event handler for PreeditString
  /// - [serial]: serial of the latest known text input state
  /// - [text]:
  /// - [commit]:
  void onPreeditString(ZwpTextInputV1PreeditStringEventHandler handler) {
    _preeditStringHandler = handler;
  }

  ZwpTextInputV1PreeditStringEventHandler? _preeditStringHandler;

  /// pre-edit styling
  ///
  /// Sets styling information on composing text. The style is applied for
  /// length bytes from index relative to the beginning of the composing
  /// text (as byte offset). Multiple styles can
  /// be applied to a composing text by sending multiple preedit_styling
  /// events.
  ///
  /// This event is handled as part of a following preedit_string event.
  ///
  /// Event handler for PreeditStyling
  /// - [index]:
  /// - [length]:
  /// - [style]:
  void onPreeditStyling(ZwpTextInputV1PreeditStylingEventHandler handler) {
    _preeditStylingHandler = handler;
  }

  ZwpTextInputV1PreeditStylingEventHandler? _preeditStylingHandler;

  /// pre-edit cursor
  ///
  /// Sets the cursor position inside the composing text (as byte
  /// offset) relative to the start of the composing text. When index is a
  /// negative number no cursor is shown.
  ///
  /// This event is handled as part of a following preedit_string event.
  ///
  /// Event handler for PreeditCursor
  /// - [index]:
  void onPreeditCursor(ZwpTextInputV1PreeditCursorEventHandler handler) {
    _preeditCursorHandler = handler;
  }

  ZwpTextInputV1PreeditCursorEventHandler? _preeditCursorHandler;

  /// commit
  ///
  /// Notify when text should be inserted into the editor widget. The text to
  /// commit could be either just a single character after a key press or the
  /// result of some composing (pre-edit). It could also be an empty text
  /// when some text should be removed (see delete_surrounding_text) or when
  /// the input cursor should be moved (see cursor_position).
  ///
  /// Any previously set composing text should be removed.
  ///
  /// Event handler for CommitString
  /// - [serial]: serial of the latest known text input state
  /// - [text]:
  void onCommitString(ZwpTextInputV1CommitStringEventHandler handler) {
    _commitStringHandler = handler;
  }

  ZwpTextInputV1CommitStringEventHandler? _commitStringHandler;

  /// set cursor to new position
  ///
  /// Notify when the cursor or anchor position should be modified.
  ///
  /// This event should be handled as part of a following commit_string
  /// event.
  ///
  /// Event handler for CursorPosition
  /// - [index]:
  /// - [anchor]:
  void onCursorPosition(ZwpTextInputV1CursorPositionEventHandler handler) {
    _cursorPositionHandler = handler;
  }

  ZwpTextInputV1CursorPositionEventHandler? _cursorPositionHandler;

  /// delete surrounding text
  ///
  /// Notify when the text around the current cursor position should be
  /// deleted.
  ///
  /// Index is relative to the current cursor (in bytes).
  /// Length is the length of deleted text (in bytes).
  ///
  /// This event should be handled as part of a following commit_string
  /// event.
  ///
  /// Event handler for DeleteSurroundingText
  /// - [index]:
  /// - [length]:
  void onDeleteSurroundingText(
      ZwpTextInputV1DeleteSurroundingTextEventHandler handler) {
    _deleteSurroundingTextHandler = handler;
  }

  ZwpTextInputV1DeleteSurroundingTextEventHandler?
      _deleteSurroundingTextHandler;

  /// keysym
  ///
  /// Notify when a key event was sent. Key events should not be used
  /// for normal text input operations, which should be done with
  /// commit_string, delete_surrounding_text, etc. The key event follows
  /// the wl_keyboard key event convention. Sym is an XKB keysym, state a
  /// wl_keyboard key_state. Modifiers are a mask for effective modifiers
  /// (where the modifier indices are set by the modifiers_map event)
  ///
  /// Event handler for Keysym
  /// - [serial]: serial of the latest known text input state
  /// - [time]:
  /// - [sym]:
  /// - [state]:
  /// - [modifiers]:
  void onKeysym(ZwpTextInputV1KeysymEventHandler handler) {
    _keysymHandler = handler;
  }

  ZwpTextInputV1KeysymEventHandler? _keysymHandler;

  /// language
  ///
  /// Sets the language of the input text. The "language" argument is an
  /// RFC-3066 format language tag.
  ///
  /// Event handler for Language
  /// - [serial]: serial of the latest known text input state
  /// - [language]:
  void onLanguage(ZwpTextInputV1LanguageEventHandler handler) {
    _languageHandler = handler;
  }

  ZwpTextInputV1LanguageEventHandler? _languageHandler;

  /// text direction
  ///
  /// Sets the text direction of input text.
  ///
  /// It is mainly needed for showing an input cursor on the correct side of
  /// the editor when there is no input done yet and making sure neutral
  /// direction text is laid out properly.
  ///
  /// Event handler for TextDirection
  /// - [serial]: serial of the latest known text input state
  /// - [direction]:
  void onTextDirection(ZwpTextInputV1TextDirectionEventHandler handler) {
    _textDirectionHandler = handler;
  }

  ZwpTextInputV1TextDirectionEventHandler? _textDirectionHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTextInputV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_enterHandler != null) {
          var offset = 0;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTextInputV1EnterEvent(
            surface,
          );
          _enterHandler!(event);
        }
        break;
      case 1:
        if (_leaveHandler != null) {
          _leaveHandler!(ZwpTextInputV1LeaveEvent());
        }
        break;
      case 2:
        if (_modifiersMapHandler != null) {
          var offset = 0;
          final map = getArray(data, offset);
          var arrayLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4 + arrayLength;
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTextInputV1ModifiersMapEvent(
            map,
          );
          _modifiersMapHandler!(event);
        }
        break;
      case 3:
        if (_inputPanelStateHandler != null) {
          var offset = 0;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1InputPanelStateEvent(
            state,
          );
          _inputPanelStateHandler!(event);
        }
        break;
      case 4:
        if (_preeditStringHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final textLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final text =
              utf8.decode(data.sublist(offset, offset + textLength - 1));
          offset += textLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          final commitLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final commit =
              utf8.decode(data.sublist(offset, offset + commitLength - 1));
          offset += commitLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTextInputV1PreeditStringEvent(
            serial,
            text,
            commit,
          );
          _preeditStringHandler!(event);
        }
        break;
      case 5:
        if (_preeditStylingHandler != null) {
          var offset = 0;
          final index =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final length =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final style =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1PreeditStylingEvent(
            index,
            length,
            style,
          );
          _preeditStylingHandler!(event);
        }
        break;
      case 6:
        if (_preeditCursorHandler != null) {
          var offset = 0;
          final index =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1PreeditCursorEvent(
            index,
          );
          _preeditCursorHandler!(event);
        }
        break;
      case 7:
        if (_commitStringHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final textLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final text =
              utf8.decode(data.sublist(offset, offset + textLength - 1));
          offset += textLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTextInputV1CommitStringEvent(
            serial,
            text,
          );
          _commitStringHandler!(event);
        }
        break;
      case 8:
        if (_cursorPositionHandler != null) {
          var offset = 0;
          final index =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final anchor =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1CursorPositionEvent(
            index,
            anchor,
          );
          _cursorPositionHandler!(event);
        }
        break;
      case 9:
        if (_deleteSurroundingTextHandler != null) {
          var offset = 0;
          final index =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final length =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1DeleteSurroundingTextEvent(
            index,
            length,
          );
          _deleteSurroundingTextHandler!(event);
        }
        break;
      case 10:
        if (_keysymHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final time =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final sym =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final modifiers =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1KeysymEvent(
            serial,
            time,
            sym,
            state,
            modifiers,
          );
          _keysymHandler!(event);
        }
        break;
      case 11:
        if (_languageHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final languageLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final language =
              utf8.decode(data.sublist(offset, offset + languageLength - 1));
          offset += languageLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTextInputV1LanguageEvent(
            serial,
            language,
          );
          _languageHandler!(event);
        }
        break;
      case 12:
        if (_textDirectionHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final direction =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV1TextDirectionEvent(
            serial,
            direction,
          );
          _textDirectionHandler!(event);
        }
        break;
    }
  }
}

/// content hint
///
/// Content hint is a bitmask to allow to modify the behavior of the text
/// input.
///

enum ZwpTextInputV1ContentHint {
  /// no special behaviour
  none("none", 0x0),

  /// auto completion, correction and capitalization
  defaulted("default", 0x7),

  /// hidden and sensitive text
  password("password", 0xc0),

  /// suggest word completions
  autoCompletion("auto_completion", 0x1),

  /// suggest word corrections
  autoCorrection("auto_correction", 0x2),

  /// switch to uppercase letters at the start of a sentence
  autoCapitalization("auto_capitalization", 0x4),

  /// prefer lowercase letters
  lowercase("lowercase", 0x8),

  /// prefer uppercase letters
  uppercase("uppercase", 0x10),

  /// prefer casing for titles and headings (can be language dependent)
  titlecase("titlecase", 0x20),

  /// characters should be hidden
  hiddenText("hidden_text", 0x40),

  /// typed text should not be stored
  sensitiveData("sensitive_data", 0x80),

  /// just latin characters should be entered
  latin("latin", 0x100),

  /// the text input is multiline
  multiline("multiline", 0x200);

  const ZwpTextInputV1ContentHint(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV1ContentHint {name: $enumName, value: $enumValue}";
  }
}

/// content purpose
///
/// The content purpose allows to specify the primary purpose of a text
/// input.
///
/// This allows an input method to show special purpose input panels with
/// extra characters or to disallow some characters.
///

enum ZwpTextInputV1ContentPurpose {
  /// default input, allowing all characters
  normal("normal", 0),

  /// allow only alphabetic characters
  alpha("alpha", 1),

  /// allow only digits
  digits("digits", 2),

  /// input a number (including decimal separator and sign)
  number("number", 3),

  /// input a phone number
  phone("phone", 4),

  /// input an URL
  url("url", 5),

  /// input an email address
  email("email", 6),

  /// input a name of a person
  name("name", 7),

  /// input a password (combine with password or sensitive_data hint)
  password("password", 8),

  /// input a date
  date("date", 9),

  /// input a time
  time("time", 10),

  /// input a date and time
  datetime("datetime", 11),

  /// input for a terminal
  terminal("terminal", 12);

  const ZwpTextInputV1ContentPurpose(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV1ContentPurpose {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ZwpTextInputV1PreeditStyle {
  /// default style for composing text
  defaulted("default", 0),

  /// style should be the same as in non-composing text
  none("none", 1),

  ///
  active("active", 2),

  ///
  inactive("inactive", 3),

  ///
  highlight("highlight", 4),

  ///
  underline("underline", 5),

  ///
  selection("selection", 6),

  ///
  incorrect("incorrect", 7);

  const ZwpTextInputV1PreeditStyle(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV1PreeditStyle {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ZwpTextInputV1TextDirection {
  /// automatic text direction based on text and language
  auto("auto", 0),

  /// left-to-right
  ltr("ltr", 1),

  /// right-to-left
  rtl("rtl", 2);

  const ZwpTextInputV1TextDirection(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV1TextDirection {name: $enumName, value: $enumValue}";
  }
}

/// text input manager
///
/// A factory for text_input objects. This object is a global singleton.
///
class ZwpTextInputManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZwpTextInputManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTextInputManagerV1 {name: 'zwp_text_input_manager_v1', id: '$objectId', version: '1',}";
  }

  /// create text input
  ///
  /// Creates a new text_input object.
  ///
  /// [id]:
  Result<ZwpTextInputV1, Object> createTextInput() {
    var id = ZwpTextInputV1(innerContext);
    logLn("ZwpTextInputManagerV1::createTextInput  id: $id");
    var arguments = [id];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputManagerV1::createTextInput: $e");
      return Failure(e);
    }
    return Success(id);
  }
}
