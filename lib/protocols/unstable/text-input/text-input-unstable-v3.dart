// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/text-input/text-input-unstable-v3.xml
//
// text_input_unstable_v3 Protocol Copyright:
///
/// Copyright © 2012, 2013 Intel Corporation
/// Copyright © 2015, 2016 Jan Arne Petersen
/// Copyright © 2017, 2018 Red Hat, Inc.
/// Copyright © 2018       Purism SPC
///
/// Permission to use, copy, modify, distribute, and sell this
/// software and its documentation for any purpose is hereby granted
/// without fee, provided that the above copyright notice appear in
/// all copies and that both that copyright notice and this permission
/// notice appear in supporting documentation, and that the name of
/// the copyright holders not be used in advertising or publicity
/// pertaining to distribution of the software without specific,
/// written prior permission.  The copyright holders make no
/// representations about the suitability of this software for any
/// purpose.  It is provided "as is" without express or implied
/// warranty.
///
/// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
/// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
/// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
/// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
/// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
/// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
/// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
/// THIS SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// enter event
///
/// Notification that this seat's text-input focus is on a certain surface.
///
/// If client has created multiple text input objects, compositor must send
/// this event to all of them.
///
/// When the seat has the keyboard capability the text-input focus follows
/// the keyboard focus. This event sets the current surface for the
/// text-input object.
///
class ZwpTextInputV3EnterEvent {
  ///
  final int surface;

  ZwpTextInputV3EnterEvent(
    this.surface,
  );

  @override
  toString() {
    return "ZwpTextInputV3EnterEvent (surface: $surface)";
  }
}

typedef ZwpTextInputV3EnterEventHandler = void Function(
    ZwpTextInputV3EnterEvent);

/// leave event
///
/// Notification that this seat's text-input focus is no longer on a
/// certain surface. The client should reset any preedit string previously
/// set.
///
/// The leave notification clears the current surface. It is sent before
/// the enter notification for the new focus. After leave event, compositor
/// must ignore requests from any text input instances until next enter
/// event.
///
/// When the seat has the keyboard capability the text-input focus follows
/// the keyboard focus.
///
class ZwpTextInputV3LeaveEvent {
  ///
  final int surface;

  ZwpTextInputV3LeaveEvent(
    this.surface,
  );

  @override
  toString() {
    return "ZwpTextInputV3LeaveEvent (surface: $surface)";
  }
}

typedef ZwpTextInputV3LeaveEventHandler = void Function(
    ZwpTextInputV3LeaveEvent);

/// pre-edit
///
/// Notify when a new composing text (pre-edit) should be set at the
/// current cursor position. Any previously set composing text must be
/// removed. Any previously existing selected text must be removed.
///
/// The argument text contains the pre-edit string buffer.
///
/// The parameters cursor_begin and cursor_end are counted in bytes
/// relative to the beginning of the submitted text buffer. Cursor should
/// be hidden when both are equal to -1.
///
/// They could be represented by the client as a line if both values are
/// the same, or as a text highlight otherwise.
///
/// Values set with this event are double-buffered. They must be applied
/// and reset to initial on the next zwp_text_input_v3.done event.
///
/// The initial value of text is an empty string, and cursor_begin,
/// cursor_end and cursor_hidden are all 0.
///
class ZwpTextInputV3PreeditStringEvent {
  ///
  final String text;

  ///
  final int cursorBegin;

  ///
  final int cursorEnd;

  ZwpTextInputV3PreeditStringEvent(
    this.text,
    this.cursorBegin,
    this.cursorEnd,
  );

  @override
  toString() {
    return "ZwpTextInputV3PreeditStringEvent (text: $text, cursorBegin: $cursorBegin, cursorEnd: $cursorEnd)";
  }
}

typedef ZwpTextInputV3PreeditStringEventHandler = void Function(
    ZwpTextInputV3PreeditStringEvent);

/// text commit
///
/// Notify when text should be inserted into the editor widget. The text to
/// commit could be either just a single character after a key press or the
/// result of some composing (pre-edit).
///
/// Values set with this event are double-buffered. They must be applied
/// and reset to initial on the next zwp_text_input_v3.done event.
///
/// The initial value of text is an empty string.
///
class ZwpTextInputV3CommitStringEvent {
  ///
  final String text;

  ZwpTextInputV3CommitStringEvent(
    this.text,
  );

  @override
  toString() {
    return "ZwpTextInputV3CommitStringEvent (text: $text)";
  }
}

typedef ZwpTextInputV3CommitStringEventHandler = void Function(
    ZwpTextInputV3CommitStringEvent);

/// delete surrounding text
///
/// Notify when the text around the current cursor position should be
/// deleted.
///
/// Before_length and after_length are the number of bytes before and after
/// the current cursor index (excluding the selection) to delete.
///
/// If a preedit text is present, in effect before_length is counted from
/// the beginning of it, and after_length from its end (see done event
/// sequence).
///
/// Values set with this event are double-buffered. They must be applied
/// and reset to initial on the next zwp_text_input_v3.done event.
///
/// The initial values of both before_length and after_length are 0.
///
class ZwpTextInputV3DeleteSurroundingTextEvent {
  /// length of text before current cursor position
  final int beforeLength;

  /// length of text after current cursor position
  final int afterLength;

  ZwpTextInputV3DeleteSurroundingTextEvent(
    this.beforeLength,
    this.afterLength,
  );

  @override
  toString() {
    return "ZwpTextInputV3DeleteSurroundingTextEvent (beforeLength: $beforeLength, afterLength: $afterLength)";
  }
}

typedef ZwpTextInputV3DeleteSurroundingTextEventHandler = void Function(
    ZwpTextInputV3DeleteSurroundingTextEvent);

/// apply changes
///
/// Instruct the application to apply changes to state requested by the
/// preedit_string, commit_string and delete_surrounding_text events. The
/// state relating to these events is double-buffered, and each one
/// modifies the pending state. This event replaces the current state with
/// the pending state.
///
/// The application must proceed by evaluating the changes in the following
/// order:
///
/// 1. Replace existing preedit string with the cursor.
/// 2. Delete requested surrounding text.
/// 3. Insert commit string with the cursor at its end.
/// 4. Calculate surrounding text to send.
/// 5. Insert new preedit text in cursor position.
/// 6. Place cursor inside preedit text.
///
/// The serial number reflects the last state of the zwp_text_input_v3
/// object known to the compositor. The value of the serial argument must
/// be equal to the number of commit requests already issued on that object.
///
/// When the client receives a done event with a serial different than the
/// number of past commit requests, it must proceed with evaluating and
/// applying the changes as normal, except it should not change the current
/// state of the zwp_text_input_v3 object. All pending state requests
/// (set_surrounding_text, set_content_type and set_cursor_rectangle) on
/// the zwp_text_input_v3 object should be sent and committed after
/// receiving a zwp_text_input_v3.done event with a matching serial.
///
class ZwpTextInputV3DoneEvent {
  ///
  final int serial;

  ZwpTextInputV3DoneEvent(
    this.serial,
  );

  @override
  toString() {
    return "ZwpTextInputV3DoneEvent (serial: $serial)";
  }
}

typedef ZwpTextInputV3DoneEventHandler = void Function(ZwpTextInputV3DoneEvent);

/// text input
///
/// The zwp_text_input_v3 interface represents text input and input methods
/// associated with a seat. It provides enter/leave events to follow the
/// text input focus for a seat.
///
/// Requests are used to enable/disable the text-input object and set
/// state information like surrounding and selected text or the content type.
/// The information about the entered text is sent to the text-input object
/// via the preedit_string and commit_string events.
///
/// Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
/// must not point to middle bytes inside a code point: they must either
/// point to the first byte of a code point or to the end of the buffer.
/// Lengths must be measured between two valid indices.
///
/// Focus moving throughout surfaces will result in the emission of
/// zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
/// surface must commit zwp_text_input_v3.enable and
/// zwp_text_input_v3.disable requests as the keyboard focus moves across
/// editable and non-editable elements of the UI. Those two requests are not
/// expected to be paired with each other, the compositor must be able to
/// handle consecutive series of the same request.
///
/// State is sent by the state requests (set_surrounding_text,
/// set_content_type and set_cursor_rectangle) and a commit request. After an
/// enter event or disable request all state information is invalidated and
/// needs to be resent by the client.
///
class ZwpTextInputV3 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpTextInputV3(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTextInputV3 {name: 'zwp_text_input_v3', id: '$objectId', version: '1',}";
  }

  /// Destroy the wp_text_input
  ///
  /// Destroy the wp_text_input object. Also disables all surfaces enabled
  /// through this wp_text_input object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTextInputV3::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// Request text input to be enabled
  ///
  /// Requests text input on the surface previously obtained from the enter
  /// event.
  ///
  /// This request must be issued every time the active text input changes
  /// to a new one, including within the current surface. Use
  /// zwp_text_input_v3.disable when there is no longer any input focus on
  /// the current surface.
  ///
  /// Clients must not enable more than one text input on the single seat
  /// and should disable the current text input before enabling the new one.
  /// At most one instance of text input may be in enabled state per instance,
  /// Requests to enable the another text input when some text input is active
  /// must be ignored by compositor.
  ///
  /// This request resets all state associated with previous enable, disable,
  /// set_surrounding_text, set_text_change_cause, set_content_type, and
  /// set_cursor_rectangle requests, as well as the state associated with
  /// preedit_string, commit_string, and delete_surrounding_text events.
  ///
  /// The set_surrounding_text, set_content_type and set_cursor_rectangle
  /// requests must follow if the text input supports the necessary
  /// functionality.
  ///
  /// State set with this request is double-buffered. It will get applied on
  /// the next zwp_text_input_v3.commit request, and stay valid until the
  /// next committed enable or disable request.
  ///
  /// The changes must be applied by the compositor after issuing a
  /// zwp_text_input_v3.commit request.
  ///
  Result<void, Object> enable() {
    logLn("ZwpTextInputV3::enable ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::enable: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// Disable text input on a surface
  ///
  /// Explicitly disable text input on the current surface (typically when
  /// there is no focus on any text entry inside the surface).
  ///
  /// State set with this request is double-buffered. It will get applied on
  /// the next zwp_text_input_v3.commit request.
  ///
  Result<void, Object> disable() {
    logLn("ZwpTextInputV3::disable ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::disable: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// sets the surrounding text
  ///
  /// Sets the surrounding plain text around the input, excluding the preedit
  /// text.
  ///
  /// The client should notify the compositor of any changes in any of the
  /// values carried with this request, including changes caused by handling
  /// incoming text-input events as well as changes caused by other
  /// mechanisms like keyboard typing.
  ///
  /// If the client is unaware of the text around the cursor, it should not
  /// issue this request, to signify lack of support to the compositor.
  ///
  /// Text is UTF-8 encoded, and should include the cursor position, the
  /// complete selection and additional characters before and after them.
  /// There is a maximum length of wayland messages, so text can not be
  /// longer than 4000 bytes.
  ///
  /// Cursor is the byte offset of the cursor within text buffer.
  ///
  /// Anchor is the byte offset of the selection anchor within text buffer.
  /// If there is no selected text, anchor is the same as cursor.
  ///
  /// If any preedit text is present, it is replaced with a cursor for the
  /// purpose of this event.
  ///
  /// Values set with this request are double-buffered. They will get applied
  /// on the next zwp_text_input_v3.commit request, and stay valid until the
  /// next committed enable or disable request.
  ///
  /// The initial state for affected fields is empty, meaning that the text
  /// input does not support sending surrounding text. If the empty values
  /// get applied, subsequent attempts to change them may have no effect.
  ///
  /// [text]:
  /// [cursor]:
  /// [anchor]:
  Result<void, Object> setSurroundingText(String text, int cursor, int anchor) {
    logLn(
        "ZwpTextInputV3::setSurroundingText  text: $text cursor: $cursor anchor: $anchor");
    var arguments = [text, cursor, anchor];
    var argTypes = <WaylandType>[
      WaylandType.string,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    final textBytes = utf8.encode(text);
    bytesBuilder
        .add(Uint32List.fromList([textBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(textBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    bytesBuilder.add(Int32List.fromList([cursor]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([anchor]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::setSurroundingText: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// indicates the cause of surrounding text change
  ///
  /// Tells the compositor why the text surrounding the cursor changed.
  ///
  /// Whenever the client detects an external change in text, cursor, or
  /// anchor posision, it must issue this request to the compositor. This
  /// request is intended to give the input method a chance to update the
  /// preedit text in an appropriate way, e.g. by removing it when the user
  /// starts typing with a keyboard.
  ///
  /// cause describes the source of the change.
  ///
  /// The value set with this request is double-buffered. It must be applied
  /// and reset to initial at the next zwp_text_input_v3.commit request.
  ///
  /// The initial value of cause is input_method.
  ///
  /// [cause]:
  Result<void, Object> setTextChangeCause(int cause) {
    logLn("ZwpTextInputV3::setTextChangeCause  cause: $cause");
    var arguments = [cause];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 4])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([cause]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::setTextChangeCause: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set content purpose and hint
  ///
  /// Sets the content purpose and content hint. While the purpose is the
  /// basic purpose of an input field, the hint flags allow to modify some of
  /// the behavior.
  ///
  /// Values set with this request are double-buffered. They will get applied
  /// on the next zwp_text_input_v3.commit request.
  /// Subsequent attempts to update them may have no effect. The values
  /// remain valid until the next committed enable or disable request.
  ///
  /// The initial value for hint is none, and the initial value for purpose
  /// is normal.
  ///
  /// [hint]:
  /// [purpose]:
  Result<void, Object> setContentType(int hint, int purpose) {
    logLn("ZwpTextInputV3::setContentType  hint: $hint purpose: $purpose");
    var arguments = [hint, purpose];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 5])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([hint]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([purpose]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::setContentType: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set cursor position
  ///
  /// Marks an area around the cursor as a x, y, width, height rectangle in
  /// surface local coordinates.
  ///
  /// Allows the compositor to put a window with word suggestions near the
  /// cursor, without obstructing the text being input.
  ///
  /// If the client is unaware of the position of edited text, it should not
  /// issue this request, to signify lack of support to the compositor.
  ///
  /// Values set with this request are double-buffered. They will get applied
  /// on the next zwp_text_input_v3.commit request, and stay valid until the
  /// next committed enable or disable request.
  ///
  /// The initial values describing a cursor rectangle are empty. That means
  /// the text input does not support describing the cursor area. If the
  /// empty values get applied, subsequent attempts to change them may have
  /// no effect.
  ///
  /// [x]:
  /// [y]:
  /// [width]:
  /// [height]:
  Result<void, Object> setCursorRectangle(int x, int y, int width, int height) {
    logLn(
        "ZwpTextInputV3::setCursorRectangle  x: $x y: $y width: $width height: $height");
    var arguments = [x, y, width, height];
    var argTypes = <WaylandType>[
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 6])
            .buffer
            .asUint8List());
    bytesBuilder.add(Int32List.fromList([x]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([y]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([width]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([height]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::setCursorRectangle: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// commit state
  ///
  /// Atomically applies state changes recently sent to the compositor.
  ///
  /// The commit request establishes and updates the state of the client, and
  /// must be issued after any changes to apply them.
  ///
  /// Text input state (enabled status, content purpose, content hint,
  /// surrounding text and change cause, cursor rectangle) is conceptually
  /// double-buffered within the context of a text input, i.e. between a
  /// committed enable request and the following committed enable or disable
  /// request.
  ///
  /// Protocol requests modify the pending state, as opposed to the current
  /// state in use by the input method. A commit request atomically applies
  /// all pending state, replacing the current state. After commit, the new
  /// pending state is as documented for each related request.
  ///
  /// Requests are applied in the order of arrival.
  ///
  /// Neither current nor pending state are modified unless noted otherwise.
  ///
  /// The compositor must count the number of commit requests coming from
  /// each zwp_text_input_v3 object and use the count as the serial in done
  /// events.
  ///
  Result<void, Object> commit() {
    logLn("ZwpTextInputV3::commit ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 7])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputV3::commit: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// enter event
  ///
  /// Notification that this seat's text-input focus is on a certain surface.
  ///
  /// If client has created multiple text input objects, compositor must send
  /// this event to all of them.
  ///
  /// When the seat has the keyboard capability the text-input focus follows
  /// the keyboard focus. This event sets the current surface for the
  /// text-input object.
  ///
  /// Event handler for Enter
  /// - [surface]:
  void onEnter(ZwpTextInputV3EnterEventHandler handler) {
    _enterHandler = handler;
  }

  ZwpTextInputV3EnterEventHandler? _enterHandler;

  /// leave event
  ///
  /// Notification that this seat's text-input focus is no longer on a
  /// certain surface. The client should reset any preedit string previously
  /// set.
  ///
  /// The leave notification clears the current surface. It is sent before
  /// the enter notification for the new focus. After leave event, compositor
  /// must ignore requests from any text input instances until next enter
  /// event.
  ///
  /// When the seat has the keyboard capability the text-input focus follows
  /// the keyboard focus.
  ///
  /// Event handler for Leave
  /// - [surface]:
  void onLeave(ZwpTextInputV3LeaveEventHandler handler) {
    _leaveHandler = handler;
  }

  ZwpTextInputV3LeaveEventHandler? _leaveHandler;

  /// pre-edit
  ///
  /// Notify when a new composing text (pre-edit) should be set at the
  /// current cursor position. Any previously set composing text must be
  /// removed. Any previously existing selected text must be removed.
  ///
  /// The argument text contains the pre-edit string buffer.
  ///
  /// The parameters cursor_begin and cursor_end are counted in bytes
  /// relative to the beginning of the submitted text buffer. Cursor should
  /// be hidden when both are equal to -1.
  ///
  /// They could be represented by the client as a line if both values are
  /// the same, or as a text highlight otherwise.
  ///
  /// Values set with this event are double-buffered. They must be applied
  /// and reset to initial on the next zwp_text_input_v3.done event.
  ///
  /// The initial value of text is an empty string, and cursor_begin,
  /// cursor_end and cursor_hidden are all 0.
  ///
  /// Event handler for PreeditString
  /// - [text]:
  /// - [cursor_begin]:
  /// - [cursor_end]:
  void onPreeditString(ZwpTextInputV3PreeditStringEventHandler handler) {
    _preeditStringHandler = handler;
  }

  ZwpTextInputV3PreeditStringEventHandler? _preeditStringHandler;

  /// text commit
  ///
  /// Notify when text should be inserted into the editor widget. The text to
  /// commit could be either just a single character after a key press or the
  /// result of some composing (pre-edit).
  ///
  /// Values set with this event are double-buffered. They must be applied
  /// and reset to initial on the next zwp_text_input_v3.done event.
  ///
  /// The initial value of text is an empty string.
  ///
  /// Event handler for CommitString
  /// - [text]:
  void onCommitString(ZwpTextInputV3CommitStringEventHandler handler) {
    _commitStringHandler = handler;
  }

  ZwpTextInputV3CommitStringEventHandler? _commitStringHandler;

  /// delete surrounding text
  ///
  /// Notify when the text around the current cursor position should be
  /// deleted.
  ///
  /// Before_length and after_length are the number of bytes before and after
  /// the current cursor index (excluding the selection) to delete.
  ///
  /// If a preedit text is present, in effect before_length is counted from
  /// the beginning of it, and after_length from its end (see done event
  /// sequence).
  ///
  /// Values set with this event are double-buffered. They must be applied
  /// and reset to initial on the next zwp_text_input_v3.done event.
  ///
  /// The initial values of both before_length and after_length are 0.
  ///
  /// Event handler for DeleteSurroundingText
  /// - [before_length]: length of text before current cursor position
  /// - [after_length]: length of text after current cursor position
  void onDeleteSurroundingText(
      ZwpTextInputV3DeleteSurroundingTextEventHandler handler) {
    _deleteSurroundingTextHandler = handler;
  }

  ZwpTextInputV3DeleteSurroundingTextEventHandler?
      _deleteSurroundingTextHandler;

  /// apply changes
  ///
  /// Instruct the application to apply changes to state requested by the
  /// preedit_string, commit_string and delete_surrounding_text events. The
  /// state relating to these events is double-buffered, and each one
  /// modifies the pending state. This event replaces the current state with
  /// the pending state.
  ///
  /// The application must proceed by evaluating the changes in the following
  /// order:
  ///
  /// 1. Replace existing preedit string with the cursor.
  /// 2. Delete requested surrounding text.
  /// 3. Insert commit string with the cursor at its end.
  /// 4. Calculate surrounding text to send.
  /// 5. Insert new preedit text in cursor position.
  /// 6. Place cursor inside preedit text.
  ///
  /// The serial number reflects the last state of the zwp_text_input_v3
  /// object known to the compositor. The value of the serial argument must
  /// be equal to the number of commit requests already issued on that object.
  ///
  /// When the client receives a done event with a serial different than the
  /// number of past commit requests, it must proceed with evaluating and
  /// applying the changes as normal, except it should not change the current
  /// state of the zwp_text_input_v3 object. All pending state requests
  /// (set_surrounding_text, set_content_type and set_cursor_rectangle) on
  /// the zwp_text_input_v3 object should be sent and committed after
  /// receiving a zwp_text_input_v3.done event with a matching serial.
  ///
  /// Event handler for Done
  /// - [serial]:
  void onDone(ZwpTextInputV3DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZwpTextInputV3DoneEventHandler? _doneHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpTextInputV3.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_enterHandler != null) {
          var offset = 0;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTextInputV3EnterEvent(
            surface,
          );
          _enterHandler!(event);
        }
        break;
      case 1:
        if (_leaveHandler != null) {
          var offset = 0;
          final surface = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ZwpTextInputV3LeaveEvent(
            surface,
          );
          _leaveHandler!(event);
        }
        break;
      case 2:
        if (_preeditStringHandler != null) {
          var offset = 0;
          final textLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final text =
              utf8.decode(data.sublist(offset, offset + textLength - 1));
          offset += textLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          final cursorBegin =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final cursorEnd =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV3PreeditStringEvent(
            text,
            cursorBegin,
            cursorEnd,
          );
          _preeditStringHandler!(event);
        }
        break;
      case 3:
        if (_commitStringHandler != null) {
          var offset = 0;
          final textLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final text =
              utf8.decode(data.sublist(offset, offset + textLength - 1));
          offset += textLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZwpTextInputV3CommitStringEvent(
            text,
          );
          _commitStringHandler!(event);
        }
        break;
      case 4:
        if (_deleteSurroundingTextHandler != null) {
          var offset = 0;
          final beforeLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final afterLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV3DeleteSurroundingTextEvent(
            beforeLength,
            afterLength,
          );
          _deleteSurroundingTextHandler!(event);
        }
        break;
      case 5:
        if (_doneHandler != null) {
          var offset = 0;
          final serial =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ZwpTextInputV3DoneEvent(
            serial,
          );
          _doneHandler!(event);
        }
        break;
    }
  }
}

/// text change reason
///
/// Reason for the change of surrounding text or cursor posision.
///

enum ZwpTextInputV3ChangeCause {
  /// input method caused the change
  inputMethod("input_method", 0),

  /// something else than the input method caused the change
  other("other", 1);

  const ZwpTextInputV3ChangeCause(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV3ChangeCause {name: $enumName, value: $enumValue}";
  }
}

/// content hint
///
/// Content hint is a bitmask to allow to modify the behavior of the text
/// input.
///

enum ZwpTextInputV3ContentHint {
  /// no special behavior
  none("none", 0x0),

  /// suggest word completions
  completion("completion", 0x1),

  /// suggest word corrections
  spellcheck("spellcheck", 0x2),

  /// switch to uppercase letters at the start of a sentence
  autoCapitalization("auto_capitalization", 0x4),

  /// prefer lowercase letters
  lowercase("lowercase", 0x8),

  /// prefer uppercase letters
  uppercase("uppercase", 0x10),

  /// prefer casing for titles and headings (can be language dependent)
  titlecase("titlecase", 0x20),

  /// characters should be hidden
  hiddenText("hidden_text", 0x40),

  /// typed text should not be stored
  sensitiveData("sensitive_data", 0x80),

  /// just Latin characters should be entered
  latin("latin", 0x100),

  /// the text input is multiline
  multiline("multiline", 0x200);

  const ZwpTextInputV3ContentHint(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV3ContentHint {name: $enumName, value: $enumValue}";
  }
}

/// content purpose
///
/// The content purpose allows to specify the primary purpose of a text
/// input.
///
/// This allows an input method to show special purpose input panels with
/// extra characters or to disallow some characters.
///

enum ZwpTextInputV3ContentPurpose {
  /// default input, allowing all characters
  normal("normal", 0),

  /// allow only alphabetic characters
  alpha("alpha", 1),

  /// allow only digits
  digits("digits", 2),

  /// input a number (including decimal separator and sign)
  number("number", 3),

  /// input a phone number
  phone("phone", 4),

  /// input an URL
  url("url", 5),

  /// input an email address
  email("email", 6),

  /// input a name of a person
  name("name", 7),

  /// input a password (combine with sensitive_data hint)
  password("password", 8),

  /// input is a numeric password (combine with sensitive_data hint)
  pin("pin", 9),

  /// input a date
  date("date", 10),

  /// input a time
  time("time", 11),

  /// input a date and time
  datetime("datetime", 12),

  /// input for a terminal
  terminal("terminal", 13);

  const ZwpTextInputV3ContentPurpose(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpTextInputV3ContentPurpose {name: $enumName, value: $enumValue}";
  }
}

/// text input manager
///
/// A factory for text-input objects. This object is a global singleton.
///
class ZwpTextInputManagerV3 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZwpTextInputManagerV3(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpTextInputManagerV3 {name: 'zwp_text_input_manager_v3', id: '$objectId', version: '1',}";
  }

  /// Destroy the wp_text_input_manager
  ///
  /// Destroy the wp_text_input_manager object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZwpTextInputManagerV3::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputManagerV3::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// create a new text input object
  ///
  /// Creates a new text-input object for a given seat.
  ///
  /// [id]:
  /// [seat]:
  Result<ZwpTextInputV3, Object> getTextInput(Seat seat) {
    var id = ZwpTextInputV3(innerContext);
    logLn("ZwpTextInputManagerV3::getTextInput  id: $id seat: $seat");
    var arguments = [id, seat];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZwpTextInputManagerV3::getTextInput: $e");
      return Failure(e);
    }
    return Success(id);
  }
}
