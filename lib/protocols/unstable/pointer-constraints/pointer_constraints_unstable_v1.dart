// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml
//
// pointer_constraints_unstable_v1 Protocol Copyright:
///
/// Copyright © 2014      Jonas Ådahl
/// Copyright © 2015      Red Hat Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// constrain the movement of a pointer
///
/// The global interface exposing pointer constraining functionality. It
/// exposes two requests: lock_pointer for locking the pointer to its
/// position, and confine_pointer for locking the pointer to a region.
///
/// The lock_pointer and confine_pointer requests create the objects
/// wp_locked_pointer and wp_confined_pointer respectively, and the client can
/// use these objects to interact with the lock.
///
/// For any surface, only one lock or confinement may be active across all
/// wl_pointer objects of the same seat. If a lock or confinement is requested
/// when another lock or confinement is active or requested on the same surface
/// and with any of the wl_pointer objects of the same seat, an
/// 'already_constrained' error will be raised.
///
class ZwpPointerConstraintsV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZwpPointerConstraintsV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpPointerConstraintsV1 {name: 'zwp_pointer_constraints_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the pointer constraints manager object
  ///
  /// Used by the client to notify the server that it will no longer use this
  /// pointer constraints object.
  ///
  void destroy() {
    logLn("ZwpPointerConstraintsV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// lock pointer to a position
  ///
  /// The lock_pointer request lets the client request to disable movements of
  /// the virtual pointer (i.e. the cursor), effectively locking the pointer
  /// to a position. This request may not take effect immediately; in the
  /// future, when the compositor deems implementation-specific constraints
  /// are satisfied, the pointer lock will be activated and the compositor
  /// sends a locked event.
  ///
  /// The protocol provides no guarantee that the constraints are ever
  /// satisfied, and does not require the compositor to send an error if the
  /// constraints cannot ever be satisfied. It is thus possible to request a
  /// lock that will never activate.
  ///
  /// There may not be another pointer constraint of any kind requested or
  /// active on the surface for any of the wl_pointer objects of the seat of
  /// the passed pointer when requesting a lock. If there is, an error will be
  /// raised. See general pointer lock documentation for more details.
  ///
  /// The intersection of the region passed with this request and the input
  /// region of the surface is used to determine where the pointer must be
  /// in order for the lock to activate. It is up to the compositor whether to
  /// warp the pointer or require some kind of user interaction for the lock
  /// to activate. If the region is null the surface input region is used.
  ///
  /// A surface may receive pointer focus without the lock being activated.
  ///
  /// The request creates a new object wp_locked_pointer which is used to
  /// interact with the lock as well as receive updates about its state. See
  /// the the description of wp_locked_pointer for further information.
  ///
  /// Note that while a pointer is locked, the wl_pointer objects of the
  /// corresponding seat will not emit any wl_pointer.motion events, but
  /// relative motion events will still be emitted via wp_relative_pointer
  /// objects of the same seat. wl_pointer.axis and wl_pointer.button events
  /// are unaffected.
  ///
  /// [id]:
  /// [surface]: surface to lock pointer to
  /// [pointer]: the pointer that should be locked
  /// [region]: region of surface
  /// [lifetime]: lock lifetime
  ZwpLockedPointerV1 lockPointer(
      Surface surface, Pointer pointer, Region region, int lifetime) {
    var id = ZwpLockedPointerV1(innerContext);
    logLn(
        "ZwpPointerConstraintsV1::lockPointer  id: $id surface: $surface pointer: $pointer region: $region lifetime: $lifetime");
    var arguments = [id, surface, pointer, region, lifetime];
    var argTypes = <WaylandType>[
      WaylandType.newId,
      WaylandType.object,
      WaylandType.object,
      WaylandType.object,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([pointer.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([region.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([lifetime]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }

  /// confine pointer to a region
  ///
  /// The confine_pointer request lets the client request to confine the
  /// pointer cursor to a given region. This request may not take effect
  /// immediately; in the future, when the compositor deems implementation-
  /// specific constraints are satisfied, the pointer confinement will be
  /// activated and the compositor sends a confined event.
  ///
  /// The intersection of the region passed with this request and the input
  /// region of the surface is used to determine where the pointer must be
  /// in order for the confinement to activate. It is up to the compositor
  /// whether to warp the pointer or require some kind of user interaction for
  /// the confinement to activate. If the region is null the surface input
  /// region is used.
  ///
  /// The request will create a new object wp_confined_pointer which is used
  /// to interact with the confinement as well as receive updates about its
  /// state. See the the description of wp_confined_pointer for further
  /// information.
  ///
  /// [id]:
  /// [surface]: surface to lock pointer to
  /// [pointer]: the pointer that should be confined
  /// [region]: region of surface
  /// [lifetime]: confinement lifetime
  ZwpConfinedPointerV1 confinePointer(
      Surface surface, Pointer pointer, Region region, int lifetime) {
    var id = ZwpConfinedPointerV1(innerContext);
    logLn(
        "ZwpPointerConstraintsV1::confinePointer  id: $id surface: $surface pointer: $pointer region: $region lifetime: $lifetime");
    var arguments = [id, surface, pointer, region, lifetime];
    var argTypes = <WaylandType>[
      WaylandType.newId,
      WaylandType.object,
      WaylandType.object,
      WaylandType.object,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([pointer.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([region.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([lifetime]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

/// wp_pointer_constraints error values
///
/// These errors can be emitted in response to wp_pointer_constraints
/// requests.
///

enum ZwpPointerConstraintsV1Error {
  /// pointer constraint already requested on that surface
  alreadyConstrained("already_constrained", 1);

  const ZwpPointerConstraintsV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpPointerConstraintsV1Error {name: $enumName, value: $enumValue}";
  }
}

/// constraint lifetime
///
/// These values represent different lifetime semantics. They are passed
/// as arguments to the factory requests to specify how the constraint
/// lifetimes should be managed.
///

enum ZwpPointerConstraintsV1Lifetime {
  ///
  oneshot("oneshot", 1),

  ///
  persistent("persistent", 2);

  const ZwpPointerConstraintsV1Lifetime(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZwpPointerConstraintsV1Lifetime {name: $enumName, value: $enumValue}";
  }
}

/// lock activation event
///
/// Notification that the pointer lock of the seat's pointer is activated.
///
class ZwpLockedPointerV1LockedEvent {
  ZwpLockedPointerV1LockedEvent();

  @override
  toString() {
    return "ZwpLockedPointerV1LockedEvent ()";
  }
}

typedef ZwpLockedPointerV1LockedEventHandler = void Function(
    ZwpLockedPointerV1LockedEvent);

/// lock deactivation event
///
/// Notification that the pointer lock of the seat's pointer is no longer
/// active. If this is a oneshot pointer lock (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer lock (see
/// wp_pointer_constraints.lifetime) this pointer lock may again
/// reactivate in the future.
///
class ZwpLockedPointerV1UnlockedEvent {
  ZwpLockedPointerV1UnlockedEvent();

  @override
  toString() {
    return "ZwpLockedPointerV1UnlockedEvent ()";
  }
}

typedef ZwpLockedPointerV1UnlockedEventHandler = void Function(
    ZwpLockedPointerV1UnlockedEvent);

/// receive relative pointer motion events
///
/// The wp_locked_pointer interface represents a locked pointer state.
///
/// While the lock of this object is active, the wl_pointer objects of the
/// associated seat will not emit any wl_pointer.motion events.
///
/// This object will send the event 'locked' when the lock is activated.
/// Whenever the lock is activated, it is guaranteed that the locked surface
/// will already have received pointer focus and that the pointer will be
/// within the region passed to the request creating this object.
///
/// To unlock the pointer, send the destroy request. This will also destroy
/// the wp_locked_pointer object.
///
/// If the compositor decides to unlock the pointer the unlocked event is
/// sent. See wp_locked_pointer.unlock for details.
///
/// When unlocking, the compositor may warp the cursor position to the set
/// cursor position hint. If it does, it will not result in any relative
/// motion events emitted via wp_relative_pointer.
///
/// If the surface the lock was requested on is destroyed and the lock is not
/// yet activated, the wp_locked_pointer object is now defunct and must be
/// destroyed.
///
class ZwpLockedPointerV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpLockedPointerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpLockedPointerV1 {name: 'zwp_locked_pointer_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the locked pointer object
  ///
  /// Destroy the locked pointer object. If applicable, the compositor will
  /// unlock the pointer.
  ///
  void destroy() {
    logLn("ZwpLockedPointerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// set the pointer cursor position hint
  ///
  /// Set the cursor position hint relative to the top left corner of the
  /// surface.
  ///
  /// If the client is drawing its own cursor, it should update the position
  /// hint to the position of its own cursor. A compositor may use this
  /// information to warp the pointer upon unlock in order to avoid pointer
  /// jumps.
  ///
  /// The cursor position hint is double-buffered state, see
  /// wl_surface.commit.
  ///
  /// [surface_x]: surface-local x coordinate
  /// [surface_y]: surface-local y coordinate
  void setCursorPositionHint(double surfaceX, double surfaceY) {
    logLn(
        "ZwpLockedPointerV1::setCursorPositionHint  surfaceX: $surfaceX surfaceY: $surfaceY");
    var arguments = [surfaceX, surfaceY];
    var argTypes = <WaylandType>[WaylandType.fixed, WaylandType.fixed];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Int32List.fromList([doubleToFixed(surfaceX)]).buffer.asUint8List());
    bytesBuilder.add(
        Int32List.fromList([doubleToFixed(surfaceY)]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// set a new lock region
  ///
  /// Set a new region used to lock the pointer.
  ///
  /// The new lock region is double-buffered, see wl_surface.commit.
  ///
  /// For details about the lock region, see wp_locked_pointer.
  ///
  /// [region]: region of surface
  void setRegion(Region region) {
    logLn("ZwpLockedPointerV1::setRegion  region: $region");
    var arguments = [region];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([region.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// lock activation event
  ///
  /// Notification that the pointer lock of the seat's pointer is activated.
  ///
  /// Event handler for Locked
  void onLocked(ZwpLockedPointerV1LockedEventHandler handler) {
    _lockedHandler = handler;
  }

  ZwpLockedPointerV1LockedEventHandler? _lockedHandler;

  /// lock deactivation event
  ///
  /// Notification that the pointer lock of the seat's pointer is no longer
  /// active. If this is a oneshot pointer lock (see
  /// wp_pointer_constraints.lifetime) this object is now defunct and should
  /// be destroyed. If this is a persistent pointer lock (see
  /// wp_pointer_constraints.lifetime) this pointer lock may again
  /// reactivate in the future.
  ///
  /// Event handler for Unlocked
  void onUnlocked(ZwpLockedPointerV1UnlockedEventHandler handler) {
    _unlockedHandler = handler;
  }

  ZwpLockedPointerV1UnlockedEventHandler? _unlockedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpLockedPointerV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_lockedHandler != null) {
          _lockedHandler!(ZwpLockedPointerV1LockedEvent());
        }
        break;
      case 1:
        if (_unlockedHandler != null) {
          _unlockedHandler!(ZwpLockedPointerV1UnlockedEvent());
        }
        break;
    }
  }
}

/// pointer confined
///
/// Notification that the pointer confinement of the seat's pointer is
/// activated.
///
class ZwpConfinedPointerV1ConfinedEvent {
  ZwpConfinedPointerV1ConfinedEvent();

  @override
  toString() {
    return "ZwpConfinedPointerV1ConfinedEvent ()";
  }
}

typedef ZwpConfinedPointerV1ConfinedEventHandler = void Function(
    ZwpConfinedPointerV1ConfinedEvent);

/// pointer unconfined
///
/// Notification that the pointer confinement of the seat's pointer is no
/// longer active. If this is a oneshot pointer confinement (see
/// wp_pointer_constraints.lifetime) this object is now defunct and should
/// be destroyed. If this is a persistent pointer confinement (see
/// wp_pointer_constraints.lifetime) this pointer confinement may again
/// reactivate in the future.
///
class ZwpConfinedPointerV1UnconfinedEvent {
  ZwpConfinedPointerV1UnconfinedEvent();

  @override
  toString() {
    return "ZwpConfinedPointerV1UnconfinedEvent ()";
  }
}

typedef ZwpConfinedPointerV1UnconfinedEventHandler = void Function(
    ZwpConfinedPointerV1UnconfinedEvent);

/// confined pointer object
///
/// The wp_confined_pointer interface represents a confined pointer state.
///
/// This object will send the event 'confined' when the confinement is
/// activated. Whenever the confinement is activated, it is guaranteed that
/// the surface the pointer is confined to will already have received pointer
/// focus and that the pointer will be within the region passed to the request
/// creating this object. It is up to the compositor to decide whether this
/// requires some user interaction and if the pointer will warp to within the
/// passed region if outside.
///
/// To unconfine the pointer, send the destroy request. This will also destroy
/// the wp_confined_pointer object.
///
/// If the compositor decides to unconfine the pointer the unconfined event is
/// sent. The wp_confined_pointer object is at this point defunct and should
/// be destroyed.
///
class ZwpConfinedPointerV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZwpConfinedPointerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZwpConfinedPointerV1 {name: 'zwp_confined_pointer_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the confined pointer object
  ///
  /// Destroy the confined pointer object. If applicable, the compositor will
  /// unconfine the pointer.
  ///
  void destroy() {
    logLn("ZwpConfinedPointerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// set a new confine region
  ///
  /// Set a new region used to confine the pointer.
  ///
  /// The new confine region is double-buffered, see wl_surface.commit.
  ///
  /// If the confinement is active when the new confinement region is applied
  /// and the pointer ends up outside of newly applied region, the pointer may
  /// warped to a position within the new confinement region. If warped, a
  /// wl_pointer.motion event will be emitted, but no
  /// wp_relative_pointer.relative_motion event.
  ///
  /// The compositor may also, instead of using the new region, unconfine the
  /// pointer.
  ///
  /// For details about the confine region, see wp_confined_pointer.
  ///
  /// [region]: region of surface
  void setRegion(Region region) {
    logLn("ZwpConfinedPointerV1::setRegion  region: $region");
    var arguments = [region];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([region.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// pointer confined
  ///
  /// Notification that the pointer confinement of the seat's pointer is
  /// activated.
  ///
  /// Event handler for Confined
  void onConfined(ZwpConfinedPointerV1ConfinedEventHandler handler) {
    _confinedHandler = handler;
  }

  ZwpConfinedPointerV1ConfinedEventHandler? _confinedHandler;

  /// pointer unconfined
  ///
  /// Notification that the pointer confinement of the seat's pointer is no
  /// longer active. If this is a oneshot pointer confinement (see
  /// wp_pointer_constraints.lifetime) this object is now defunct and should
  /// be destroyed. If this is a persistent pointer confinement (see
  /// wp_pointer_constraints.lifetime) this pointer confinement may again
  /// reactivate in the future.
  ///
  /// Event handler for Unconfined
  void onUnconfined(ZwpConfinedPointerV1UnconfinedEventHandler handler) {
    _unconfinedHandler = handler;
  }

  ZwpConfinedPointerV1UnconfinedEventHandler? _unconfinedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZwpConfinedPointerV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_confinedHandler != null) {
          _confinedHandler!(ZwpConfinedPointerV1ConfinedEvent());
        }
        break;
      case 1:
        if (_unconfinedHandler != null) {
          _unconfinedHandler!(ZwpConfinedPointerV1UnconfinedEvent());
        }
        break;
    }
  }
}
