// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-output/xdg-output-unstable-v1.xml
//
// xdg_output_unstable_v1 Protocol Copyright:
///
/// Copyright © 2017 Red Hat Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// manage xdg_output objects
///
/// A global factory interface for xdg_output objects.
///
class ZxdgOutputManagerV1 extends Proxy {
  final Context innerContext;
  final version = 3;

  ZxdgOutputManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgOutputManagerV1 {name: 'zxdg_output_manager_v1', id: '$objectId', version: '3',}";
  }

  /// destroy the xdg_output_manager object
  ///
  /// Using this request a client can tell the server that it is not
  /// going to use the xdg_output_manager object anymore.
  ///
  /// Any objects already created through this instance are not affected.
  ///
  void destroy() {
    logLn("ZxdgOutputManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// create an xdg output from a wl_output
  ///
  /// This creates a new xdg_output object for the given wl_output.
  ///
  /// [id]:
  /// [output]:
  ZxdgOutputV1 getXdgOutput(Output output) {
    var id = ZxdgOutputV1(innerContext);
    logLn("ZxdgOutputManagerV1::getXdgOutput  id: $id output: $output");
    var arguments = [id, output];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([output.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

/// position of the output within the global compositor space
///
/// The position event describes the location of the wl_output within
/// the global compositor space.
///
/// The logical_position event is sent after creating an xdg_output
/// (see xdg_output_manager.get_xdg_output) and whenever the location
/// of the output changes within the global compositor space.
///
class ZxdgOutputV1LogicalPositionEvent {
  /// x position within the global compositor space
  final int x;

  /// y position within the global compositor space
  final int y;

  ZxdgOutputV1LogicalPositionEvent(
    this.x,
    this.y,
  );

  @override
  toString() {
    return "ZxdgOutputV1LogicalPositionEvent (x: $x, y: $y)";
  }
}

typedef ZxdgOutputV1LogicalPositionEventHandler = void Function(
    ZxdgOutputV1LogicalPositionEvent);

/// size of the output in the global compositor space
///
/// The logical_size event describes the size of the output in the
/// global compositor space.
///
/// Most regular Wayland clients should not pay attention to the
/// logical size and would rather rely on xdg_shell interfaces.
///
/// Some clients such as Xwayland, however, need this to configure
/// their surfaces in the global compositor space as the compositor
/// may apply a different scale from what is advertised by the output
/// scaling property (to achieve fractional scaling, for example).
///
/// For example, for a wl_output mode 3840×2160 and a scale factor 2:
///
/// - A compositor not scaling the monitor viewport in its compositing space
/// will advertise a logical size of 3840×2160,
///
/// - A compositor scaling the monitor viewport with scale factor 2 will
/// advertise a logical size of 1920×1080,
///
/// - A compositor scaling the monitor viewport using a fractional scale of
/// 1.5 will advertise a logical size of 2560×1440.
///
/// For example, for a wl_output mode 1920×1080 and a 90 degree rotation,
/// the compositor will advertise a logical size of 1080x1920.
///
/// The logical_size event is sent after creating an xdg_output
/// (see xdg_output_manager.get_xdg_output) and whenever the logical
/// size of the output changes, either as a result of a change in the
/// applied scale or because of a change in the corresponding output
/// mode(see wl_output.mode) or transform (see wl_output.transform).
///
class ZxdgOutputV1LogicalSizeEvent {
  /// width in global compositor space
  final int width;

  /// height in global compositor space
  final int height;

  ZxdgOutputV1LogicalSizeEvent(
    this.width,
    this.height,
  );

  @override
  toString() {
    return "ZxdgOutputV1LogicalSizeEvent (width: $width, height: $height)";
  }
}

typedef ZxdgOutputV1LogicalSizeEventHandler = void Function(
    ZxdgOutputV1LogicalSizeEvent);

/// all information about the output have been sent
///
/// This event is sent after all other properties of an xdg_output
/// have been sent.
///
/// This allows changes to the xdg_output properties to be seen as
/// atomic, even if they happen via multiple events.
///
/// For objects version 3 onwards, this event is deprecated. Compositors
/// are not required to send it anymore and must send wl_output.done
/// instead.
///
class ZxdgOutputV1DoneEvent {
  ZxdgOutputV1DoneEvent();

  @override
  toString() {
    return "ZxdgOutputV1DoneEvent ()";
  }
}

typedef ZxdgOutputV1DoneEventHandler = void Function(ZxdgOutputV1DoneEvent);

/// name of this output
///
/// Many compositors will assign names to their outputs, show them to the
/// user, allow them to be configured by name, etc. The client may wish to
/// know this name as well to offer the user similar behaviors.
///
/// The naming convention is compositor defined, but limited to
/// alphanumeric characters and dashes (-). Each name is unique among all
/// wl_output globals, but if a wl_output global is destroyed the same name
/// may be reused later. The names will also remain consistent across
/// sessions with the same hardware and software configuration.
///
/// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
/// not assume that the name is a reflection of an underlying DRM
/// connector, X11 connection, etc.
///
/// The name event is sent after creating an xdg_output (see
/// xdg_output_manager.get_xdg_output). This event is only sent once per
/// xdg_output, and the name does not change over the lifetime of the
/// wl_output global.
///
/// This event is deprecated, instead clients should use wl_output.name.
/// Compositors must still support this event.
///
class ZxdgOutputV1NameEvent {
  /// output name
  final String name;

  ZxdgOutputV1NameEvent(
    this.name,
  );

  @override
  toString() {
    return "ZxdgOutputV1NameEvent (name: $name)";
  }
}

typedef ZxdgOutputV1NameEventHandler = void Function(ZxdgOutputV1NameEvent);

/// human-readable description of this output
///
/// Many compositors can produce human-readable descriptions of their
/// outputs.  The client may wish to know this description as well, to
/// communicate the user for various purposes.
///
/// The description is a UTF-8 string with no convention defined for its
/// contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11
/// output via :1'.
///
/// The description event is sent after creating an xdg_output (see
/// xdg_output_manager.get_xdg_output) and whenever the description
/// changes. The description is optional, and may not be sent at all.
///
/// For objects of version 2 and lower, this event is only sent once per
/// xdg_output, and the description does not change over the lifetime of
/// the wl_output global.
///
/// This event is deprecated, instead clients should use
/// wl_output.description. Compositors must still support this event.
///
class ZxdgOutputV1DescriptionEvent {
  /// output description
  final String description;

  ZxdgOutputV1DescriptionEvent(
    this.description,
  );

  @override
  toString() {
    return "ZxdgOutputV1DescriptionEvent (description: $description)";
  }
}

typedef ZxdgOutputV1DescriptionEventHandler = void Function(
    ZxdgOutputV1DescriptionEvent);

/// compositor logical output region
///
/// An xdg_output describes part of the compositor geometry.
///
/// This typically corresponds to a monitor that displays part of the
/// compositor space.
///
/// For objects version 3 onwards, after all xdg_output properties have been
/// sent (when the object is created and when properties are updated), a
/// wl_output.done event is sent. This allows changes to the output
/// properties to be seen as atomic, even if they happen via multiple events.
///
class ZxdgOutputV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 3;

  ZxdgOutputV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgOutputV1 {name: 'zxdg_output_v1', id: '$objectId', version: '3',}";
  }

  /// destroy the xdg_output object
  ///
  /// Using this request a client can tell the server that it is not
  /// going to use the xdg_output object anymore.
  ///
  void destroy() {
    logLn("ZxdgOutputV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// position of the output within the global compositor space
  ///
  /// The position event describes the location of the wl_output within
  /// the global compositor space.
  ///
  /// The logical_position event is sent after creating an xdg_output
  /// (see xdg_output_manager.get_xdg_output) and whenever the location
  /// of the output changes within the global compositor space.
  ///
  /// Event handler for LogicalPosition
  /// - [x]: x position within the global compositor space
  /// - [y]: y position within the global compositor space
  void onLogicalPosition(ZxdgOutputV1LogicalPositionEventHandler handler) {
    _logicalPositionHandler = handler;
  }

  ZxdgOutputV1LogicalPositionEventHandler? _logicalPositionHandler;

  /// size of the output in the global compositor space
  ///
  /// The logical_size event describes the size of the output in the
  /// global compositor space.
  ///
  /// Most regular Wayland clients should not pay attention to the
  /// logical size and would rather rely on xdg_shell interfaces.
  ///
  /// Some clients such as Xwayland, however, need this to configure
  /// their surfaces in the global compositor space as the compositor
  /// may apply a different scale from what is advertised by the output
  /// scaling property (to achieve fractional scaling, for example).
  ///
  /// For example, for a wl_output mode 3840×2160 and a scale factor 2:
  ///
  /// - A compositor not scaling the monitor viewport in its compositing space
  /// will advertise a logical size of 3840×2160,
  ///
  /// - A compositor scaling the monitor viewport with scale factor 2 will
  /// advertise a logical size of 1920×1080,
  ///
  /// - A compositor scaling the monitor viewport using a fractional scale of
  /// 1.5 will advertise a logical size of 2560×1440.
  ///
  /// For example, for a wl_output mode 1920×1080 and a 90 degree rotation,
  /// the compositor will advertise a logical size of 1080x1920.
  ///
  /// The logical_size event is sent after creating an xdg_output
  /// (see xdg_output_manager.get_xdg_output) and whenever the logical
  /// size of the output changes, either as a result of a change in the
  /// applied scale or because of a change in the corresponding output
  /// mode(see wl_output.mode) or transform (see wl_output.transform).
  ///
  /// Event handler for LogicalSize
  /// - [width]: width in global compositor space
  /// - [height]: height in global compositor space
  void onLogicalSize(ZxdgOutputV1LogicalSizeEventHandler handler) {
    _logicalSizeHandler = handler;
  }

  ZxdgOutputV1LogicalSizeEventHandler? _logicalSizeHandler;

  /// all information about the output have been sent
  ///
  /// This event is sent after all other properties of an xdg_output
  /// have been sent.
  ///
  /// This allows changes to the xdg_output properties to be seen as
  /// atomic, even if they happen via multiple events.
  ///
  /// For objects version 3 onwards, this event is deprecated. Compositors
  /// are not required to send it anymore and must send wl_output.done
  /// instead.
  ///
  /// Event handler for Done
  void onDone(ZxdgOutputV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ZxdgOutputV1DoneEventHandler? _doneHandler;

  /// name of this output
  ///
  /// Many compositors will assign names to their outputs, show them to the
  /// user, allow them to be configured by name, etc. The client may wish to
  /// know this name as well to offer the user similar behaviors.
  ///
  /// The naming convention is compositor defined, but limited to
  /// alphanumeric characters and dashes (-). Each name is unique among all
  /// wl_output globals, but if a wl_output global is destroyed the same name
  /// may be reused later. The names will also remain consistent across
  /// sessions with the same hardware and software configuration.
  ///
  /// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
  /// not assume that the name is a reflection of an underlying DRM
  /// connector, X11 connection, etc.
  ///
  /// The name event is sent after creating an xdg_output (see
  /// xdg_output_manager.get_xdg_output). This event is only sent once per
  /// xdg_output, and the name does not change over the lifetime of the
  /// wl_output global.
  ///
  /// This event is deprecated, instead clients should use wl_output.name.
  /// Compositors must still support this event.
  ///
  /// Event handler for Name
  /// - [name]: output name
  void onName(ZxdgOutputV1NameEventHandler handler) {
    _nameHandler = handler;
  }

  ZxdgOutputV1NameEventHandler? _nameHandler;

  /// human-readable description of this output
  ///
  /// Many compositors can produce human-readable descriptions of their
  /// outputs.  The client may wish to know this description as well, to
  /// communicate the user for various purposes.
  ///
  /// The description is a UTF-8 string with no convention defined for its
  /// contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11
  /// output via :1'.
  ///
  /// The description event is sent after creating an xdg_output (see
  /// xdg_output_manager.get_xdg_output) and whenever the description
  /// changes. The description is optional, and may not be sent at all.
  ///
  /// For objects of version 2 and lower, this event is only sent once per
  /// xdg_output, and the description does not change over the lifetime of
  /// the wl_output global.
  ///
  /// This event is deprecated, instead clients should use
  /// wl_output.description. Compositors must still support this event.
  ///
  /// Event handler for Description
  /// - [description]: output description
  void onDescription(ZxdgOutputV1DescriptionEventHandler handler) {
    _descriptionHandler = handler;
  }

  ZxdgOutputV1DescriptionEventHandler? _descriptionHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgOutputV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_logicalPositionHandler != null) {
          var offset = 0;
          final x = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final y = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZxdgOutputV1LogicalPositionEvent(
            x,
            y,
          );
          _logicalPositionHandler!(event);
        }
        break;
      case 1:
        if (_logicalSizeHandler != null) {
          var offset = 0;
          final width =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final height =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ZxdgOutputV1LogicalSizeEvent(
            width,
            height,
          );
          _logicalSizeHandler!(event);
        }
        break;
      case 2:
        if (_doneHandler != null) {
          _doneHandler!(ZxdgOutputV1DoneEvent());
        }
        break;
      case 3:
        if (_nameHandler != null) {
          var offset = 0;
          final nameLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final name =
              utf8.decode(data.sublist(offset, offset + nameLength - 1));
          offset += nameLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZxdgOutputV1NameEvent(
            name,
          );
          _nameHandler!(event);
        }
        break;
      case 4:
        if (_descriptionHandler != null) {
          var offset = 0;
          final descriptionLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final description =
              utf8.decode(data.sublist(offset, offset + descriptionLength - 1));
          offset +=
              descriptionLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZxdgOutputV1DescriptionEvent(
            description,
          );
          _descriptionHandler!(event);
        }
        break;
    }
  }
}
