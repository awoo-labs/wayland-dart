// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-foreign/xdg-foreign-unstable-v1.xml
//
// xdg_foreign_unstable_v1 Protocol Copyright:
///
/// Copyright Â© 2015-2016 Red Hat Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// interface for exporting surfaces
///
/// A global interface used for exporting surfaces that can later be imported
/// using xdg_importer.
///
class ZxdgExporterV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZxdgExporterV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgExporterV1 {name: 'zxdg_exporter_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_exporter object
  ///
  /// Notify the compositor that the xdg_exporter object will no longer be
  /// used.
  ///
  void destroy() {
    logLn("ZxdgExporterV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// export a surface
  ///
  /// The export request exports the passed surface so that it can later be
  /// imported via xdg_importer. When called, a new xdg_exported object will
  /// be created and xdg_exported.handle will be sent immediately. See the
  /// corresponding interface and event for details.
  ///
  /// A surface may be exported multiple times, and each exported handle may
  /// be used to create an xdg_imported multiple times. Only xdg_surface
  /// surfaces may be exported.
  ///
  /// [id]: the new xdg_exported object
  /// [surface]: the surface to export
  ZxdgExportedV1 export(Surface surface) {
    var id = ZxdgExportedV1(innerContext);
    logLn("ZxdgExporterV1::export  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

/// interface for importing surfaces
///
/// A global interface used for importing surfaces exported by xdg_exporter.
/// With this interface, a client can create a reference to a surface of
/// another client.
///
class ZxdgImporterV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZxdgImporterV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgImporterV1 {name: 'zxdg_importer_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_importer object
  ///
  /// Notify the compositor that the xdg_importer object will no longer be
  /// used.
  ///
  void destroy() {
    logLn("ZxdgImporterV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// import a surface
  ///
  /// The import request imports a surface from any client given a handle
  /// retrieved by exporting said surface using xdg_exporter.export. When
  /// called, a new xdg_imported object will be created. This new object
  /// represents the imported surface, and the importing client can
  /// manipulate its relationship using it. See xdg_imported for details.
  ///
  /// [id]: the new xdg_imported object
  /// [handle]: the exported surface handle
  ZxdgImportedV1 import(String handle) {
    var id = ZxdgImportedV1(innerContext);
    logLn("ZxdgImporterV1::import  id: $id handle: $handle");
    var arguments = [id, handle];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    final handleBytes = utf8.encode(handle);
    bytesBuilder.add(
        Uint32List.fromList([handleBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(handleBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

/// the exported surface handle
///
/// The handle event contains the unique handle of this exported surface
/// reference. It may be shared with any client, which then can use it to
/// import the surface by calling xdg_importer.import. A handle may be
/// used to import the surface multiple times.
///
class ZxdgExportedV1HandleEvent {
  /// the exported surface handle
  final String handle;

  ZxdgExportedV1HandleEvent(
    this.handle,
  );

  @override
  toString() {
    return "ZxdgExportedV1HandleEvent (handle: $handle)";
  }
}

typedef ZxdgExportedV1HandleEventHandler = void Function(
    ZxdgExportedV1HandleEvent);

/// an exported surface handle
///
/// An xdg_exported object represents an exported reference to a surface. The
/// exported surface may be referenced as long as the xdg_exported object not
/// destroyed. Destroying the xdg_exported invalidates any relationship the
/// importer may have established using xdg_imported.
///
class ZxdgExportedV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZxdgExportedV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgExportedV1 {name: 'zxdg_exported_v1', id: '$objectId', version: '1',}";
  }

  /// unexport the exported surface
  ///
  /// Revoke the previously exported surface. This invalidates any
  /// relationship the importer may have set up using the xdg_imported created
  /// given the handle sent via xdg_exported.handle.
  ///
  void destroy() {
    logLn("ZxdgExportedV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// the exported surface handle
  ///
  /// The handle event contains the unique handle of this exported surface
  /// reference. It may be shared with any client, which then can use it to
  /// import the surface by calling xdg_importer.import. A handle may be
  /// used to import the surface multiple times.
  ///
  /// Event handler for Handle
  /// - [handle]: the exported surface handle
  void onHandle(ZxdgExportedV1HandleEventHandler handler) {
    _handleHandler = handler;
  }

  ZxdgExportedV1HandleEventHandler? _handleHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgExportedV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_handleHandler != null) {
          var offset = 0;
          final handleLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final handle =
              utf8.decode(data.sublist(offset, offset + handleLength - 1));
          offset += handleLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZxdgExportedV1HandleEvent(
            handle,
          );
          _handleHandler!(event);
        }
        break;
    }
  }
}

/// the imported surface handle has been destroyed
///
/// The imported surface handle has been destroyed and any relationship set
/// up has been invalidated. This may happen for various reasons, for
/// example if the exported surface or the exported surface handle has been
/// destroyed, if the handle used for importing was invalid.
///
class ZxdgImportedV1DestroyedEvent {
  ZxdgImportedV1DestroyedEvent();

  @override
  toString() {
    return "ZxdgImportedV1DestroyedEvent ()";
  }
}

typedef ZxdgImportedV1DestroyedEventHandler = void Function(
    ZxdgImportedV1DestroyedEvent);

/// an imported surface handle
///
/// An xdg_imported object represents an imported reference to surface exported
/// by some client. A client can use this interface to manipulate
/// relationships between its own surfaces and the imported surface.
///
class ZxdgImportedV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZxdgImportedV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgImportedV1 {name: 'zxdg_imported_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_imported object
  ///
  /// Notify the compositor that it will no longer use the xdg_imported
  /// object. Any relationship that may have been set up will at this point
  /// be invalidated.
  ///
  void destroy() {
    logLn("ZxdgImportedV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// set as the parent of some surface
  ///
  /// Set the imported surface as the parent of some surface of the client.
  /// The passed surface must be a toplevel xdg_surface. Calling this function
  /// sets up a surface to surface relation with the same stacking and positioning
  /// semantics as xdg_surface.set_parent.
  ///
  /// [surface]: the child surface
  void setParentOf(Surface surface) {
    logLn("ZxdgImportedV1::setParentOf  surface: $surface");
    var arguments = [surface];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// the imported surface handle has been destroyed
  ///
  /// The imported surface handle has been destroyed and any relationship set
  /// up has been invalidated. This may happen for various reasons, for
  /// example if the exported surface or the exported surface handle has been
  /// destroyed, if the handle used for importing was invalid.
  ///
  /// Event handler for Destroyed
  void onDestroyed(ZxdgImportedV1DestroyedEventHandler handler) {
    _destroyedHandler = handler;
  }

  ZxdgImportedV1DestroyedEventHandler? _destroyedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgImportedV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_destroyedHandler != null) {
          _destroyedHandler!(ZxdgImportedV1DestroyedEvent());
        }
        break;
    }
  }
}
