// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/unstable/xdg-foreign/xdg-foreign-unstable-v2.xml
//
// xdg_foreign_unstable_v2 Protocol Copyright:
///
/// Copyright Â© 2015-2016 Red Hat Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// interface for exporting surfaces
///
/// A global interface used for exporting surfaces that can later be imported
/// using xdg_importer.
///
class ZxdgExporterV2 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZxdgExporterV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgExporterV2 {name: 'zxdg_exporter_v2', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_exporter object
  ///
  /// Notify the compositor that the xdg_exporter object will no longer be
  /// used.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZxdgExporterV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgExporterV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// export a toplevel surface
  ///
  /// The export_toplevel request exports the passed surface so that it can later be
  /// imported via xdg_importer. When called, a new xdg_exported object will
  /// be created and xdg_exported.handle will be sent immediately. See the
  /// corresponding interface and event for details.
  ///
  /// A surface may be exported multiple times, and each exported handle may
  /// be used to create an xdg_imported multiple times. Only xdg_toplevel
  /// equivalent surfaces may be exported, otherwise an invalid_surface
  /// protocol error is sent.
  ///
  /// [id]: the new xdg_exported object
  /// [surface]: the surface to export
  Result<ZxdgExportedV2, Object> exportToplevel(Surface surface) {
    var id = ZxdgExportedV2(innerContext);
    logLn("ZxdgExporterV2::exportToplevel  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgExporterV2::exportToplevel: $e");
      return Failure(e);
    }
    return Success(id);
  }
}

/// error values
///
/// These errors can be emitted in response to invalid xdg_exporter
/// requests.
///

enum ZxdgExporterV2Error {
  /// surface is not an xdg_toplevel
  invalidSurface("invalid_surface", 0);

  const ZxdgExporterV2Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZxdgExporterV2Error {name: $enumName, value: $enumValue}";
  }
}

/// interface for importing surfaces
///
/// A global interface used for importing surfaces exported by xdg_exporter.
/// With this interface, a client can create a reference to a surface of
/// another client.
///
class ZxdgImporterV2 extends Proxy {
  final Context innerContext;
  final version = 1;

  ZxdgImporterV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgImporterV2 {name: 'zxdg_importer_v2', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_importer object
  ///
  /// Notify the compositor that the xdg_importer object will no longer be
  /// used.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZxdgImporterV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgImporterV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// import a toplevel surface
  ///
  /// The import_toplevel request imports a surface from any client given a handle
  /// retrieved by exporting said surface using xdg_exporter.export_toplevel.
  /// When called, a new xdg_imported object will be created. This new object
  /// represents the imported surface, and the importing client can
  /// manipulate its relationship using it. See xdg_imported for details.
  ///
  /// [id]: the new xdg_imported object
  /// [handle]: the exported surface handle
  Result<ZxdgImportedV2, Object> importToplevel(String handle) {
    var id = ZxdgImportedV2(innerContext);
    logLn("ZxdgImporterV2::importToplevel  id: $id handle: $handle");
    var arguments = [id, handle];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    final handleBytes = utf8.encode(handle);
    bytesBuilder.add(
        Uint32List.fromList([handleBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(handleBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgImporterV2::importToplevel: $e");
      return Failure(e);
    }
    return Success(id);
  }
}

/// the exported surface handle
///
/// The handle event contains the unique handle of this exported surface
/// reference. It may be shared with any client, which then can use it to
/// import the surface by calling xdg_importer.import_toplevel. A handle
/// may be used to import the surface multiple times.
///
class ZxdgExportedV2HandleEvent {
  /// the exported surface handle
  final String handle;

  ZxdgExportedV2HandleEvent(
    this.handle,
  );

  @override
  toString() {
    return "ZxdgExportedV2HandleEvent (handle: $handle)";
  }
}

typedef ZxdgExportedV2HandleEventHandler = void Function(
    ZxdgExportedV2HandleEvent);

/// an exported surface handle
///
/// An xdg_exported object represents an exported reference to a surface. The
/// exported surface may be referenced as long as the xdg_exported object not
/// destroyed. Destroying the xdg_exported invalidates any relationship the
/// importer may have established using xdg_imported.
///
class ZxdgExportedV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZxdgExportedV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgExportedV2 {name: 'zxdg_exported_v2', id: '$objectId', version: '1',}";
  }

  /// unexport the exported surface
  ///
  /// Revoke the previously exported surface. This invalidates any
  /// relationship the importer may have set up using the xdg_imported created
  /// given the handle sent via xdg_exported.handle.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZxdgExportedV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgExportedV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// the exported surface handle
  ///
  /// The handle event contains the unique handle of this exported surface
  /// reference. It may be shared with any client, which then can use it to
  /// import the surface by calling xdg_importer.import_toplevel. A handle
  /// may be used to import the surface multiple times.
  ///
  /// Event handler for Handle
  /// - [handle]: the exported surface handle
  void onHandle(ZxdgExportedV2HandleEventHandler handler) {
    _handleHandler = handler;
  }

  ZxdgExportedV2HandleEventHandler? _handleHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgExportedV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_handleHandler != null) {
          var offset = 0;
          final handleLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final handle =
              utf8.decode(data.sublist(offset, offset + handleLength - 1));
          offset += handleLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ZxdgExportedV2HandleEvent(
            handle,
          );
          _handleHandler!(event);
        }
        break;
    }
  }
}

/// the imported surface handle has been destroyed
///
/// The imported surface handle has been destroyed and any relationship set
/// up has been invalidated. This may happen for various reasons, for
/// example if the exported surface or the exported surface handle has been
/// destroyed, if the handle used for importing was invalid.
///
class ZxdgImportedV2DestroyedEvent {
  ZxdgImportedV2DestroyedEvent();

  @override
  toString() {
    return "ZxdgImportedV2DestroyedEvent ()";
  }
}

typedef ZxdgImportedV2DestroyedEventHandler = void Function(
    ZxdgImportedV2DestroyedEvent);

/// an imported surface handle
///
/// An xdg_imported object represents an imported reference to surface exported
/// by some client. A client can use this interface to manipulate
/// relationships between its own surfaces and the imported surface.
///
class ZxdgImportedV2 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ZxdgImportedV2(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ZxdgImportedV2 {name: 'zxdg_imported_v2', id: '$objectId', version: '1',}";
  }

  /// destroy the xdg_imported object
  ///
  /// Notify the compositor that it will no longer use the xdg_imported
  /// object. Any relationship that may have been set up will at this point
  /// be invalidated.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ZxdgImportedV2::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgImportedV2::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set as the parent of some surface
  ///
  /// Set the imported surface as the parent of some surface of the client.
  /// The passed surface must be an xdg_toplevel equivalent, otherwise an
  /// invalid_surface protocol error is sent. Calling this function sets up
  /// a surface to surface relation with the same stacking and positioning
  /// semantics as xdg_toplevel.set_parent.
  ///
  /// [surface]: the child surface
  Result<void, Object> setParentOf(Surface surface) {
    logLn("ZxdgImportedV2::setParentOf  surface: $surface");
    var arguments = [surface];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ZxdgImportedV2::setParentOf: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// the imported surface handle has been destroyed
  ///
  /// The imported surface handle has been destroyed and any relationship set
  /// up has been invalidated. This may happen for various reasons, for
  /// example if the exported surface or the exported surface handle has been
  /// destroyed, if the handle used for importing was invalid.
  ///
  /// Event handler for Destroyed
  void onDestroyed(ZxdgImportedV2DestroyedEventHandler handler) {
    _destroyedHandler = handler;
  }

  ZxdgImportedV2DestroyedEventHandler? _destroyedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ZxdgImportedV2.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_destroyedHandler != null) {
          _destroyedHandler!(ZxdgImportedV2DestroyedEvent());
        }
        break;
    }
  }
}

/// error values
///
/// These errors can be emitted in response to invalid xdg_imported
/// requests.
///

enum ZxdgImportedV2Error {
  /// surface is not an xdg_toplevel
  invalidSurface("invalid_surface", 0);

  const ZxdgImportedV2Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ZxdgImportedV2Error {name: $enumName, value: $enumValue}";
  }
}
