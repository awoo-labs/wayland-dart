// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/linux-drm-syncobj/linux-drm-syncobj-v1.xml
//
// linux_drm_syncobj_v1 Protocol Copyright:
///
/// Copyright 2016 The Chromium Authors.
/// Copyright 2017 Intel Corporation
/// Copyright 2018 Collabora, Ltd
/// Copyright 2021 Simon Ser
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:typed_data';
// AWOO-MIXINS

/// global for providing explicit synchronization
///
/// This global is a factory interface, allowing clients to request
/// explicit synchronization for buffers on a per-surface basis.
///
/// See wp_linux_drm_syncobj_surface_v1 for more information.
///
class WpLinuxDrmSyncobjManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpLinuxDrmSyncobjManagerV1 {name: 'wp_linux_drm_syncobj_manager_v1', id: '$objectId', version: '1',}";
  }

  /// destroy explicit synchronization factory object
  ///
  /// Destroy this explicit synchronization factory object. Other objects
  /// shall not be affected by this request.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// extend surface interface for explicit synchronization
  ///
  /// Instantiate an interface extension for the given wl_surface to provide
  /// explicit synchronization.
  ///
  /// If the given wl_surface already has an explicit synchronization object
  /// associated, the surface_exists protocol error is raised.
  ///
  /// Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
  /// commits of a wl_surface themselves, are likely to be using this
  /// extension internally. If a client is using such an API for a
  /// wl_surface, it should not directly use this extension on that surface,
  /// to avoid raising a surface_exists protocol error.
  ///
  /// [id]: the new synchronization surface object id
  /// [surface]: the surface
  Result<WpLinuxDrmSyncobjSurfaceV1, Object> getSurface(Surface surface) {
    var id = WpLinuxDrmSyncobjSurfaceV1(innerContext);
    logLn("WpLinuxDrmSyncobjManagerV1::getSurface  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::getSurface: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// import a DRM syncobj timeline
  ///
  /// Import a DRM synchronization object timeline.
  ///
  /// If the FD cannot be imported, the invalid_timeline error is raised.
  ///
  /// [id]:
  /// [fd]: drm_syncobj file descriptor
  Result<WpLinuxDrmSyncobjTimelineV1, Object> importTimeline(int fd) {
    var id = WpLinuxDrmSyncobjTimelineV1(innerContext);
    logLn("WpLinuxDrmSyncobjManagerV1::importTimeline  id: $id fd: $fd");
    var arguments = [id];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(bytesBuilder.toBytes(), fd);
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::importTimeline: $e");
      return Failure(e);
    }
    return Success(id);
  }
}

///
///

enum WpLinuxDrmSyncobjManagerV1Error {
  /// the surface already has a synchronization object associated
  surfaceExists("surface_exists", 0),

  /// the timeline object could not be imported
  invalidTimeline("invalid_timeline", 1);

  const WpLinuxDrmSyncobjManagerV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpLinuxDrmSyncobjManagerV1Error {name: $enumName, value: $enumValue}";
  }
}

/// synchronization object timeline
///
/// This object represents an explicit synchronization object timeline
/// imported by the client to the compositor.
///
class WpLinuxDrmSyncobjTimelineV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjTimelineV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpLinuxDrmSyncobjTimelineV1 {name: 'wp_linux_drm_syncobj_timeline_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the timeline
  ///
  /// Destroy the synchronization object timeline. Other objects are not
  /// affected by this request, in particular timeline points set by
  /// set_acquire_point and set_release_point are not unset.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjTimelineV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjTimelineV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// per-surface explicit synchronization
///
/// This object is an add-on interface for wl_surface to enable explicit
/// synchronization.
///
/// Each surface can be associated with only one object of this interface at
/// any time.
///
/// Explicit synchronization is guaranteed to be supported for buffers
/// created with any version of the linux-dmabuf protocol. Compositors are
/// free to support explicit synchronization for additional buffer types.
/// If at surface commit time the attached buffer does not support explicit
/// synchronization, an unsupported_buffer error is raised.
///
/// As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the
/// compositor may ignore implicit synchronization for buffers attached and
/// committed to the wl_surface. The delivery of wl_buffer.release events
/// for buffers attached to the surface becomes undefined.
///
/// Clients must set both acquire and release points if and only if a
/// non-null buffer is attached in the same surface commit. See the
/// no_buffer, no_acquire_point and no_release_point protocol errors.
///
/// If at surface commit time the acquire and release DRM syncobj timelines
/// are identical, the acquire point value must be strictly less than the
/// release point value, or else the conflicting_points protocol error is
/// raised.
///
class WpLinuxDrmSyncobjSurfaceV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjSurfaceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpLinuxDrmSyncobjSurfaceV1 {name: 'wp_linux_drm_syncobj_surface_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the surface synchronization object
  ///
  /// Destroy this surface synchronization object.
  ///
  /// Any timeline point set by this object with set_acquire_point or
  /// set_release_point since the last commit may be discarded by the
  /// compositor. Any timeline point set by this object before the last
  /// commit will not be affected.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjSurfaceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the acquire timeline point
  ///
  /// Set the timeline point that must be signalled before the compositor may
  /// sample from the buffer attached with wl_surface.attach.
  ///
  /// The 64-bit unsigned value combined from point_hi and point_lo is the
  /// point value.
  ///
  /// The acquire point is double-buffered state, and will be applied on the
  /// next wl_surface.commit request for the associated surface. Thus, it
  /// applies only to the buffer that is attached to the surface at commit
  /// time.
  ///
  /// If an acquire point has already been attached during the same commit
  /// cycle, the new point replaces the old one.
  ///
  /// If the associated wl_surface was destroyed, a no_surface error is
  /// raised.
  ///
  /// If at surface commit time there is a pending acquire timeline point set
  /// but no pending buffer attached, a no_buffer error is raised. If at
  /// surface commit time there is a pending buffer attached but no pending
  /// acquire timeline point set, the no_acquire_point protocol error is
  /// raised.
  ///
  /// [timeline]:
  /// [point_hi]: high 32 bits of the point value
  /// [point_lo]: low 32 bits of the point value
  Result<void, Object> setAcquirePoint(
      WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) {
    logLn(
        "WpLinuxDrmSyncobjSurfaceV1::setAcquirePoint  timeline: $timeline pointHi: $pointHi pointLo: $pointLo");
    var arguments = [timeline, pointHi, pointLo];
    var argTypes = <WaylandType>[
      WaylandType.object,
      WaylandType.uint,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([timeline.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointHi]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointLo]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::setAcquirePoint: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the release timeline point
  ///
  /// Set the timeline point that must be signalled by the compositor when it
  /// has finished its usage of the buffer attached with wl_surface.attach
  /// for the relevant commit.
  ///
  /// Once the timeline point is signaled, and assuming the associated buffer
  /// is not pending release from other wl_surface.commit requests, no
  /// additional explicit or implicit synchronization with the compositor is
  /// required to safely re-use the buffer.
  ///
  /// Note that clients cannot rely on the release point being always
  /// signaled after the acquire point: compositors may release buffers
  /// without ever reading from them. In addition, the compositor may use
  /// different presentation paths for different commits, which may have
  /// different release behavior. As a result, the compositor may signal the
  /// release points in a different order than the client committed them.
  ///
  /// Because signaling a timeline point also signals every previous point,
  /// it is generally not safe to use the same timeline object for the
  /// release points of multiple buffers. The out-of-order signaling
  /// described above may lead to a release point being signaled before the
  /// compositor has finished reading. To avoid this, it is strongly
  /// recommended that each buffer should use a separate timeline for its
  /// release points.
  ///
  /// The 64-bit unsigned value combined from point_hi and point_lo is the
  /// point value.
  ///
  /// The release point is double-buffered state, and will be applied on the
  /// next wl_surface.commit request for the associated surface. Thus, it
  /// applies only to the buffer that is attached to the surface at commit
  /// time.
  ///
  /// If a release point has already been attached during the same commit
  /// cycle, the new point replaces the old one.
  ///
  /// If the associated wl_surface was destroyed, a no_surface error is
  /// raised.
  ///
  /// If at surface commit time there is a pending release timeline point set
  /// but no pending buffer attached, a no_buffer error is raised. If at
  /// surface commit time there is a pending buffer attached but no pending
  /// release timeline point set, the no_release_point protocol error is
  /// raised.
  ///
  /// [timeline]:
  /// [point_hi]: high 32 bits of the point value
  /// [point_lo]: low 32 bits of the point value
  Result<void, Object> setReleasePoint(
      WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) {
    logLn(
        "WpLinuxDrmSyncobjSurfaceV1::setReleasePoint  timeline: $timeline pointHi: $pointHi pointLo: $pointLo");
    var arguments = [timeline, pointHi, pointLo];
    var argTypes = <WaylandType>[
      WaylandType.object,
      WaylandType.uint,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([timeline.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointHi]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointLo]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::setReleasePoint: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

///
///

enum WpLinuxDrmSyncobjSurfaceV1Error {
  /// the associated wl_surface was destroyed
  noSurface("no_surface", 1),

  /// the buffer does not support explicit synchronization
  unsupportedBuffer("unsupported_buffer", 2),

  /// no buffer was attached
  noBuffer("no_buffer", 3),

  /// no acquire timeline point was set
  noAcquirePoint("no_acquire_point", 4),

  /// no release timeline point was set
  noReleasePoint("no_release_point", 5),

  /// acquire and release timeline points are in conflict
  conflictingPoints("conflicting_points", 6);

  const WpLinuxDrmSyncobjSurfaceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpLinuxDrmSyncobjSurfaceV1Error {name: $enumName, value: $enumValue}";
  }
}
