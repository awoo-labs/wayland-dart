// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/color-management/color-management-v1.xml
//
// color_management_v1 Protocol Copyright:
///
/// Copyright 2019 Sebastian Wick
/// Copyright 2019 Erwin Burema
/// Copyright 2020 AMD
/// Copyright 2020-2024 Collabora, Ltd.
/// Copyright 2024 Xaver Hugl
/// Copyright 2022-2025 Red Hat, Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// supported rendering intent
///
/// When this object is created, it shall immediately send this event once
/// for each rendering intent the compositor supports.
///
class WpColorManagerV1SupportedIntentEvent {
  /// rendering intent
  final int renderIntent;

  WpColorManagerV1SupportedIntentEvent(
    this.renderIntent,
  );

  @override
  toString() {
    return "WpColorManagerV1SupportedIntentEvent (renderIntent: $renderIntent)";
  }
}

typedef WpColorManagerV1SupportedIntentEventHandler = void Function(
    WpColorManagerV1SupportedIntentEvent);

/// supported features
///
/// When this object is created, it shall immediately send this event once
/// for each compositor supported feature listed in the enumeration.
///
class WpColorManagerV1SupportedFeatureEvent {
  /// supported feature
  final int feature;

  WpColorManagerV1SupportedFeatureEvent(
    this.feature,
  );

  @override
  toString() {
    return "WpColorManagerV1SupportedFeatureEvent (feature: $feature)";
  }
}

typedef WpColorManagerV1SupportedFeatureEventHandler = void Function(
    WpColorManagerV1SupportedFeatureEvent);

/// supported named transfer characteristic
///
/// When this object is created, it shall immediately send this event once
/// for each named transfer function the compositor supports with the
/// parametric image description creator.
///
class WpColorManagerV1SupportedTfNamedEvent {
  /// Named transfer function
  final int tf;

  WpColorManagerV1SupportedTfNamedEvent(
    this.tf,
  );

  @override
  toString() {
    return "WpColorManagerV1SupportedTfNamedEvent (tf: $tf)";
  }
}

typedef WpColorManagerV1SupportedTfNamedEventHandler = void Function(
    WpColorManagerV1SupportedTfNamedEvent);

/// supported named primaries
///
/// When this object is created, it shall immediately send this event once
/// for each named set of primaries the compositor supports with the
/// parametric image description creator.
///
class WpColorManagerV1SupportedPrimariesNamedEvent {
  /// Named color primaries
  final int primaries;

  WpColorManagerV1SupportedPrimariesNamedEvent(
    this.primaries,
  );

  @override
  toString() {
    return "WpColorManagerV1SupportedPrimariesNamedEvent (primaries: $primaries)";
  }
}

typedef WpColorManagerV1SupportedPrimariesNamedEventHandler = void Function(
    WpColorManagerV1SupportedPrimariesNamedEvent);

/// all features have been sent
///
/// This event is sent when all supported rendering intents, features,
/// transfer functions and named primaries have been sent.
///
class WpColorManagerV1DoneEvent {
  WpColorManagerV1DoneEvent();

  @override
  toString() {
    return "WpColorManagerV1DoneEvent ()";
  }
}

typedef WpColorManagerV1DoneEventHandler = void Function(
    WpColorManagerV1DoneEvent);

/// color manager singleton
///
/// A singleton global interface used for getting color management extensions
/// for wl_surface and wl_output objects, and for creating client defined
/// image description objects. The extension interfaces allow
/// getting the image description of outputs and setting the image
/// description of surfaces.
///
/// Compositors should never remove this global.
///
class WpColorManagerV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpColorManagerV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorManagerV1 {name: 'wp_color_manager_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the color manager
  ///
  /// Destroy the wp_color_manager_v1 object. This does not affect any other
  /// objects in any way.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// create a color management interface for a wl_output
  ///
  /// This creates a new wp_color_management_output_v1 object for the
  /// given wl_output.
  ///
  /// See the wp_color_management_output_v1 interface for more details.
  ///
  /// [id]:
  /// [output]:
  Result<WpColorManagementOutputV1, Object> getOutput(Output output) {
    var id = WpColorManagementOutputV1(innerContext);
    logLn("WpColorManagerV1::getOutput  id: $id output: $output");
    var arguments = [id, output];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([output.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::getOutput: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// create a color management interface for a wl_surface
  ///
  /// If a wp_color_management_surface_v1 object already exists for the given
  /// wl_surface, the protocol error surface_exists is raised.
  ///
  /// This creates a new color wp_color_management_surface_v1 object for the
  /// given wl_surface.
  ///
  /// See the wp_color_management_surface_v1 interface for more details.
  ///
  /// [id]:
  /// [surface]:
  Result<WpColorManagementSurfaceV1, Object> getSurface(Surface surface) {
    var id = WpColorManagementSurfaceV1(innerContext);
    logLn("WpColorManagerV1::getSurface  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::getSurface: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// create a color management feedback interface
  ///
  /// This creates a new color wp_color_management_surface_feedback_v1 object
  /// for the given wl_surface.
  ///
  /// See the wp_color_management_surface_feedback_v1 interface for more
  /// details.
  ///
  /// [id]:
  /// [surface]:
  Result<WpColorManagementSurfaceFeedbackV1, Object> getSurfaceFeedback(
      Surface surface) {
    var id = WpColorManagementSurfaceFeedbackV1(innerContext);
    logLn("WpColorManagerV1::getSurfaceFeedback  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::getSurfaceFeedback: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// make a new ICC-based image description creator object
  ///
  /// Makes a new ICC-based image description creator object with all
  /// properties initially unset. The client can then use the object's
  /// interface to define all the required properties for an image description
  /// and finally create a wp_image_description_v1 object.
  ///
  /// This request can be used when the compositor advertises
  /// wp_color_manager_v1.feature.icc_v2_v4.
  /// Otherwise this request raises the protocol error unsupported_feature.
  ///
  /// [obj]: the new creator object
  Result<WpImageDescriptionCreatorIccV1, Object> createIccCreator() {
    var obj = WpImageDescriptionCreatorIccV1(innerContext);
    logLn("WpColorManagerV1::createIccCreator  obj: $obj");
    var arguments = [obj];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 4])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([obj.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::createIccCreator: $e");
      return Failure(e);
    }
    return Success(obj);
  }

  /// make a new parametric image description creator object
  ///
  /// Makes a new parametric image description creator object with all
  /// properties initially unset. The client can then use the object's
  /// interface to define all the required properties for an image description
  /// and finally create a wp_image_description_v1 object.
  ///
  /// This request can be used when the compositor advertises
  /// wp_color_manager_v1.feature.parametric.
  /// Otherwise this request raises the protocol error unsupported_feature.
  ///
  /// [obj]: the new creator object
  Result<WpImageDescriptionCreatorParamsV1, Object> createParametricCreator() {
    var obj = WpImageDescriptionCreatorParamsV1(innerContext);
    logLn("WpColorManagerV1::createParametricCreator  obj: $obj");
    var arguments = [obj];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 5])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([obj.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::createParametricCreator: $e");
      return Failure(e);
    }
    return Success(obj);
  }

  /// create Windows-scRGB image description object
  ///
  /// This creates a pre-defined image description for the so-called
  /// Windows-scRGB stimulus encoding. This comes from the Windows 10 handling
  /// of its own definition of an scRGB color space for an HDR screen
  /// driven in BT.2100/PQ signalling mode.
  ///
  /// Windows-scRGB uses sRGB (BT.709) color primaries and white point.
  /// The transfer characteristic is extended linear.
  ///
  /// The nominal color channel value range is extended, meaning it includes
  /// negative and greater than 1.0 values. Negative values are used to
  /// escape the sRGB color gamut boundaries. To make use of the extended
  /// range, the client needs to use a pixel format that can represent those
  /// values, e.g. floating-point 16 bits per channel.
  ///
  /// Nominal color value R=G=B=0.0 corresponds to BT.2100/PQ system
  /// 0 cd/m², and R=G=B=1.0 corresponds to BT.2100/PQ system 80 cd/m².
  /// The maximum is R=G=B=125.0 corresponding to 10k cd/m².
  ///
  /// Windows-scRGB is displayed by Windows 10 by converting it to
  /// BT.2100/PQ, maintaining the CIE 1931 chromaticity and mapping the
  /// luminance as above. No adjustment is made to the signal to account
  /// for the viewing conditions.
  ///
  /// The reference white level of Windows-scRGB is unknown. If a
  /// reference white level must be assumed for compositor processing, it
  /// should be R=G=B=2.5375 corresponding to 203 cd/m² of Report ITU-R
  /// BT.2408-7.
  ///
  /// The target color volume of Windows-scRGB is unknown. The color gamut
  /// may be anything between sRGB and BT.2100.
  ///
  /// Note: EGL_EXT_gl_colorspace_scrgb_linear definition differs from
  /// Windows-scRGB by using R=G=B=1.0 as the reference white level, while
  /// Windows-scRGB reference white level is unknown or varies. However,
  /// it seems probable that Windows implements both
  /// EGL_EXT_gl_colorspace_scrgb_linear and Vulkan
  /// VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT as Windows-scRGB.
  ///
  /// This request can be used when the compositor advertises
  /// wp_color_manager_v1.feature.windows_scrgb.
  /// Otherwise this request raises the protocol error unsupported_feature.
  ///
  /// The resulting image description object does not allow get_information
  /// request. The wp_image_description_v1.ready event shall be sent.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> createWindowsScrgb() {
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpColorManagerV1::createWindowsScrgb  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 6])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagerV1::createWindowsScrgb: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// supported rendering intent
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each rendering intent the compositor supports.
  ///
  /// Event handler for SupportedIntent
  /// - [render_intent]: rendering intent
  void onSupportedIntent(WpColorManagerV1SupportedIntentEventHandler handler) {
    _supportedIntentHandler = handler;
  }

  WpColorManagerV1SupportedIntentEventHandler? _supportedIntentHandler;

  /// supported features
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each compositor supported feature listed in the enumeration.
  ///
  /// Event handler for SupportedFeature
  /// - [feature]: supported feature
  void onSupportedFeature(
      WpColorManagerV1SupportedFeatureEventHandler handler) {
    _supportedFeatureHandler = handler;
  }

  WpColorManagerV1SupportedFeatureEventHandler? _supportedFeatureHandler;

  /// supported named transfer characteristic
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each named transfer function the compositor supports with the
  /// parametric image description creator.
  ///
  /// Event handler for SupportedTfNamed
  /// - [tf]: Named transfer function
  void onSupportedTfNamed(
      WpColorManagerV1SupportedTfNamedEventHandler handler) {
    _supportedTfNamedHandler = handler;
  }

  WpColorManagerV1SupportedTfNamedEventHandler? _supportedTfNamedHandler;

  /// supported named primaries
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each named set of primaries the compositor supports with the
  /// parametric image description creator.
  ///
  /// Event handler for SupportedPrimariesNamed
  /// - [primaries]: Named color primaries
  void onSupportedPrimariesNamed(
      WpColorManagerV1SupportedPrimariesNamedEventHandler handler) {
    _supportedPrimariesNamedHandler = handler;
  }

  WpColorManagerV1SupportedPrimariesNamedEventHandler?
      _supportedPrimariesNamedHandler;

  /// all features have been sent
  ///
  /// This event is sent when all supported rendering intents, features,
  /// transfer functions and named primaries have been sent.
  ///
  /// Event handler for Done
  void onDone(WpColorManagerV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  WpColorManagerV1DoneEventHandler? _doneHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpColorManagerV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_supportedIntentHandler != null) {
          var offset = 0;
          final renderIntent =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorManagerV1SupportedIntentEvent(
            renderIntent,
          );
          _supportedIntentHandler!(event);
        }
        break;
      case 1:
        if (_supportedFeatureHandler != null) {
          var offset = 0;
          final feature =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorManagerV1SupportedFeatureEvent(
            feature,
          );
          _supportedFeatureHandler!(event);
        }
        break;
      case 2:
        if (_supportedTfNamedHandler != null) {
          var offset = 0;
          final tf =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorManagerV1SupportedTfNamedEvent(
            tf,
          );
          _supportedTfNamedHandler!(event);
        }
        break;
      case 3:
        if (_supportedPrimariesNamedHandler != null) {
          var offset = 0;
          final primaries =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorManagerV1SupportedPrimariesNamedEvent(
            primaries,
          );
          _supportedPrimariesNamedHandler!(event);
        }
        break;
      case 4:
        if (_doneHandler != null) {
          _doneHandler!(WpColorManagerV1DoneEvent());
        }
        break;
    }
  }
}

///
///

enum WpColorManagerV1Error {
  /// request not supported
  unsupportedFeature("unsupported_feature", 0),

  /// color management surface exists already
  surfaceExists("surface_exists", 1);

  const WpColorManagerV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagerV1Error {name: $enumName, value: $enumValue}";
  }
}

/// rendering intents
///
/// See the ICC.1:2022 specification from the International Color Consortium
/// for more details about rendering intents.
///
/// The principles of ICC defined rendering intents apply with all types of
/// image descriptions, not only those with ICC file profiles.
///
/// Compositors must support the perceptual rendering intent. Other
/// rendering intents are optional.
///

enum WpColorManagerV1RenderIntent {
  /// perceptual
  perceptual("perceptual", 0),

  /// media-relative colorimetric
  relative("relative", 1),

  /// saturation
  saturation("saturation", 2),

  /// ICC-absolute colorimetric
  absolute("absolute", 3),

  /// media-relative colorimetric + black point compensation
  relativeBpc("relative_bpc", 4);

  const WpColorManagerV1RenderIntent(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagerV1RenderIntent {name: $enumName, value: $enumValue}";
  }
}

/// compositor supported features
///

enum WpColorManagerV1Feature {
  /// create_icc_creator request
  iccV2V4("icc_v2_v4", 0),

  /// create_parametric_creator request
  parametric("parametric", 1),

  /// parametric set_primaries request
  setPrimaries("set_primaries", 2),

  /// parametric set_tf_power request
  setTfPower("set_tf_power", 3),

  /// parametric set_luminances request
  setLuminances("set_luminances", 4),

  ///
  setMasteringDisplayPrimaries("set_mastering_display_primaries", 5),

  ///
  extendedTargetVolume("extended_target_volume", 6),

  /// create_windows_scrgb request
  windowsScrgb("windows_scrgb", 7);

  const WpColorManagerV1Feature(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagerV1Feature {name: $enumName, value: $enumValue}";
  }
}

/// named color primaries
///
/// Named color primaries used to encode well-known sets of primaries. H.273
/// is the authority, when it comes to the exact values of primaries and
/// authoritative specifications, where an equivalent code point exists.
///
/// A value of 0 is invalid and will never be present in the list of enums.
///
/// Descriptions do list the specifications for convenience.
///

enum WpColorManagerV1Primaries {
  ///
  srgb("srgb", 1),

  ///
  palM("pal_m", 2),

  ///
  pal("pal", 3),

  ///
  ntsc("ntsc", 4),

  ///
  genericFilm("generic_film", 5),

  ///
  bt2020("bt2020", 6),

  ///
  cie1931Xyz("cie1931_xyz", 7),

  ///
  dciP3("dci_p3", 8),

  ///
  displayP3("display_p3", 9),

  ///
  adobeRgb("adobe_rgb", 10);

  const WpColorManagerV1Primaries(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagerV1Primaries {name: $enumName, value: $enumValue}";
  }
}

/// named transfer functions
///
/// Named transfer functions used to represent well-known transfer
/// characteristics. H.273 is the authority, when it comes to the exact
/// formulas and authoritative specifications, where an equivalent code
/// point exists.
///
/// A value of 0 is invalid and will never be present in the list of enums.
///
/// Descriptions do list the specifications for convenience.
///

enum WpColorManagerV1TransferFunction {
  ///
  bt1886("bt1886", 1),

  ///
  gamma22("gamma22", 2),

  ///
  gamma28("gamma28", 3),

  ///
  st240("st240", 4),

  ///
  extLinear("ext_linear", 5),

  ///
  log100("log_100", 6),

  ///
  log316("log_316", 7),

  ///
  xvycc("xvycc", 8),

  ///
  srgb("srgb", 9),

  ///
  extSrgb("ext_srgb", 10),

  ///
  st2084Pq("st2084_pq", 11),

  ///
  st428("st428", 12),

  ///
  hlg("hlg", 13);

  const WpColorManagerV1TransferFunction(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagerV1TransferFunction {name: $enumName, value: $enumValue}";
  }
}

/// image description changed
///
/// This event is sent whenever the image description of the output changed,
/// followed by one wl_output.done event common to output events across all
/// extensions.
///
/// If the client wants to use the updated image description, it needs to do
/// get_image_description again, because image description objects are
/// immutable.
///
class WpColorManagementOutputV1ImageDescriptionChangedEvent {
  WpColorManagementOutputV1ImageDescriptionChangedEvent();

  @override
  toString() {
    return "WpColorManagementOutputV1ImageDescriptionChangedEvent ()";
  }
}

typedef WpColorManagementOutputV1ImageDescriptionChangedEventHandler = void
    Function(WpColorManagementOutputV1ImageDescriptionChangedEvent);

/// output color properties
///
/// A wp_color_management_output_v1 describes the color properties of an
/// output.
///
/// The wp_color_management_output_v1 is associated with the wl_output global
/// underlying the wl_output object. Therefore the client destroying the
/// wl_output object has no impact, but the compositor removing the output
/// global makes the wp_color_management_output_v1 object inert.
///
class WpColorManagementOutputV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpColorManagementOutputV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorManagementOutputV1 {name: 'wp_color_management_output_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the color management output
  ///
  /// Destroy the color wp_color_management_output_v1 object. This does not
  /// affect any remaining protocol objects.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorManagementOutputV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagementOutputV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// get the image description of the output
  ///
  /// This creates a new wp_image_description_v1 object for the current image
  /// description of the output. There always is exactly one image description
  /// active for an output so the client should destroy the image description
  /// created by earlier invocations of this request. This request is usually
  /// sent as a reaction to the image_description_changed event or when
  /// creating a wp_color_management_output_v1 object.
  ///
  /// The image description of an output represents the color encoding the
  /// output expects. There might be performance and power advantages, as well
  /// as improved color reproduction, if a content update matches the image
  /// description of the output it is being shown on. If a content update is
  /// shown on any other output than the one it matches the image description
  /// of, then the color reproduction on those outputs might be considerably
  /// worse.
  ///
  /// The created wp_image_description_v1 object preserves the image
  /// description of the output from the time the object was created.
  ///
  /// The resulting image description object allows get_information request.
  ///
  /// If this protocol object is inert, the resulting image description object
  /// shall immediately deliver the wp_image_description_v1.failed event with
  /// the no_output cause.
  ///
  /// If the interface version is inadequate for the output's image
  /// description, meaning that the client does not support all the events
  /// needed to deliver the crucial information, the resulting image
  /// description object shall immediately deliver the
  /// wp_image_description_v1.failed event with the low_version cause.
  ///
  /// Otherwise the object shall immediately deliver the ready event.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> getImageDescription() {
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpColorManagementOutputV1::getImageDescription  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagementOutputV1::getImageDescription: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// image description changed
  ///
  /// This event is sent whenever the image description of the output changed,
  /// followed by one wl_output.done event common to output events across all
  /// extensions.
  ///
  /// If the client wants to use the updated image description, it needs to do
  /// get_image_description again, because image description objects are
  /// immutable.
  ///
  /// Event handler for ImageDescriptionChanged
  void onImageDescriptionChanged(
      WpColorManagementOutputV1ImageDescriptionChangedEventHandler handler) {
    _imageDescriptionChangedHandler = handler;
  }

  WpColorManagementOutputV1ImageDescriptionChangedEventHandler?
      _imageDescriptionChangedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpColorManagementOutputV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_imageDescriptionChangedHandler != null) {
          _imageDescriptionChangedHandler!(
              WpColorManagementOutputV1ImageDescriptionChangedEvent());
        }
        break;
    }
  }
}

/// color management extension to a surface
///
/// A wp_color_management_surface_v1 allows the client to set the color
/// space and HDR properties of a surface.
///
/// If the wl_surface associated with the wp_color_management_surface_v1 is
/// destroyed, the wp_color_management_surface_v1 object becomes inert.
///
class WpColorManagementSurfaceV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpColorManagementSurfaceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorManagementSurfaceV1 {name: 'wp_color_management_surface_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the color management interface for a surface
  ///
  /// Destroy the wp_color_management_surface_v1 object and do the same as
  /// unset_image_description.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorManagementSurfaceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagementSurfaceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the surface image description
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// Set the image description of the underlying surface. The image
  /// description and rendering intent are double-buffered state, see
  /// wl_surface.commit.
  ///
  /// It is the client's responsibility to understand the image description
  /// it sets on a surface, and to provide content that matches that image
  /// description. Compositors might convert images to match their own or any
  /// other image descriptions.
  ///
  /// Image descriptions which are not ready (see wp_image_description_v1)
  /// are forbidden in this request, and in such case the protocol error
  /// image_description is raised.
  ///
  /// All image descriptions which are ready (see wp_image_description_v1)
  /// are allowed and must always be accepted by the compositor.
  ///
  /// A rendering intent provides the client's preference on how content
  /// colors should be mapped to each output. The render_intent value must
  /// be one advertised by the compositor with
  /// wp_color_manager_v1.render_intent event, otherwise the protocol error
  /// render_intent is raised.
  ///
  /// When an image description is set on a surface, the Transfer
  /// Characteristics of the image description defines the valid range of
  /// the nominal (real-valued) color channel values. The processing of
  /// out-of-range color channel values is undefined, but compositors are
  /// recommended to clamp the values to the valid range when possible.
  ///
  /// By default, a surface does not have an associated image description
  /// nor a rendering intent. The handling of color on such surfaces is
  /// compositor implementation defined. Compositors should handle such
  /// surfaces as sRGB, but may handle them differently if they have specific
  /// requirements.
  ///
  /// Setting the image description has copy semantics; after this request,
  /// the image description can be immediately destroyed without affecting
  /// the pending state of the surface.
  ///
  /// [image_description]:
  /// [render_intent]: rendering intent
  Result<void, Object> setImageDescription(
      WpImageDescriptionV1 imageDescription, int renderIntent) {
    logLn(
        "WpColorManagementSurfaceV1::setImageDescription  imageDescription: $imageDescription renderIntent: $renderIntent");
    var arguments = [imageDescription, renderIntent];
    var argTypes = <WaylandType>[WaylandType.object, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([renderIntent]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagementSurfaceV1::setImageDescription: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// remove the surface image description
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// This request removes any image description from the surface. See
  /// set_image_description for how a compositor handles a surface without
  /// an image description. This is double-buffered state, see
  /// wl_surface.commit.
  ///
  Result<void, Object> unsetImageDescription() {
    logLn("WpColorManagementSurfaceV1::unsetImageDescription ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpColorManagementSurfaceV1::unsetImageDescription: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// protocol errors
///

enum WpColorManagementSurfaceV1Error {
  /// unsupported rendering intent
  renderIntent("render_intent", 0),

  /// invalid image description
  imageDescription("image_description", 1),

  /// forbidden request on inert object
  inert("inert", 2);

  const WpColorManagementSurfaceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagementSurfaceV1Error {name: $enumName, value: $enumValue}";
  }
}

/// the preferred image description changed
///
/// The preferred image description is the one which likely has the most
/// performance and/or quality benefits for the compositor if used by the
/// client for its wl_surface contents. This event is sent whenever the
/// compositor changes the wl_surface's preferred image description.
///
/// This event sends the identity of the new preferred state as the argument,
/// so clients who are aware of the image description already can reuse it.
/// Otherwise, if the client client wants to know what the preferred image
/// description is, it shall use the get_preferred request.
///
/// The preferred image description is not automatically used for anything.
/// It is only a hint, and clients may set any valid image description with
/// set_image_description, but there might be performance and color accuracy
/// improvements by providing the wl_surface contents in the preferred
/// image description. Therefore clients that can, should render according
/// to the preferred image description
///
class WpColorManagementSurfaceFeedbackV1PreferredChangedEvent {
  /// image description id number
  final int identity;

  WpColorManagementSurfaceFeedbackV1PreferredChangedEvent(
    this.identity,
  );

  @override
  toString() {
    return "WpColorManagementSurfaceFeedbackV1PreferredChangedEvent (identity: $identity)";
  }
}

typedef WpColorManagementSurfaceFeedbackV1PreferredChangedEventHandler = void
    Function(WpColorManagementSurfaceFeedbackV1PreferredChangedEvent);

/// color management extension to a surface
///
/// A wp_color_management_surface_feedback_v1 allows the client to get the
/// preferred image description of a surface.
///
/// If the wl_surface associated with this object is destroyed, the
/// wp_color_management_surface_feedback_v1 object becomes inert.
///
class WpColorManagementSurfaceFeedbackV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpColorManagementSurfaceFeedbackV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorManagementSurfaceFeedbackV1 {name: 'wp_color_management_surface_feedback_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the color management interface for a surface
  ///
  /// Destroy the wp_color_management_surface_feedback_v1 object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorManagementSurfaceFeedbackV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorManagementSurfaceFeedbackV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// get the preferred image description
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// The preferred image description represents the compositor's preferred
  /// color encoding for this wl_surface at the current time. There might be
  /// performance and power advantages, as well as improved color
  /// reproduction, if the image description of a content update matches the
  /// preferred image description.
  ///
  /// This creates a new wp_image_description_v1 object for the currently
  /// preferred image description for the wl_surface. The client should
  /// stop using and destroy the image descriptions created by earlier
  /// invocations of this request for the associated wl_surface.
  /// This request is usually sent as a reaction to the preferred_changed
  /// event or when creating a wp_color_management_surface_feedback_v1 object
  /// if the client is capable of adapting to image descriptions.
  ///
  /// The created wp_image_description_v1 object preserves the preferred image
  /// description of the wl_surface from the time the object was created.
  ///
  /// The resulting image description object allows get_information request.
  ///
  /// If the image description is parametric, the client should set it on its
  /// wl_surface only if the image description is an exact match with the
  /// client content. Particularly if everything else matches, but the target
  /// color volume is greater than what the client needs, the client should
  /// create its own parameric image description with its exact parameters.
  ///
  /// If the interface version is inadequate for the preferred image
  /// description, meaning that the client does not support all the
  /// events needed to deliver the crucial information, the resulting image
  /// description object shall immediately deliver the
  /// wp_image_description_v1.failed event with the low_version cause,
  /// otherwise the object shall immediately deliver the ready event.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> getPreferred() {
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpColorManagementSurfaceFeedbackV1::getPreferred  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpColorManagementSurfaceFeedbackV1::getPreferred: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// get the preferred image description
  ///
  /// The same description as for get_preferred applies, except the returned
  /// image description is guaranteed to be parametric. This is meant for
  /// clients that can only deal with parametric image descriptions.
  ///
  /// If the compositor doesn't support parametric image descriptions, the
  /// unsupported_feature error is emitted.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> getPreferredParametric() {
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpColorManagementSurfaceFeedbackV1::getPreferredParametric  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpColorManagementSurfaceFeedbackV1::getPreferredParametric: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// the preferred image description changed
  ///
  /// The preferred image description is the one which likely has the most
  /// performance and/or quality benefits for the compositor if used by the
  /// client for its wl_surface contents. This event is sent whenever the
  /// compositor changes the wl_surface's preferred image description.
  ///
  /// This event sends the identity of the new preferred state as the argument,
  /// so clients who are aware of the image description already can reuse it.
  /// Otherwise, if the client client wants to know what the preferred image
  /// description is, it shall use the get_preferred request.
  ///
  /// The preferred image description is not automatically used for anything.
  /// It is only a hint, and clients may set any valid image description with
  /// set_image_description, but there might be performance and color accuracy
  /// improvements by providing the wl_surface contents in the preferred
  /// image description. Therefore clients that can, should render according
  /// to the preferred image description
  ///
  /// Event handler for PreferredChanged
  /// - [identity]: image description id number
  void onPreferredChanged(
      WpColorManagementSurfaceFeedbackV1PreferredChangedEventHandler handler) {
    _preferredChangedHandler = handler;
  }

  WpColorManagementSurfaceFeedbackV1PreferredChangedEventHandler?
      _preferredChangedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpColorManagementSurfaceFeedbackV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_preferredChangedHandler != null) {
          var offset = 0;
          final identity =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorManagementSurfaceFeedbackV1PreferredChangedEvent(
            identity,
          );
          _preferredChangedHandler!(event);
        }
        break;
    }
  }
}

/// protocol errors
///

enum WpColorManagementSurfaceFeedbackV1Error {
  /// forbidden request on inert object
  inert("inert", 0),

  /// attempted to use an unsupported feature
  unsupportedFeature("unsupported_feature", 1);

  const WpColorManagementSurfaceFeedbackV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorManagementSurfaceFeedbackV1Error {name: $enumName, value: $enumValue}";
  }
}

/// holder of image description ICC information
///
/// This type of object is used for collecting all the information required
/// to create a wp_image_description_v1 object from an ICC file. A complete
/// set of required parameters consists of these properties:
/// - ICC file
///
/// Each required property must be set exactly once if the client is to create
/// an image description. The set requests verify that a property was not
/// already set. The create request verifies that all required properties are
/// set. There may be several alternative requests for setting each property,
/// and in that case the client must choose one of them.
///
/// Once all properties have been set, the create request must be used to
/// create the image description object, destroying the creator in the
/// process.
///
class WpImageDescriptionCreatorIccV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpImageDescriptionCreatorIccV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpImageDescriptionCreatorIccV1 {name: 'wp_image_description_creator_icc_v1', id: '$objectId', version: '1',}";
  }

  /// Create the image description object from ICC data
  ///
  /// Create an image description object based on the ICC information
  /// previously set on this object. A compositor must parse the ICC data in
  /// some undefined but finite amount of time.
  ///
  /// The completeness of the parameter set is verified. If the set is not
  /// complete, the protocol error incomplete_set is raised. For the
  /// definition of a complete set, see the description of this interface.
  ///
  /// If the particular combination of the information is not supported
  /// by the compositor, the resulting image description object shall
  /// immediately deliver the wp_image_description_v1.failed event with the
  /// 'unsupported' cause. If a valid image description was created from the
  /// information, the wp_image_description_v1.ready event will eventually
  /// be sent instead.
  ///
  /// This request destroys the wp_image_description_creator_icc_v1 object.
  ///
  /// The resulting image description object does not allow get_information
  /// request.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> create() {
    innerContext.unRegister(this);
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpImageDescriptionCreatorIccV1::create  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorIccV1::create: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// set the ICC profile file
  ///
  /// Sets the ICC profile file to be used as the basis of the image
  /// description.
  ///
  /// The data shall be found through the given fd at the given offset, having
  /// the given length. The fd must be seekable and readable. Violating these
  /// requirements raises the bad_fd protocol error.
  ///
  /// If reading the data fails due to an error independent of the client, the
  /// compositor shall send the wp_image_description_v1.failed event on the
  /// created wp_image_description_v1 with the 'operating_system' cause.
  ///
  /// The maximum size of the ICC profile is 32 MB. If length is greater than
  /// that or zero, the protocol error bad_size is raised. If offset + length
  /// exceeds the file size, the protocol error out_of_file is raised.
  ///
  /// A compositor may read the file at any time starting from this request
  /// and only until whichever happens first:
  /// - If create request was issued, the wp_image_description_v1 object
  /// delivers either failed or ready event; or
  /// - if create request was not issued, this
  /// wp_image_description_creator_icc_v1 object is destroyed.
  ///
  /// A compositor shall not modify the contents of the file, and the fd may
  /// be sealed for writes and size changes. The client must ensure to its
  /// best ability that the data does not change while the compositor is
  /// reading it.
  ///
  /// The data must represent a valid ICC profile. The ICC profile version
  /// must be 2 or 4, it must be a 3 channel profile and the class must be
  /// Display or ColorSpace. Violating these requirements will not result in a
  /// protocol error, but will eventually send the
  /// wp_image_description_v1.failed event on the created
  /// wp_image_description_v1 with the 'unsupported' cause.
  ///
  /// See the International Color Consortium specification ICC.1:2022 for more
  /// details about ICC profiles.
  ///
  /// If ICC file has already been set on this object, the protocol error
  /// already_set is raised.
  ///
  /// [icc_profile]: ICC profile
  /// [offset]: byte offset in fd to start of ICC data
  /// [length]: length of ICC data in bytes
  Result<void, Object> setIccFile(int iccProfile, int offset, int length) {
    logLn(
        "WpImageDescriptionCreatorIccV1::setIccFile  iccProfile: $iccProfile offset: $offset length: $length");
    var arguments = [offset, length];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([offset]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([length]).buffer.asUint8List());
    try {
      innerContext.sendMessage(bytesBuilder.toBytes(), iccProfile);
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorIccV1::setIccFile: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// protocol errors
///

enum WpImageDescriptionCreatorIccV1Error {
  /// incomplete parameter set
  incompleteSet("incomplete_set", 0),

  /// property already set
  alreadySet("already_set", 1),

  /// fd not seekable and readable
  badFd("bad_fd", 2),

  /// no or too much data
  badSize("bad_size", 3),

  /// offset + length exceeds file size
  outOfFile("out_of_file", 4);

  const WpImageDescriptionCreatorIccV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpImageDescriptionCreatorIccV1Error {name: $enumName, value: $enumValue}";
  }
}

/// holder of image description parameters
///
/// This type of object is used for collecting all the parameters required
/// to create a wp_image_description_v1 object. A complete set of required
/// parameters consists of these properties:
/// - transfer characteristic function (tf)
/// - chromaticities of primaries and white point (primary color volume)
///
/// The following properties are optional and have a well-defined default
/// if not explicitly set:
/// - primary color volume luminance range
/// - reference white luminance level
/// - mastering display primaries and white point (target color volume)
/// - mastering luminance range
///
/// The following properties are optional and will be ignored
/// if not explicitly set:
/// - maximum content light level
/// - maximum frame-average light level
///
/// Each required property must be set exactly once if the client is to create
/// an image description. The set requests verify that a property was not
/// already set. The create request verifies that all required properties are
/// set. There may be several alternative requests for setting each property,
/// and in that case the client must choose one of them.
///
/// Once all properties have been set, the create request must be used to
/// create the image description object, destroying the creator in the
/// process.
///
class WpImageDescriptionCreatorParamsV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpImageDescriptionCreatorParamsV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpImageDescriptionCreatorParamsV1 {name: 'wp_image_description_creator_params_v1', id: '$objectId', version: '1',}";
  }

  /// Create the image description object using params
  ///
  /// Create an image description object based on the parameters previously
  /// set on this object.
  ///
  /// The completeness of the parameter set is verified. If the set is not
  /// complete, the protocol error incomplete_set is raised. For the
  /// definition of a complete set, see the description of this interface.
  ///
  /// The protocol error invalid_luminance is raised if any of the following
  /// requirements is not met:
  /// - When max_cll is set, it must be greater than min L and less or equal
  /// to max L of the mastering luminance range.
  /// - When max_fall is set, it must be greater than min L and less or equal
  /// to max L of the mastering luminance range.
  /// - When both max_cll and max_fall are set, max_fall must be less or equal
  /// to max_cll.
  ///
  /// If the particular combination of the parameter set is not supported
  /// by the compositor, the resulting image description object shall
  /// immediately deliver the wp_image_description_v1.failed event with the
  /// 'unsupported' cause. If a valid image description was created from the
  /// parameter set, the wp_image_description_v1.ready event will eventually
  /// be sent instead.
  ///
  /// This request destroys the wp_image_description_creator_params_v1
  /// object.
  ///
  /// The resulting image description object does not allow get_information
  /// request.
  ///
  /// [image_description]:
  Result<WpImageDescriptionV1, Object> create() {
    innerContext.unRegister(this);
    var imageDescription = WpImageDescriptionV1(innerContext);
    logLn(
        "WpImageDescriptionCreatorParamsV1::create  imageDescription: $imageDescription");
    var arguments = [imageDescription];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([imageDescription.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::create: $e");
      return Failure(e);
    }
    return Success(imageDescription);
  }

  /// named transfer characteristic
  ///
  /// Sets the transfer characteristic using explicitly enumerated named
  /// functions.
  ///
  /// When the resulting image description is attached to an image, the
  /// content should be encoded and decoded according to the industry standard
  /// practices for the transfer characteristic.
  ///
  /// Only names advertised with wp_color_manager_v1 event supported_tf_named
  /// are allowed. Other values shall raise the protocol error invalid_tf.
  ///
  /// If transfer characteristic has already been set on this object, the
  /// protocol error already_set is raised.
  ///
  /// [tf]: named transfer function
  Result<void, Object> setTfNamed(int tf) {
    logLn("WpImageDescriptionCreatorParamsV1::setTfNamed  tf: $tf");
    var arguments = [tf];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([tf]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::setTfNamed: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// transfer characteristic as a power curve
  ///
  /// Sets the color component transfer characteristic to a power curve with
  /// the given exponent. Negative values are handled by mirroring the
  /// positive half of the curve through the origin. The valid domain and
  /// range of the curve are all finite real numbers. This curve represents
  /// the conversion from electrical to optical color channel values.
  ///
  /// When the resulting image description is attached to an image, the
  /// content should be encoded with the inverse of the power curve.
  ///
  /// The curve exponent shall be multiplied by 10000 to get the argument eexp
  /// value to carry the precision of 4 decimals.
  ///
  /// The curve exponent must be at least 1.0 and at most 10.0. Otherwise the
  /// protocol error invalid_tf is raised.
  ///
  /// If transfer characteristic has already been set on this object, the
  /// protocol error already_set is raised.
  ///
  /// This request can be used when the compositor advertises
  /// wp_color_manager_v1.feature.set_tf_power. Otherwise this request raises
  /// the protocol error unsupported_feature.
  ///
  /// [eexp]: the exponent * 10000
  Result<void, Object> setTfPower(int eexp) {
    logLn("WpImageDescriptionCreatorParamsV1::setTfPower  eexp: $eexp");
    var arguments = [eexp];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([eexp]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::setTfPower: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// named primaries
  ///
  /// Sets the color primaries and white point using explicitly named sets.
  /// This describes the primary color volume which is the basis for color
  /// value encoding.
  ///
  /// Only names advertised with wp_color_manager_v1 event
  /// supported_primaries_named are allowed. Other values shall raise the
  /// protocol error invalid_primaries_named.
  ///
  /// If primaries have already been set on this object, the protocol error
  /// already_set is raised.
  ///
  /// [primaries]: named primaries
  Result<void, Object> setPrimariesNamed(int primaries) {
    logLn(
        "WpImageDescriptionCreatorParamsV1::setPrimariesNamed  primaries: $primaries");
    var arguments = [primaries];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([primaries]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpImageDescriptionCreatorParamsV1::setPrimariesNamed: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// primaries as chromaticity coordinates
  ///
  /// Sets the color primaries and white point using CIE 1931 xy chromaticity
  /// coordinates. This describes the primary color volume which is the basis
  /// for color value encoding.
  ///
  /// Each coordinate value is multiplied by 1 million to get the argument
  /// value to carry precision of 6 decimals.
  ///
  /// If primaries have already been set on this object, the protocol error
  /// already_set is raised.
  ///
  /// This request can be used if the compositor advertises
  /// wp_color_manager_v1.feature.set_primaries. Otherwise this request raises
  /// the protocol error unsupported_feature.
  ///
  /// [r_x]: Red x * 1M
  /// [r_y]: Red y * 1M
  /// [g_x]: Green x * 1M
  /// [g_y]: Green y * 1M
  /// [b_x]: Blue x * 1M
  /// [b_y]: Blue y * 1M
  /// [w_x]: White x * 1M
  /// [w_y]: White y * 1M
  Result<void, Object> setPrimaries(
      int rX, int rY, int gX, int gY, int bX, int bY, int wX, int wY) {
    logLn(
        "WpImageDescriptionCreatorParamsV1::setPrimaries  rX: $rX rY: $rY gX: $gX gY: $gY bX: $bX bY: $bY wX: $wX wY: $wY");
    var arguments = [rX, rY, gX, gY, bX, bY, wX, wY];
    var argTypes = <WaylandType>[
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 4])
            .buffer
            .asUint8List());
    bytesBuilder.add(Int32List.fromList([rX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([rY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([gX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([gY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([bX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([bY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([wX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([wY]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::setPrimaries: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// primary color volume luminance range and reference white
  ///
  /// Sets the primary color volume luminance range and the reference white
  /// luminance level. These values include the minimum display emission
  /// and ambient flare luminances, assumed to be optically additive and have
  /// the chromaticity of the primary color volume white point.
  ///
  /// The default luminances from
  /// https://www.color.org/chardata/rgb/srgb.xalter are
  /// - primary color volume minimum: 0.2 cd/m²
  /// - primary color volume maximum: 80 cd/m²
  /// - reference white: 80 cd/m²
  ///
  /// Setting a named transfer characteristic can imply other default
  /// luminances.
  ///
  /// The default luminances get overwritten when this request is used.
  /// With transfer_function.st2084_pq the given 'max_lum' value is ignored,
  /// and 'max_lum' is taken as 'min_lum' + 10000 cd/m².
  ///
  /// 'min_lum' and 'max_lum' specify the minimum and maximum luminances of
  /// the primary color volume as reproduced by the targeted display.
  ///
  /// 'reference_lum' specifies the luminance of the reference white as
  /// reproduced by the targeted display, and reflects the targeted viewing
  /// environment.
  ///
  /// Compositors should make sure that all content is anchored, meaning that
  /// an input signal level of 'reference_lum' on one image description and
  /// another input signal level of 'reference_lum' on another image
  /// description should produce the same output level, even though the
  /// 'reference_lum' on both image representations can be different.
  ///
  /// 'reference_lum' may be higher than 'max_lum'. In that case reaching
  /// the reference white output level in image content requires the
  /// 'extended_target_volume' feature support.
  ///
  /// If 'max_lum' or 'reference_lum' are less than or equal to 'min_lum',
  /// the protocol error invalid_luminance is raised.
  ///
  /// The minimum luminance is multiplied by 10000 to get the argument
  /// 'min_lum' value and carries precision of 4 decimals. The maximum
  /// luminance and reference white luminance values are unscaled.
  ///
  /// If the primary color volume luminance range and the reference white
  /// luminance level have already been set on this object, the protocol error
  /// already_set is raised.
  ///
  /// This request can be used if the compositor advertises
  /// wp_color_manager_v1.feature.set_luminances. Otherwise this request
  /// raises the protocol error unsupported_feature.
  ///
  /// [min_lum]: minimum luminance (cd/m²) * 10000
  /// [max_lum]: maximum luminance (cd/m²)
  /// [reference_lum]: reference white luminance (cd/m²)
  Result<void, Object> setLuminances(int minLum, int maxLum, int referenceLum) {
    logLn(
        "WpImageDescriptionCreatorParamsV1::setLuminances  minLum: $minLum maxLum: $maxLum referenceLum: $referenceLum");
    var arguments = [minLum, maxLum, referenceLum];
    var argTypes = <WaylandType>[
      WaylandType.uint,
      WaylandType.uint,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 5])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([minLum]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([maxLum]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([referenceLum]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpImageDescriptionCreatorParamsV1::setLuminances: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// mastering display primaries as chromaticity coordinates
  ///
  /// Provides the color primaries and white point of the mastering display
  /// using CIE 1931 xy chromaticity coordinates. This is compatible with the
  /// SMPTE ST 2086 definition of HDR static metadata.
  ///
  /// The mastering display primaries and mastering display luminances define
  /// the target color volume.
  ///
  /// If mastering display primaries are not explicitly set, the target color
  /// volume is assumed to have the same primaries as the primary color volume.
  ///
  /// The target color volume is defined by all tristimulus values between 0.0
  /// and 1.0 (inclusive) of the color space defined by the given mastering
  /// display primaries and white point. The colorimetry is identical between
  /// the container color space and the mastering display color space,
  /// including that no chromatic adaptation is applied even if the white
  /// points differ.
  ///
  /// The target color volume can exceed the primary color volume to allow for
  /// a greater color volume with an existing color space definition (for
  /// example scRGB). It can be smaller than the primary color volume to
  /// minimize gamut and tone mapping distances for big color spaces (HDR
  /// metadata).
  ///
  /// To make use of the entire target color volume a suitable pixel format
  /// has to be chosen (e.g. floating point to exceed the primary color
  /// volume, or abusing limited quantization range as with xvYCC).
  ///
  /// Each coordinate value is multiplied by 1 million to get the argument
  /// value to carry precision of 6 decimals.
  ///
  /// If mastering display primaries have already been set on this object, the
  /// protocol error already_set is raised.
  ///
  /// This request can be used if the compositor advertises
  /// wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
  /// this request raises the protocol error unsupported_feature. The
  /// advertisement implies support only for target color volumes fully
  /// contained within the primary color volume.
  ///
  /// If a compositor additionally supports target color volume exceeding the
  /// primary color volume, it must advertise
  /// wp_color_manager_v1.feature.extended_target_volume. If a client uses
  /// target color volume exceeding the primary color volume and the
  /// compositor does not support it, the result is implementation defined.
  /// Compositors are recommended to detect this case and fail the image
  /// description gracefully, but it may as well result in color artifacts.
  ///
  /// [r_x]: Red x * 1M
  /// [r_y]: Red y * 1M
  /// [g_x]: Green x * 1M
  /// [g_y]: Green y * 1M
  /// [b_x]: Blue x * 1M
  /// [b_y]: Blue y * 1M
  /// [w_x]: White x * 1M
  /// [w_y]: White y * 1M
  Result<void, Object> setMasteringDisplayPrimaries(
      int rX, int rY, int gX, int gY, int bX, int bY, int wX, int wY) {
    logLn(
        "WpImageDescriptionCreatorParamsV1::setMasteringDisplayPrimaries  rX: $rX rY: $rY gX: $gX gY: $gY bX: $bX bY: $bY wX: $wX wY: $wY");
    var arguments = [rX, rY, gX, gY, bX, bY, wX, wY];
    var argTypes = <WaylandType>[
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 6])
            .buffer
            .asUint8List());
    bytesBuilder.add(Int32List.fromList([rX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([rY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([gX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([gY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([bX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([bY]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([wX]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([wY]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpImageDescriptionCreatorParamsV1::setMasteringDisplayPrimaries: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// display mastering luminance range
  ///
  /// Sets the luminance range that was used during the content mastering
  /// process as the minimum and maximum absolute luminance L. These values
  /// include the minimum display emission and ambient flare luminances,
  /// assumed to be optically additive and have the chromaticity of the
  /// primary color volume white point. This should be
  /// compatible with the SMPTE ST 2086 definition of HDR static metadata.
  ///
  /// The mastering display primaries and mastering display luminances define
  /// the target color volume.
  ///
  /// If mastering luminances are not explicitly set, the target color volume
  /// is assumed to have the same min and max luminances as the primary color
  /// volume.
  ///
  /// If max L is less than or equal to min L, the protocol error
  /// invalid_luminance is raised.
  ///
  /// Min L value is multiplied by 10000 to get the argument min_lum value
  /// and carry precision of 4 decimals. Max L value is unscaled for max_lum.
  ///
  /// This request can be used if the compositor advertises
  /// wp_color_manager_v1.feature.set_mastering_display_primaries. Otherwise
  /// this request raises the protocol error unsupported_feature. The
  /// advertisement implies support only for target color volumes fully
  /// contained within the primary color volume.
  ///
  /// If a compositor additionally supports target color volume exceeding the
  /// primary color volume, it must advertise
  /// wp_color_manager_v1.feature.extended_target_volume. If a client uses
  /// target color volume exceeding the primary color volume and the
  /// compositor does not support it, the result is implementation defined.
  /// Compositors are recommended to detect this case and fail the image
  /// description gracefully, but it may as well result in color artifacts.
  ///
  /// [min_lum]: min L (cd/m²) * 10000
  /// [max_lum]: max L (cd/m²)
  Result<void, Object> setMasteringLuminance(int minLum, int maxLum) {
    logLn(
        "WpImageDescriptionCreatorParamsV1::setMasteringLuminance  minLum: $minLum maxLum: $maxLum");
    var arguments = [minLum, maxLum];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 7])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([minLum]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([maxLum]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpImageDescriptionCreatorParamsV1::setMasteringLuminance: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// maximum content light level
  ///
  /// Sets the maximum content light level (max_cll) as defined by CTA-861-H.
  ///
  /// max_cll is undefined by default.
  ///
  /// [max_cll]: Maximum content light level (cd/m²)
  Result<void, Object> setMaxCll(int maxCll) {
    logLn("WpImageDescriptionCreatorParamsV1::setMaxCll  maxCll: $maxCll");
    var arguments = [maxCll];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 8])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([maxCll]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::setMaxCll: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// maximum frame-average light level
  ///
  /// Sets the maximum frame-average light level (max_fall) as defined by
  /// CTA-861-H.
  ///
  /// max_fall is undefined by default.
  ///
  /// [max_fall]: Maximum frame-average light level (cd/m²)
  Result<void, Object> setMaxFall(int maxFall) {
    logLn("WpImageDescriptionCreatorParamsV1::setMaxFall  maxFall: $maxFall");
    var arguments = [maxFall];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 9])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([maxFall]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionCreatorParamsV1::setMaxFall: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// protocol errors
///

enum WpImageDescriptionCreatorParamsV1Error {
  /// incomplete parameter set
  incompleteSet("incomplete_set", 0),

  /// property already set
  alreadySet("already_set", 1),

  /// request not supported
  unsupportedFeature("unsupported_feature", 2),

  /// invalid transfer characteristic
  invalidTf("invalid_tf", 3),

  /// invalid primaries named
  invalidPrimariesNamed("invalid_primaries_named", 4),

  /// invalid luminance value or range
  invalidLuminance("invalid_luminance", 5);

  const WpImageDescriptionCreatorParamsV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpImageDescriptionCreatorParamsV1Error {name: $enumName, value: $enumValue}";
  }
}

/// graceful error on creating the image description
///
/// If creating a wp_image_description_v1 object fails for a reason that is
/// not defined as a protocol error, this event is sent.
///
/// The requests that create image description objects define whether and
/// when this can occur. Only such creation requests can trigger this event.
/// This event cannot be triggered after the image description was
/// successfully formed.
///
/// Once this event has been sent, the wp_image_description_v1 object will
/// never become ready and it can only be destroyed.
///
class WpImageDescriptionV1FailedEvent {
  /// generic reason
  final int cause;

  /// ad hoc human-readable explanation
  final String msg;

  WpImageDescriptionV1FailedEvent(
    this.cause,
    this.msg,
  );

  @override
  toString() {
    return "WpImageDescriptionV1FailedEvent (cause: $cause, msg: $msg)";
  }
}

typedef WpImageDescriptionV1FailedEventHandler = void Function(
    WpImageDescriptionV1FailedEvent);

/// indication that the object is ready to be used
///
/// Once this event has been sent, the wp_image_description_v1 object is
/// deemed "ready". Ready objects can be used to send requests and can be
/// used through other interfaces.
///
/// Every ready wp_image_description_v1 protocol object refers to an
/// underlying image description record in the compositor. Multiple protocol
/// objects may end up referring to the same record. Clients may identify
/// these "copies" by comparing their id numbers: if the numbers from two
/// protocol objects are identical, the protocol objects refer to the same
/// image description record. Two different image description records
/// cannot have the same id number simultaneously. The id number does not
/// change during the lifetime of the image description record.
///
/// The id number is valid only as long as the protocol object is alive. If
/// all protocol objects referring to the same image description record are
/// destroyed, the id number may be recycled for a different image
/// description record.
///
/// Image description id number is not a protocol object id. Zero is
/// reserved as an invalid id number. It shall not be possible for a client
/// to refer to an image description by its id number in protocol. The id
/// numbers might not be portable between Wayland connections. A compositor
/// shall not send an invalid id number.
///
/// This identity allows clients to de-duplicate image description records
/// and avoid get_information request if they already have the image
/// description information.
///
class WpImageDescriptionV1ReadyEvent {
  /// image description id number
  final int identity;

  WpImageDescriptionV1ReadyEvent(
    this.identity,
  );

  @override
  toString() {
    return "WpImageDescriptionV1ReadyEvent (identity: $identity)";
  }
}

typedef WpImageDescriptionV1ReadyEventHandler = void Function(
    WpImageDescriptionV1ReadyEvent);

/// Colorimetric image description
///
/// An image description carries information about the color encoding used on
/// a surface when attached to a wl_surface via
/// wp_color_management_surface_v1.set_image_description. A compositor can use
/// this information to decode pixel values into colorimetrically meaningful
/// quantities.
///
/// Note, that the wp_image_description_v1 object is not ready to be used
/// immediately after creation. The object eventually delivers either the
/// 'ready' or the 'failed' event, specified in all requests creating it. The
/// object is deemed "ready" after receiving the 'ready' event.
///
/// An object which is not ready is illegal to use, it can only be destroyed.
/// Any other request in this interface shall result in the 'not_ready'
/// protocol error. Attempts to use an object which is not ready through other
/// interfaces shall raise protocol errors defined there.
///
/// Once created and regardless of how it was created, a
/// wp_image_description_v1 object always refers to one fixed image
/// description. It cannot change after creation.
///
class WpImageDescriptionV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpImageDescriptionV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpImageDescriptionV1 {name: 'wp_image_description_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the image description
  ///
  /// Destroy this object. It is safe to destroy an object which is not ready.
  ///
  /// Destroying a wp_image_description_v1 object has no side-effects, not
  /// even if a wp_color_management_surface_v1.set_image_description has not
  /// yet been followed by a wl_surface.commit.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpImageDescriptionV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// get information about the image description
  ///
  /// Creates a wp_image_description_info_v1 object which delivers the
  /// information that makes up the image description.
  ///
  /// Not all image description protocol objects allow get_information
  /// request. Whether it is allowed or not is defined by the request that
  /// created the object. If get_information is not allowed, the protocol
  /// error no_information is raised.
  ///
  /// [information]:
  Result<WpImageDescriptionInfoV1, Object> getInformation() {
    var information = WpImageDescriptionInfoV1(innerContext);
    logLn("WpImageDescriptionV1::getInformation  information: $information");
    var arguments = [information];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([information.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpImageDescriptionV1::getInformation: $e");
      return Failure(e);
    }
    return Success(information);
  }

  /// graceful error on creating the image description
  ///
  /// If creating a wp_image_description_v1 object fails for a reason that is
  /// not defined as a protocol error, this event is sent.
  ///
  /// The requests that create image description objects define whether and
  /// when this can occur. Only such creation requests can trigger this event.
  /// This event cannot be triggered after the image description was
  /// successfully formed.
  ///
  /// Once this event has been sent, the wp_image_description_v1 object will
  /// never become ready and it can only be destroyed.
  ///
  /// Event handler for Failed
  /// - [cause]: generic reason
  /// - [msg]: ad hoc human-readable explanation
  void onFailed(WpImageDescriptionV1FailedEventHandler handler) {
    _failedHandler = handler;
  }

  WpImageDescriptionV1FailedEventHandler? _failedHandler;

  /// indication that the object is ready to be used
  ///
  /// Once this event has been sent, the wp_image_description_v1 object is
  /// deemed "ready". Ready objects can be used to send requests and can be
  /// used through other interfaces.
  ///
  /// Every ready wp_image_description_v1 protocol object refers to an
  /// underlying image description record in the compositor. Multiple protocol
  /// objects may end up referring to the same record. Clients may identify
  /// these "copies" by comparing their id numbers: if the numbers from two
  /// protocol objects are identical, the protocol objects refer to the same
  /// image description record. Two different image description records
  /// cannot have the same id number simultaneously. The id number does not
  /// change during the lifetime of the image description record.
  ///
  /// The id number is valid only as long as the protocol object is alive. If
  /// all protocol objects referring to the same image description record are
  /// destroyed, the id number may be recycled for a different image
  /// description record.
  ///
  /// Image description id number is not a protocol object id. Zero is
  /// reserved as an invalid id number. It shall not be possible for a client
  /// to refer to an image description by its id number in protocol. The id
  /// numbers might not be portable between Wayland connections. A compositor
  /// shall not send an invalid id number.
  ///
  /// This identity allows clients to de-duplicate image description records
  /// and avoid get_information request if they already have the image
  /// description information.
  ///
  /// Event handler for Ready
  /// - [identity]: image description id number
  void onReady(WpImageDescriptionV1ReadyEventHandler handler) {
    _readyHandler = handler;
  }

  WpImageDescriptionV1ReadyEventHandler? _readyHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpImageDescriptionV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_failedHandler != null) {
          var offset = 0;
          final cause =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final msgLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final msg = utf8.decode(data.sublist(offset, offset + msgLength - 1));
          offset += msgLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = WpImageDescriptionV1FailedEvent(
            cause,
            msg,
          );
          _failedHandler!(event);
        }
        break;
      case 1:
        if (_readyHandler != null) {
          var offset = 0;
          final identity =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionV1ReadyEvent(
            identity,
          );
          _readyHandler!(event);
        }
        break;
    }
  }
}

/// protocol errors
///

enum WpImageDescriptionV1Error {
  /// attempted to use an object which is not ready
  notReady("not_ready", 0),

  /// get_information not allowed
  noInformation("no_information", 1);

  const WpImageDescriptionV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpImageDescriptionV1Error {name: $enumName, value: $enumValue}";
  }
}

/// generic reason for failure
///

enum WpImageDescriptionV1Cause {
  /// interface version too low
  lowVersion("low_version", 0),

  /// unsupported image description data
  unsupported("unsupported", 1),

  /// error independent of the client
  operatingSystem("operating_system", 2),

  /// the relevant output no longer exists
  noOutput("no_output", 3);

  const WpImageDescriptionV1Cause(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpImageDescriptionV1Cause {name: $enumName, value: $enumValue}";
  }
}

/// end of information
///
/// Signals the end of information events and destroys the object.
///
class WpImageDescriptionInfoV1DoneEvent {
  WpImageDescriptionInfoV1DoneEvent();

  @override
  toString() {
    return "WpImageDescriptionInfoV1DoneEvent ()";
  }
}

typedef WpImageDescriptionInfoV1DoneEventHandler = void Function(
    WpImageDescriptionInfoV1DoneEvent);

/// ICC profile matching the image description
///
/// The icc argument provides a file descriptor to the client which may be
/// memory-mapped to provide the ICC profile matching the image description.
/// The fd is read-only, and if mapped then it must be mapped with
/// MAP_PRIVATE by the client.
///
/// The ICC profile version and other details are determined by the
/// compositor. There is no provision for a client to ask for a specific
/// kind of a profile.
///
class WpImageDescriptionInfoV1IccFileEvent {
  /// ICC profile file descriptor
  final int icc;

  /// ICC profile size, in bytes
  final int iccSize;

  WpImageDescriptionInfoV1IccFileEvent(
    this.icc,
    this.iccSize,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1IccFileEvent (icc: $icc, iccSize: $iccSize)";
  }
}

typedef WpImageDescriptionInfoV1IccFileEventHandler = void Function(
    WpImageDescriptionInfoV1IccFileEvent);

/// primaries as chromaticity coordinates
///
/// Delivers the primary color volume primaries and white point using CIE
/// 1931 xy chromaticity coordinates.
///
/// Each coordinate value is multiplied by 1 million to get the argument
/// value to carry precision of 6 decimals.
///
class WpImageDescriptionInfoV1PrimariesEvent {
  /// Red x * 1M
  final int rX;

  /// Red y * 1M
  final int rY;

  /// Green x * 1M
  final int gX;

  /// Green y * 1M
  final int gY;

  /// Blue x * 1M
  final int bX;

  /// Blue y * 1M
  final int bY;

  /// White x * 1M
  final int wX;

  /// White y * 1M
  final int wY;

  WpImageDescriptionInfoV1PrimariesEvent(
    this.rX,
    this.rY,
    this.gX,
    this.gY,
    this.bX,
    this.bY,
    this.wX,
    this.wY,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1PrimariesEvent (rX: $rX, rY: $rY, gX: $gX, gY: $gY, bX: $bX, bY: $bY, wX: $wX, wY: $wY)";
  }
}

typedef WpImageDescriptionInfoV1PrimariesEventHandler = void Function(
    WpImageDescriptionInfoV1PrimariesEvent);

/// named primaries
///
/// Delivers the primary color volume primaries and white point using an
/// explicitly enumerated named set.
///
class WpImageDescriptionInfoV1PrimariesNamedEvent {
  /// named primaries
  final int primaries;

  WpImageDescriptionInfoV1PrimariesNamedEvent(
    this.primaries,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1PrimariesNamedEvent (primaries: $primaries)";
  }
}

typedef WpImageDescriptionInfoV1PrimariesNamedEventHandler = void Function(
    WpImageDescriptionInfoV1PrimariesNamedEvent);

/// transfer characteristic as a power curve
///
/// The color component transfer characteristic of this image description is
/// a pure power curve. This event provides the exponent of the power
/// function. This curve represents the conversion from electrical to
/// optical pixel or color values.
///
/// The curve exponent has been multiplied by 10000 to get the argument eexp
/// value to carry the precision of 4 decimals.
///
class WpImageDescriptionInfoV1TfPowerEvent {
  /// the exponent * 10000
  final int eexp;

  WpImageDescriptionInfoV1TfPowerEvent(
    this.eexp,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TfPowerEvent (eexp: $eexp)";
  }
}

typedef WpImageDescriptionInfoV1TfPowerEventHandler = void Function(
    WpImageDescriptionInfoV1TfPowerEvent);

/// named transfer characteristic
///
/// Delivers the transfer characteristic using an explicitly enumerated
/// named function.
///
class WpImageDescriptionInfoV1TfNamedEvent {
  /// named transfer function
  final int tf;

  WpImageDescriptionInfoV1TfNamedEvent(
    this.tf,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TfNamedEvent (tf: $tf)";
  }
}

typedef WpImageDescriptionInfoV1TfNamedEventHandler = void Function(
    WpImageDescriptionInfoV1TfNamedEvent);

/// primary color volume luminance range and reference white
///
/// Delivers the primary color volume luminance range and the reference
/// white luminance level. These values include the minimum display emission
/// and ambient flare luminances, assumed to be optically additive and have
/// the chromaticity of the primary color volume white point.
///
/// The minimum luminance is multiplied by 10000 to get the argument
/// 'min_lum' value and carries precision of 4 decimals. The maximum
/// luminance and reference white luminance values are unscaled.
///
class WpImageDescriptionInfoV1LuminancesEvent {
  /// minimum luminance (cd/m²) * 10000
  final int minLum;

  /// maximum luminance (cd/m²)
  final int maxLum;

  /// reference white luminance (cd/m²)
  final int referenceLum;

  WpImageDescriptionInfoV1LuminancesEvent(
    this.minLum,
    this.maxLum,
    this.referenceLum,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1LuminancesEvent (minLum: $minLum, maxLum: $maxLum, referenceLum: $referenceLum)";
  }
}

typedef WpImageDescriptionInfoV1LuminancesEventHandler = void Function(
    WpImageDescriptionInfoV1LuminancesEvent);

/// target primaries as chromaticity coordinates
///
/// Provides the color primaries and white point of the target color volume
/// using CIE 1931 xy chromaticity coordinates. This is compatible with the
/// SMPTE ST 2086 definition of HDR static metadata for mastering displays.
///
/// While primary color volume is about how color is encoded, the target
/// color volume is the actually displayable color volume. If target color
/// volume is equal to the primary color volume, then this event is not
/// sent.
///
/// Each coordinate value is multiplied by 1 million to get the argument
/// value to carry precision of 6 decimals.
///
class WpImageDescriptionInfoV1TargetPrimariesEvent {
  /// Red x * 1M
  final int rX;

  /// Red y * 1M
  final int rY;

  /// Green x * 1M
  final int gX;

  /// Green y * 1M
  final int gY;

  /// Blue x * 1M
  final int bX;

  /// Blue y * 1M
  final int bY;

  /// White x * 1M
  final int wX;

  /// White y * 1M
  final int wY;

  WpImageDescriptionInfoV1TargetPrimariesEvent(
    this.rX,
    this.rY,
    this.gX,
    this.gY,
    this.bX,
    this.bY,
    this.wX,
    this.wY,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TargetPrimariesEvent (rX: $rX, rY: $rY, gX: $gX, gY: $gY, bX: $bX, bY: $bY, wX: $wX, wY: $wY)";
  }
}

typedef WpImageDescriptionInfoV1TargetPrimariesEventHandler = void Function(
    WpImageDescriptionInfoV1TargetPrimariesEvent);

/// target luminance range
///
/// Provides the luminance range that the image description is targeting as
/// the minimum and maximum absolute luminance L. These values include the
/// minimum display emission and ambient flare luminances, assumed to be
/// optically additive and have the chromaticity of the primary color
/// volume white point. This should be compatible with the SMPTE ST 2086
/// definition of HDR static metadata.
///
/// This luminance range is only theoretical and may not correspond to the
/// luminance of light emitted on an actual display.
///
/// Min L value is multiplied by 10000 to get the argument min_lum value and
/// carry precision of 4 decimals. Max L value is unscaled for max_lum.
///
class WpImageDescriptionInfoV1TargetLuminanceEvent {
  /// min L (cd/m²) * 10000
  final int minLum;

  /// max L (cd/m²)
  final int maxLum;

  WpImageDescriptionInfoV1TargetLuminanceEvent(
    this.minLum,
    this.maxLum,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TargetLuminanceEvent (minLum: $minLum, maxLum: $maxLum)";
  }
}

typedef WpImageDescriptionInfoV1TargetLuminanceEventHandler = void Function(
    WpImageDescriptionInfoV1TargetLuminanceEvent);

/// target maximum content light level
///
/// Provides the targeted max_cll of the image description. max_cll is
/// defined by CTA-861-H.
///
/// This luminance is only theoretical and may not correspond to the
/// luminance of light emitted on an actual display.
///
class WpImageDescriptionInfoV1TargetMaxCllEvent {
  /// Maximum content light-level (cd/m²)
  final int maxCll;

  WpImageDescriptionInfoV1TargetMaxCllEvent(
    this.maxCll,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TargetMaxCllEvent (maxCll: $maxCll)";
  }
}

typedef WpImageDescriptionInfoV1TargetMaxCllEventHandler = void Function(
    WpImageDescriptionInfoV1TargetMaxCllEvent);

/// target maximum frame-average light level
///
/// Provides the targeted max_fall of the image description. max_fall is
/// defined by CTA-861-H.
///
/// This luminance is only theoretical and may not correspond to the
/// luminance of light emitted on an actual display.
///
class WpImageDescriptionInfoV1TargetMaxFallEvent {
  /// Maximum frame-average light level (cd/m²)
  final int maxFall;

  WpImageDescriptionInfoV1TargetMaxFallEvent(
    this.maxFall,
  );

  @override
  toString() {
    return "WpImageDescriptionInfoV1TargetMaxFallEvent (maxFall: $maxFall)";
  }
}

typedef WpImageDescriptionInfoV1TargetMaxFallEventHandler = void Function(
    WpImageDescriptionInfoV1TargetMaxFallEvent);

/// Colorimetric image description information
///
/// Sends all matching events describing an image description object exactly
/// once and finally sends the 'done' event.
///
/// This means
/// - if the image description is parametric, it must send
/// - primaries
/// - named_primaries, if applicable
/// - at least one of tf_power and tf_named, as applicable
/// - luminances
/// - target_primaries
/// - target_luminance
/// - if the image description is parametric, it may send, if applicable,
/// - target_max_cll
/// - target_max_fall
/// - if the image description contains an ICC profile, it must send the
/// icc_file event
///
/// Once a wp_image_description_info_v1 object has delivered a 'done' event it
/// is automatically destroyed.
///
/// Every wp_image_description_info_v1 created from the same
/// wp_image_description_v1 shall always return the exact same data.
///
class WpImageDescriptionInfoV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpImageDescriptionInfoV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpImageDescriptionInfoV1 {name: 'wp_image_description_info_v1', id: '$objectId', version: '1',}";
  }

  /// end of information
  ///
  /// Signals the end of information events and destroys the object.
  ///
  /// Event handler for Done
  void onDone(WpImageDescriptionInfoV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  WpImageDescriptionInfoV1DoneEventHandler? _doneHandler;

  /// ICC profile matching the image description
  ///
  /// The icc argument provides a file descriptor to the client which may be
  /// memory-mapped to provide the ICC profile matching the image description.
  /// The fd is read-only, and if mapped then it must be mapped with
  /// MAP_PRIVATE by the client.
  ///
  /// The ICC profile version and other details are determined by the
  /// compositor. There is no provision for a client to ask for a specific
  /// kind of a profile.
  ///
  /// Event handler for IccFile
  /// - [icc]: ICC profile file descriptor
  /// - [icc_size]: ICC profile size, in bytes
  void onIccFile(WpImageDescriptionInfoV1IccFileEventHandler handler) {
    _iccFileHandler = handler;
  }

  WpImageDescriptionInfoV1IccFileEventHandler? _iccFileHandler;

  /// primaries as chromaticity coordinates
  ///
  /// Delivers the primary color volume primaries and white point using CIE
  /// 1931 xy chromaticity coordinates.
  ///
  /// Each coordinate value is multiplied by 1 million to get the argument
  /// value to carry precision of 6 decimals.
  ///
  /// Event handler for Primaries
  /// - [r_x]: Red x * 1M
  /// - [r_y]: Red y * 1M
  /// - [g_x]: Green x * 1M
  /// - [g_y]: Green y * 1M
  /// - [b_x]: Blue x * 1M
  /// - [b_y]: Blue y * 1M
  /// - [w_x]: White x * 1M
  /// - [w_y]: White y * 1M
  void onPrimaries(WpImageDescriptionInfoV1PrimariesEventHandler handler) {
    _primariesHandler = handler;
  }

  WpImageDescriptionInfoV1PrimariesEventHandler? _primariesHandler;

  /// named primaries
  ///
  /// Delivers the primary color volume primaries and white point using an
  /// explicitly enumerated named set.
  ///
  /// Event handler for PrimariesNamed
  /// - [primaries]: named primaries
  void onPrimariesNamed(
      WpImageDescriptionInfoV1PrimariesNamedEventHandler handler) {
    _primariesNamedHandler = handler;
  }

  WpImageDescriptionInfoV1PrimariesNamedEventHandler? _primariesNamedHandler;

  /// transfer characteristic as a power curve
  ///
  /// The color component transfer characteristic of this image description is
  /// a pure power curve. This event provides the exponent of the power
  /// function. This curve represents the conversion from electrical to
  /// optical pixel or color values.
  ///
  /// The curve exponent has been multiplied by 10000 to get the argument eexp
  /// value to carry the precision of 4 decimals.
  ///
  /// Event handler for TfPower
  /// - [eexp]: the exponent * 10000
  void onTfPower(WpImageDescriptionInfoV1TfPowerEventHandler handler) {
    _tfPowerHandler = handler;
  }

  WpImageDescriptionInfoV1TfPowerEventHandler? _tfPowerHandler;

  /// named transfer characteristic
  ///
  /// Delivers the transfer characteristic using an explicitly enumerated
  /// named function.
  ///
  /// Event handler for TfNamed
  /// - [tf]: named transfer function
  void onTfNamed(WpImageDescriptionInfoV1TfNamedEventHandler handler) {
    _tfNamedHandler = handler;
  }

  WpImageDescriptionInfoV1TfNamedEventHandler? _tfNamedHandler;

  /// primary color volume luminance range and reference white
  ///
  /// Delivers the primary color volume luminance range and the reference
  /// white luminance level. These values include the minimum display emission
  /// and ambient flare luminances, assumed to be optically additive and have
  /// the chromaticity of the primary color volume white point.
  ///
  /// The minimum luminance is multiplied by 10000 to get the argument
  /// 'min_lum' value and carries precision of 4 decimals. The maximum
  /// luminance and reference white luminance values are unscaled.
  ///
  /// Event handler for Luminances
  /// - [min_lum]: minimum luminance (cd/m²) * 10000
  /// - [max_lum]: maximum luminance (cd/m²)
  /// - [reference_lum]: reference white luminance (cd/m²)
  void onLuminances(WpImageDescriptionInfoV1LuminancesEventHandler handler) {
    _luminancesHandler = handler;
  }

  WpImageDescriptionInfoV1LuminancesEventHandler? _luminancesHandler;

  /// target primaries as chromaticity coordinates
  ///
  /// Provides the color primaries and white point of the target color volume
  /// using CIE 1931 xy chromaticity coordinates. This is compatible with the
  /// SMPTE ST 2086 definition of HDR static metadata for mastering displays.
  ///
  /// While primary color volume is about how color is encoded, the target
  /// color volume is the actually displayable color volume. If target color
  /// volume is equal to the primary color volume, then this event is not
  /// sent.
  ///
  /// Each coordinate value is multiplied by 1 million to get the argument
  /// value to carry precision of 6 decimals.
  ///
  /// Event handler for TargetPrimaries
  /// - [r_x]: Red x * 1M
  /// - [r_y]: Red y * 1M
  /// - [g_x]: Green x * 1M
  /// - [g_y]: Green y * 1M
  /// - [b_x]: Blue x * 1M
  /// - [b_y]: Blue y * 1M
  /// - [w_x]: White x * 1M
  /// - [w_y]: White y * 1M
  void onTargetPrimaries(
      WpImageDescriptionInfoV1TargetPrimariesEventHandler handler) {
    _targetPrimariesHandler = handler;
  }

  WpImageDescriptionInfoV1TargetPrimariesEventHandler? _targetPrimariesHandler;

  /// target luminance range
  ///
  /// Provides the luminance range that the image description is targeting as
  /// the minimum and maximum absolute luminance L. These values include the
  /// minimum display emission and ambient flare luminances, assumed to be
  /// optically additive and have the chromaticity of the primary color
  /// volume white point. This should be compatible with the SMPTE ST 2086
  /// definition of HDR static metadata.
  ///
  /// This luminance range is only theoretical and may not correspond to the
  /// luminance of light emitted on an actual display.
  ///
  /// Min L value is multiplied by 10000 to get the argument min_lum value and
  /// carry precision of 4 decimals. Max L value is unscaled for max_lum.
  ///
  /// Event handler for TargetLuminance
  /// - [min_lum]: min L (cd/m²) * 10000
  /// - [max_lum]: max L (cd/m²)
  void onTargetLuminance(
      WpImageDescriptionInfoV1TargetLuminanceEventHandler handler) {
    _targetLuminanceHandler = handler;
  }

  WpImageDescriptionInfoV1TargetLuminanceEventHandler? _targetLuminanceHandler;

  /// target maximum content light level
  ///
  /// Provides the targeted max_cll of the image description. max_cll is
  /// defined by CTA-861-H.
  ///
  /// This luminance is only theoretical and may not correspond to the
  /// luminance of light emitted on an actual display.
  ///
  /// Event handler for TargetMaxCll
  /// - [max_cll]: Maximum content light-level (cd/m²)
  void onTargetMaxCll(
      WpImageDescriptionInfoV1TargetMaxCllEventHandler handler) {
    _targetMaxCllHandler = handler;
  }

  WpImageDescriptionInfoV1TargetMaxCllEventHandler? _targetMaxCllHandler;

  /// target maximum frame-average light level
  ///
  /// Provides the targeted max_fall of the image description. max_fall is
  /// defined by CTA-861-H.
  ///
  /// This luminance is only theoretical and may not correspond to the
  /// luminance of light emitted on an actual display.
  ///
  /// Event handler for TargetMaxFall
  /// - [max_fall]: Maximum frame-average light level (cd/m²)
  void onTargetMaxFall(
      WpImageDescriptionInfoV1TargetMaxFallEventHandler handler) {
    _targetMaxFallHandler = handler;
  }

  WpImageDescriptionInfoV1TargetMaxFallEventHandler? _targetMaxFallHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpImageDescriptionInfoV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_doneHandler != null) {
          _doneHandler!(WpImageDescriptionInfoV1DoneEvent());
        }
        break;
      case 1:
        if (fd != -1) {}
        if (_iccFileHandler != null) {
          var offset = 0;
          final icc = fd;
          final iccSize =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1IccFileEvent(
            icc,
            iccSize,
          );
          _iccFileHandler!(event);
        }
        break;
      case 2:
        if (_primariesHandler != null) {
          var offset = 0;
          final rX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final rY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final gX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final gY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final bX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final bY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final wX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final wY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1PrimariesEvent(
            rX,
            rY,
            gX,
            gY,
            bX,
            bY,
            wX,
            wY,
          );
          _primariesHandler!(event);
        }
        break;
      case 3:
        if (_primariesNamedHandler != null) {
          var offset = 0;
          final primaries =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1PrimariesNamedEvent(
            primaries,
          );
          _primariesNamedHandler!(event);
        }
        break;
      case 4:
        if (_tfPowerHandler != null) {
          var offset = 0;
          final eexp =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TfPowerEvent(
            eexp,
          );
          _tfPowerHandler!(event);
        }
        break;
      case 5:
        if (_tfNamedHandler != null) {
          var offset = 0;
          final tf =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TfNamedEvent(
            tf,
          );
          _tfNamedHandler!(event);
        }
        break;
      case 6:
        if (_luminancesHandler != null) {
          var offset = 0;
          final minLum =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final maxLum =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final referenceLum =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1LuminancesEvent(
            minLum,
            maxLum,
            referenceLum,
          );
          _luminancesHandler!(event);
        }
        break;
      case 7:
        if (_targetPrimariesHandler != null) {
          var offset = 0;
          final rX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final rY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final gX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final gY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final bX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final bY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final wX = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final wY = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TargetPrimariesEvent(
            rX,
            rY,
            gX,
            gY,
            bX,
            bY,
            wX,
            wY,
          );
          _targetPrimariesHandler!(event);
        }
        break;
      case 8:
        if (_targetLuminanceHandler != null) {
          var offset = 0;
          final minLum =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final maxLum =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TargetLuminanceEvent(
            minLum,
            maxLum,
          );
          _targetLuminanceHandler!(event);
        }
        break;
      case 9:
        if (_targetMaxCllHandler != null) {
          var offset = 0;
          final maxCll =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TargetMaxCllEvent(
            maxCll,
          );
          _targetMaxCllHandler!(event);
        }
        break;
      case 10:
        if (_targetMaxFallHandler != null) {
          var offset = 0;
          final maxFall =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpImageDescriptionInfoV1TargetMaxFallEvent(
            maxFall,
          );
          _targetMaxFallHandler!(event);
        }
        break;
    }
  }
}
