// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/drm-lease/drm-lease-v1.xml
//
// drm_lease_v1 Protocol Copyright:
///
/// Copyright © 2018 NXP
/// Copyright © 2019 Status Research & Development GmbH.
/// Copyright © 2021 Xaver Hugl
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';

/// open a non-master fd for this DRM node
///
/// The compositor will send this event when the wp_drm_lease_device_v1
/// global is bound, although there are no guarantees as to how long this
/// takes - the compositor might need to wait until regaining DRM master.
/// The included fd is a non-master DRM file descriptor opened for this
/// device and the compositor must not authenticate it.
/// The purpose of this event is to give the client the ability to
/// query DRM and discover information which may help them pick the
/// appropriate DRM device or select the appropriate connectors therein.
///
class WpDrmLeaseDeviceV1DrmFdEvent {
  /// DRM file descriptor
  final int fd;

  WpDrmLeaseDeviceV1DrmFdEvent(
    this.fd,
  );

  @override
  toString() {
    return "WpDrmLeaseDeviceV1DrmFdEvent (fd: $fd)";
  }
}

typedef WpDrmLeaseDeviceV1DrmFdEventHandler = void Function(
    WpDrmLeaseDeviceV1DrmFdEvent);

/// advertise connectors available for leases
///
/// The compositor will use this event to advertise connectors available for
/// lease by clients. This object may be passed into a lease request to
/// indicate the client would like to lease that connector, see
/// wp_drm_lease_request_v1.request_connector for details. While the
/// compositor will make a best effort to not send disconnected connectors,
/// no guarantees can be made.
///
/// The compositor must send the drm_fd event before sending connectors.
/// After the drm_fd event it will send all available connectors but may
/// send additional connectors at any time.
///
class WpDrmLeaseDeviceV1ConnectorEvent {
  ///
  final int id;

  WpDrmLeaseDeviceV1ConnectorEvent(
    this.id,
  );

  @override
  toString() {
    return "WpDrmLeaseDeviceV1ConnectorEvent (id: $id)";
  }
}

typedef WpDrmLeaseDeviceV1ConnectorEventHandler = void Function(
    WpDrmLeaseDeviceV1ConnectorEvent);

/// signals grouping of connectors
///
/// The compositor will send this event to indicate that it has sent all
/// currently available connectors after the client binds to the global or
/// when it updates the connector list, for example on hotplug, drm master
/// change or when a leased connector becomes available again. It will
/// similarly send this event to group wp_drm_lease_connector_v1.withdrawn
/// events of connectors of this device.
///
class WpDrmLeaseDeviceV1DoneEvent {
  WpDrmLeaseDeviceV1DoneEvent();

  @override
  toString() {
    return "WpDrmLeaseDeviceV1DoneEvent ()";
  }
}

typedef WpDrmLeaseDeviceV1DoneEventHandler = void Function(
    WpDrmLeaseDeviceV1DoneEvent);

/// the compositor has finished using the device
///
/// This event is sent in response to the release request and indicates
/// that the compositor is done sending connector events.
/// The compositor will destroy this object immediately after sending the
/// event and it will become invalid. The client should release any
/// resources associated with this device after receiving this event.
///
class WpDrmLeaseDeviceV1ReleasedEvent {
  WpDrmLeaseDeviceV1ReleasedEvent();

  @override
  toString() {
    return "WpDrmLeaseDeviceV1ReleasedEvent ()";
  }
}

typedef WpDrmLeaseDeviceV1ReleasedEventHandler = void Function(
    WpDrmLeaseDeviceV1ReleasedEvent);

/// lease device
///
/// This protocol is used by Wayland compositors which act as Direct
/// Rendering Manager (DRM) masters to lease DRM resources to Wayland
/// clients.
///
/// The compositor will advertise one wp_drm_lease_device_v1 global for each
/// DRM node. Some time after a client binds to the wp_drm_lease_device_v1
/// global, the compositor will send a drm_fd event followed by zero, one or
/// more connector events. After all currently available connectors have been
/// sent, the compositor will send a wp_drm_lease_device_v1.done event.
///
/// When the list of connectors available for lease changes the compositor
/// will send wp_drm_lease_device_v1.connector events for added connectors and
/// wp_drm_lease_connector_v1.withdrawn events for removed connectors,
/// followed by a wp_drm_lease_device_v1.done event.
///
/// The compositor will indicate when a device is gone by removing the global
/// via a wl_registry.global_remove event. Upon receiving this event, the
/// client should destroy any matching wp_drm_lease_device_v1 object.
///
/// To destroy a wp_drm_lease_device_v1 object, the client must first issue
/// a release request. Upon receiving this request, the compositor will
/// immediately send a released event and destroy the object. The client must
/// continue to process and discard drm_fd and connector events until it
/// receives the released event. Upon receiving the released event, the
/// client can safely cleanup any client-side resources.
///
/// Warning! The protocol described in this file is currently in the testing
/// phase. Backward compatible changes may be added together with the
/// corresponding interface version bump. Backward incompatible changes can
/// only be done by creating a new major version of the extension.
///
class WpDrmLeaseDeviceV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpDrmLeaseDeviceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpDrmLeaseDeviceV1 {name: 'wp_drm_lease_device_v1', id: '$objectId', version: '1',}";
  }

  /// create a lease request object
  ///
  /// Creates a lease request object.
  ///
  /// See the documentation for wp_drm_lease_request_v1 for details.
  ///
  /// [id]:
  WpDrmLeaseRequestV1 createLeaseRequest() {
    var id = WpDrmLeaseRequestV1(innerContext);
    logLn("WpDrmLeaseDeviceV1::createLeaseRequest  id: $id");
    var arguments = [id];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }

  /// release this object
  ///
  /// Indicates the client no longer wishes to use this object. In response
  /// the compositor will immediately send the released event and destroy
  /// this object. It can however not guarantee that the client won't receive
  /// connector events before the released event. The client must not send any
  /// requests after this one, doing so will raise a wl_display error.
  /// Existing connectors, lease request and leases will not be affected.
  ///
  void release() {
    logLn("WpDrmLeaseDeviceV1::release ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// open a non-master fd for this DRM node
  ///
  /// The compositor will send this event when the wp_drm_lease_device_v1
  /// global is bound, although there are no guarantees as to how long this
  /// takes - the compositor might need to wait until regaining DRM master.
  /// The included fd is a non-master DRM file descriptor opened for this
  /// device and the compositor must not authenticate it.
  /// The purpose of this event is to give the client the ability to
  /// query DRM and discover information which may help them pick the
  /// appropriate DRM device or select the appropriate connectors therein.
  ///
  /// Event handler for DrmFd
  /// - [fd]: DRM file descriptor
  void onDrmFd(WpDrmLeaseDeviceV1DrmFdEventHandler handler) {
    _drmFdHandler = handler;
  }

  WpDrmLeaseDeviceV1DrmFdEventHandler? _drmFdHandler;

  /// advertise connectors available for leases
  ///
  /// The compositor will use this event to advertise connectors available for
  /// lease by clients. This object may be passed into a lease request to
  /// indicate the client would like to lease that connector, see
  /// wp_drm_lease_request_v1.request_connector for details. While the
  /// compositor will make a best effort to not send disconnected connectors,
  /// no guarantees can be made.
  ///
  /// The compositor must send the drm_fd event before sending connectors.
  /// After the drm_fd event it will send all available connectors but may
  /// send additional connectors at any time.
  ///
  /// Event handler for Connector
  /// - [id]:
  void onConnector(WpDrmLeaseDeviceV1ConnectorEventHandler handler) {
    _connectorHandler = handler;
  }

  WpDrmLeaseDeviceV1ConnectorEventHandler? _connectorHandler;

  /// signals grouping of connectors
  ///
  /// The compositor will send this event to indicate that it has sent all
  /// currently available connectors after the client binds to the global or
  /// when it updates the connector list, for example on hotplug, drm master
  /// change or when a leased connector becomes available again. It will
  /// similarly send this event to group wp_drm_lease_connector_v1.withdrawn
  /// events of connectors of this device.
  ///
  /// Event handler for Done
  void onDone(WpDrmLeaseDeviceV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  WpDrmLeaseDeviceV1DoneEventHandler? _doneHandler;

  /// the compositor has finished using the device
  ///
  /// This event is sent in response to the release request and indicates
  /// that the compositor is done sending connector events.
  /// The compositor will destroy this object immediately after sending the
  /// event and it will become invalid. The client should release any
  /// resources associated with this device after receiving this event.
  ///
  /// Event handler for Released
  void onReleased(WpDrmLeaseDeviceV1ReleasedEventHandler handler) {
    _releasedHandler = handler;
  }

  WpDrmLeaseDeviceV1ReleasedEventHandler? _releasedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpDrmLeaseDeviceV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_drmFdHandler != null) {
          var offset = 0;
          final fd2 = fd;
          var event = WpDrmLeaseDeviceV1DrmFdEvent(
            fd2,
          );
          _drmFdHandler!(event);
        }
        break;
      case 1:
        if (_connectorHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = WpDrmLeaseDeviceV1ConnectorEvent(
            id,
          );
          _connectorHandler!(event);
        }
        break;
      case 2:
        if (_doneHandler != null) {
          _doneHandler!(WpDrmLeaseDeviceV1DoneEvent());
        }
        break;
      case 3:
        if (_releasedHandler != null) {
          _releasedHandler!(WpDrmLeaseDeviceV1ReleasedEvent());
        }
        break;
    }
  }
}

/// name
///
/// The compositor sends this event once the connector is created to
/// indicate the name of this connector. This will not change for the
/// duration of the Wayland session, but is not guaranteed to be consistent
/// between sessions.
///
/// If the compositor supports wl_output version 4 and this connector
/// corresponds to a wl_output, the compositor should use the same name as
/// for the wl_output.
///
class WpDrmLeaseConnectorV1NameEvent {
  /// connector name
  final String name;

  WpDrmLeaseConnectorV1NameEvent(
    this.name,
  );

  @override
  toString() {
    return "WpDrmLeaseConnectorV1NameEvent (name: $name)";
  }
}

typedef WpDrmLeaseConnectorV1NameEventHandler = void Function(
    WpDrmLeaseConnectorV1NameEvent);

/// description
///
/// The compositor sends this event once the connector is created to provide
/// a human-readable description for this connector, which may be presented
/// to the user. The compositor may send this event multiple times over the
/// lifetime of this object to reflect changes in the description.
///
class WpDrmLeaseConnectorV1DescriptionEvent {
  /// connector description
  final String description;

  WpDrmLeaseConnectorV1DescriptionEvent(
    this.description,
  );

  @override
  toString() {
    return "WpDrmLeaseConnectorV1DescriptionEvent (description: $description)";
  }
}

typedef WpDrmLeaseConnectorV1DescriptionEventHandler = void Function(
    WpDrmLeaseConnectorV1DescriptionEvent);

/// connector_id
///
/// The compositor sends this event once the connector is created to
/// indicate the DRM object ID which represents the underlying connector
/// that is being offered. Note that the final lease may include additional
/// object IDs, such as CRTCs and planes.
///
class WpDrmLeaseConnectorV1ConnectorIdEvent {
  /// DRM connector ID
  final int connectorId;

  WpDrmLeaseConnectorV1ConnectorIdEvent(
    this.connectorId,
  );

  @override
  toString() {
    return "WpDrmLeaseConnectorV1ConnectorIdEvent (connectorId: $connectorId)";
  }
}

typedef WpDrmLeaseConnectorV1ConnectorIdEventHandler = void Function(
    WpDrmLeaseConnectorV1ConnectorIdEvent);

/// all properties have been sent
///
/// This event is sent after all properties of a connector have been sent.
/// This allows changes to the properties to be seen as atomic even if they
/// happen via multiple events.
///
class WpDrmLeaseConnectorV1DoneEvent {
  WpDrmLeaseConnectorV1DoneEvent();

  @override
  toString() {
    return "WpDrmLeaseConnectorV1DoneEvent ()";
  }
}

typedef WpDrmLeaseConnectorV1DoneEventHandler = void Function(
    WpDrmLeaseConnectorV1DoneEvent);

/// lease offer withdrawn
///
/// Sent to indicate that the compositor will no longer honor requests for
/// DRM leases which include this connector. The client may still issue a
/// lease request including this connector, but the compositor will send
/// wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
/// encouraged to send this event when they lose access to connector, for
/// example when the connector is hot-unplugged, when the connector gets
/// leased to a client or when the compositor loses DRM master.
///
class WpDrmLeaseConnectorV1WithdrawnEvent {
  WpDrmLeaseConnectorV1WithdrawnEvent();

  @override
  toString() {
    return "WpDrmLeaseConnectorV1WithdrawnEvent ()";
  }
}

typedef WpDrmLeaseConnectorV1WithdrawnEventHandler = void Function(
    WpDrmLeaseConnectorV1WithdrawnEvent);

/// a leasable DRM connector
///
/// Represents a DRM connector which is available for lease. These objects are
/// created via wp_drm_lease_device_v1.connector events, and should be passed
/// to lease requests via wp_drm_lease_request_v1.request_connector.
/// Immediately after the wp_drm_lease_connector_v1 object is created the
/// compositor will send a name, a description, a connector_id and a done
/// event. When the description is updated the compositor will send a
/// description event followed by a done event.
///
class WpDrmLeaseConnectorV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpDrmLeaseConnectorV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpDrmLeaseConnectorV1 {name: 'wp_drm_lease_connector_v1', id: '$objectId', version: '1',}";
  }

  /// destroy connector
  ///
  /// The client may send this request to indicate that it will not use this
  /// connector. Clients are encouraged to send this after receiving the
  /// "withdrawn" event so that the server can release the resources
  /// associated with this connector offer. Neither existing lease requests
  /// nor leases will be affected.
  ///
  void destroy() {
    logLn("WpDrmLeaseConnectorV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// name
  ///
  /// The compositor sends this event once the connector is created to
  /// indicate the name of this connector. This will not change for the
  /// duration of the Wayland session, but is not guaranteed to be consistent
  /// between sessions.
  ///
  /// If the compositor supports wl_output version 4 and this connector
  /// corresponds to a wl_output, the compositor should use the same name as
  /// for the wl_output.
  ///
  /// Event handler for Name
  /// - [name]: connector name
  void onName(WpDrmLeaseConnectorV1NameEventHandler handler) {
    _nameHandler = handler;
  }

  WpDrmLeaseConnectorV1NameEventHandler? _nameHandler;

  /// description
  ///
  /// The compositor sends this event once the connector is created to provide
  /// a human-readable description for this connector, which may be presented
  /// to the user. The compositor may send this event multiple times over the
  /// lifetime of this object to reflect changes in the description.
  ///
  /// Event handler for Description
  /// - [description]: connector description
  void onDescription(WpDrmLeaseConnectorV1DescriptionEventHandler handler) {
    _descriptionHandler = handler;
  }

  WpDrmLeaseConnectorV1DescriptionEventHandler? _descriptionHandler;

  /// connector_id
  ///
  /// The compositor sends this event once the connector is created to
  /// indicate the DRM object ID which represents the underlying connector
  /// that is being offered. Note that the final lease may include additional
  /// object IDs, such as CRTCs and planes.
  ///
  /// Event handler for ConnectorId
  /// - [connector_id]: DRM connector ID
  void onConnectorId(WpDrmLeaseConnectorV1ConnectorIdEventHandler handler) {
    _connectorIdHandler = handler;
  }

  WpDrmLeaseConnectorV1ConnectorIdEventHandler? _connectorIdHandler;

  /// all properties have been sent
  ///
  /// This event is sent after all properties of a connector have been sent.
  /// This allows changes to the properties to be seen as atomic even if they
  /// happen via multiple events.
  ///
  /// Event handler for Done
  void onDone(WpDrmLeaseConnectorV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  WpDrmLeaseConnectorV1DoneEventHandler? _doneHandler;

  /// lease offer withdrawn
  ///
  /// Sent to indicate that the compositor will no longer honor requests for
  /// DRM leases which include this connector. The client may still issue a
  /// lease request including this connector, but the compositor will send
  /// wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
  /// encouraged to send this event when they lose access to connector, for
  /// example when the connector is hot-unplugged, when the connector gets
  /// leased to a client or when the compositor loses DRM master.
  ///
  /// Event handler for Withdrawn
  void onWithdrawn(WpDrmLeaseConnectorV1WithdrawnEventHandler handler) {
    _withdrawnHandler = handler;
  }

  WpDrmLeaseConnectorV1WithdrawnEventHandler? _withdrawnHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpDrmLeaseConnectorV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_nameHandler != null) {
          var offset = 0;
          final nameLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final name =
              utf8.decode(data.sublist(offset, offset + nameLength - 1));
          offset += nameLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = WpDrmLeaseConnectorV1NameEvent(
            name,
          );
          _nameHandler!(event);
        }
        break;
      case 1:
        if (_descriptionHandler != null) {
          var offset = 0;
          final descriptionLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final description =
              utf8.decode(data.sublist(offset, offset + descriptionLength - 1));
          offset +=
              descriptionLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = WpDrmLeaseConnectorV1DescriptionEvent(
            description,
          );
          _descriptionHandler!(event);
        }
        break;
      case 2:
        if (_connectorIdHandler != null) {
          var offset = 0;
          final connectorId =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpDrmLeaseConnectorV1ConnectorIdEvent(
            connectorId,
          );
          _connectorIdHandler!(event);
        }
        break;
      case 3:
        if (_doneHandler != null) {
          _doneHandler!(WpDrmLeaseConnectorV1DoneEvent());
        }
        break;
      case 4:
        if (_withdrawnHandler != null) {
          _withdrawnHandler!(WpDrmLeaseConnectorV1WithdrawnEvent());
        }
        break;
    }
  }
}

/// DRM lease request
///
/// A client that wishes to lease DRM resources will attach the list of
/// connectors advertised with wp_drm_lease_device_v1.connector that they
/// wish to lease, then use wp_drm_lease_request_v1.submit to submit the
/// request.
///
class WpDrmLeaseRequestV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpDrmLeaseRequestV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpDrmLeaseRequestV1 {name: 'wp_drm_lease_request_v1', id: '$objectId', version: '1',}";
  }

  /// request a connector for this lease
  ///
  /// Indicates that the client would like to lease the given connector.
  /// This is only used as a suggestion, the compositor may choose to
  /// include any resources in the lease it issues, or change the set of
  /// leased resources at any time. Compositors are however encouraged to
  /// include the requested connector and other resources necessary
  /// to drive the connected output in the lease.
  ///
  /// Requesting a connector that was created from a different lease device
  /// than this lease request raises the wrong_device error. Requesting a
  /// connector twice will raise the duplicate_connector error.
  ///
  /// [connector]:
  void requestConnector(WpDrmLeaseConnectorV1 connector) {
    logLn("WpDrmLeaseRequestV1::requestConnector  connector: $connector");
    var arguments = [connector];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([connector.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// submit the lease request
  ///
  /// Submits the lease request and creates a new wp_drm_lease_v1 object.
  /// After calling submit the compositor will immediately destroy this
  /// object, issuing any more requests will cause a wl_display error.
  /// The compositor doesn't make any guarantees about the events of the
  /// lease object, clients cannot expect an immediate response.
  /// Not requesting any connectors before submitting the lease request
  /// will raise the empty_lease error.
  ///
  /// [id]:
  WpDrmLeaseV1 submit() {
    var id = WpDrmLeaseV1(innerContext);
    logLn("WpDrmLeaseRequestV1::submit  id: $id");
    var arguments = [id];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
    return id;
  }
}

///
///

enum WpDrmLeaseRequestV1Error {
  /// requested a connector from a different lease device
  wrongDevice("wrong_device", 0),

  /// requested a connector twice
  duplicateConnector("duplicate_connector", 1),

  /// requested a lease without requesting a connector
  emptyLease("empty_lease", 2);

  const WpDrmLeaseRequestV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpDrmLeaseRequestV1Error {name: $enumName, value: $enumValue}";
  }
}

/// shares the DRM file descriptor
///
/// This event returns a file descriptor suitable for use with DRM-related
/// ioctls. The client should use drmModeGetLease to enumerate the DRM
/// objects which have been leased to them. The compositor guarantees it
/// will not use the leased DRM objects itself until it sends the finished
/// event. If the compositor cannot or will not grant a lease for the
/// requested connectors, it will not send this event, instead sending the
/// finished event.
///
/// The compositor will send this event at most once during this objects
/// lifetime.
///
class WpDrmLeaseV1LeaseFdEvent {
  /// leased DRM file descriptor
  final int leasedFd;

  WpDrmLeaseV1LeaseFdEvent(
    this.leasedFd,
  );

  @override
  toString() {
    return "WpDrmLeaseV1LeaseFdEvent (leasedFd: $leasedFd)";
  }
}

typedef WpDrmLeaseV1LeaseFdEventHandler = void Function(
    WpDrmLeaseV1LeaseFdEvent);

/// sent when the lease has been revoked
///
/// The compositor uses this event to either reject a lease request, or if
/// it previously sent a lease_fd, to notify the client that the lease has
/// been revoked. If the client requires a new lease, they should destroy
/// this object and submit a new lease request. The compositor will send
/// no further events for this object after sending the finish event.
/// Compositors should revoke the lease when any of the leased resources
/// become unavailable, namely when a hot-unplug occurs or when the
/// compositor loses DRM master.
///
class WpDrmLeaseV1FinishedEvent {
  WpDrmLeaseV1FinishedEvent();

  @override
  toString() {
    return "WpDrmLeaseV1FinishedEvent ()";
  }
}

typedef WpDrmLeaseV1FinishedEventHandler = void Function(
    WpDrmLeaseV1FinishedEvent);

/// a DRM lease
///
/// A DRM lease object is used to transfer the DRM file descriptor to the
/// client and manage the lifetime of the lease.
///
/// Some time after the wp_drm_lease_v1 object is created, the compositor
/// will reply with the lease request's result. If the lease request is
/// granted, the compositor will send a lease_fd event. If the lease request
/// is denied, the compositor will send a finished event without a lease_fd
/// event.
///
class WpDrmLeaseV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpDrmLeaseV1(this.innerContext) : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpDrmLeaseV1 {name: 'wp_drm_lease_v1', id: '$objectId', version: '1',}";
  }

  /// destroys the lease object
  ///
  /// The client should send this to indicate that it no longer wishes to use
  /// this lease. The compositor should use drmModeRevokeLease on the
  /// appropriate file descriptor, if necessary.
  ///
  void destroy() {
    logLn("WpDrmLeaseV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    innerContext.sendMessage(bytesBuilder.toBytes());
  }

  /// shares the DRM file descriptor
  ///
  /// This event returns a file descriptor suitable for use with DRM-related
  /// ioctls. The client should use drmModeGetLease to enumerate the DRM
  /// objects which have been leased to them. The compositor guarantees it
  /// will not use the leased DRM objects itself until it sends the finished
  /// event. If the compositor cannot or will not grant a lease for the
  /// requested connectors, it will not send this event, instead sending the
  /// finished event.
  ///
  /// The compositor will send this event at most once during this objects
  /// lifetime.
  ///
  /// Event handler for LeaseFd
  /// - [leased_fd]: leased DRM file descriptor
  void onLeaseFd(WpDrmLeaseV1LeaseFdEventHandler handler) {
    _leaseFdHandler = handler;
  }

  WpDrmLeaseV1LeaseFdEventHandler? _leaseFdHandler;

  /// sent when the lease has been revoked
  ///
  /// The compositor uses this event to either reject a lease request, or if
  /// it previously sent a lease_fd, to notify the client that the lease has
  /// been revoked. If the client requires a new lease, they should destroy
  /// this object and submit a new lease request. The compositor will send
  /// no further events for this object after sending the finish event.
  /// Compositors should revoke the lease when any of the leased resources
  /// become unavailable, namely when a hot-unplug occurs or when the
  /// compositor loses DRM master.
  ///
  /// Event handler for Finished
  void onFinished(WpDrmLeaseV1FinishedEventHandler handler) {
    _finishedHandler = handler;
  }

  WpDrmLeaseV1FinishedEventHandler? _finishedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpDrmLeaseV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_leaseFdHandler != null) {
          var offset = 0;
          final leasedFd = fd;
          var event = WpDrmLeaseV1LeaseFdEvent(
            leasedFd,
          );
          _leaseFdHandler!(event);
        }
        break;
      case 1:
        if (_finishedHandler != null) {
          _finishedHandler!(WpDrmLeaseV1FinishedEvent());
        }
        break;
    }
  }
}
