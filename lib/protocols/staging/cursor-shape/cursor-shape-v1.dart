// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/cursor-shape/cursor-shape-v1.xml
//
// cursor_shape_v1 Protocol Copyright:
///
/// Copyright 2018 The Chromium Authors
/// Copyright 2023 Simon Ser
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:typed_data';
import 'package:wayland/protocols/unstable/tablet/tablet-unstable-v2.dart';


/// cursor shape manager
///
/// This global offers an alternative, optional way to set cursor images. This
/// new way uses enumerated cursors instead of a wl_surface like
/// wl_pointer.set_cursor does.
///
/// Warning! The protocol described in this file is currently in the testing
/// phase. Backward compatible changes may be added together with the
/// corresponding interface version bump. Backward incompatible changes can
/// only be done by creating a new major version of the extension.
///
class WpCursorShapeManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpCursorShapeManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpCursorShapeManagerV1 {name: 'wp_cursor_shape_manager_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the manager
  ///
  /// Destroy the cursor shape manager.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpCursorShapeManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// manage the cursor shape of a pointer device
  ///
  /// Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
  ///
  /// [cursor_shape_device]:
  /// [pointer]:
  Result<WpCursorShapeDeviceV1, Object> getPointer(Pointer pointer) {
    var cursorShapeDevice = WpCursorShapeDeviceV1(innerContext);
    logLn(
        "WpCursorShapeManagerV1::getPointer  cursorShapeDevice: $cursorShapeDevice pointer: $pointer");
    var arguments = [cursorShapeDevice, pointer];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([cursorShapeDevice.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([pointer.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::getPointer: $e");
      return Failure(e);
    }
    return Success(cursorShapeDevice);
  }

  /// manage the cursor shape of a tablet tool device
  ///
  /// Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
  ///
  /// [cursor_shape_device]:
  /// [tablet_tool]:
  Result<WpCursorShapeDeviceV1, Object> getTabletToolV2(
      ZwpTabletToolV2 tabletTool) {
    var cursorShapeDevice = WpCursorShapeDeviceV1(innerContext);
    logLn(
        "WpCursorShapeManagerV1::getTabletToolV2  cursorShapeDevice: $cursorShapeDevice tabletTool: $tabletTool");
    var arguments = [cursorShapeDevice, tabletTool];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([cursorShapeDevice.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([tabletTool.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::getTabletToolV2: $e");
      return Failure(e);
    }
    return Success(cursorShapeDevice);
  }
}

/// cursor shape for a device
///
/// This interface allows clients to set the cursor shape.
///
class WpCursorShapeDeviceV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpCursorShapeDeviceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpCursorShapeDeviceV1 {name: 'wp_cursor_shape_device_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the cursor shape device
  ///
  /// Destroy the cursor shape device.
  ///
  /// The device cursor shape remains unchanged.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpCursorShapeDeviceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpCursorShapeDeviceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set device cursor to the shape
  ///
  /// Sets the device cursor to the specified shape. The compositor will
  /// change the cursor image based on the specified shape.
  ///
  /// The cursor actually changes only if the input device focus is one of
  /// the requesting client's surfaces. If any, the previous cursor image
  /// (surface or shape) is replaced.
  ///
  /// The "shape" argument must be a valid enum entry, otherwise the
  /// invalid_shape protocol error is raised.
  ///
  /// This is similar to the wl_pointer.set_cursor and
  /// zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
  /// shape instead of contents in the form of a surface. Clients can mix
  /// set_cursor and set_shape requests.
  ///
  /// The serial parameter must match the latest wl_pointer.enter or
  /// zwp_tablet_tool_v2.proximity_in serial number sent to the client.
  /// Otherwise the request will be ignored.
  ///
  /// [serial]: serial number of the enter event
  /// [shape]:
  Result<void, Object> setShape(int serial, int shape) {
    logLn("WpCursorShapeDeviceV1::setShape  serial: $serial shape: $shape");
    var arguments = [serial, shape];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([shape]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpCursorShapeDeviceV1::setShape: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// cursor shapes
///
/// This enum describes cursor shapes.
///
/// The names are taken from the CSS W3C specification:
/// https://w3c.github.io/csswg-drafts/css-ui/#cursor
///

enum WpCursorShapeDeviceV1Shape {
  /// default cursor
  defaulted("default", 1),

  /// a context menu is available for the object under the cursor
  contextMenu("context_menu", 2),

  /// help is available for the object under the cursor
  help("help", 3),

  /// pointer that indicates a link or another interactive element
  pointer("pointer", 4),

  /// progress indicator
  progress("progress", 5),

  /// program is busy, user should wait
  wait("wait", 6),

  /// a cell or set of cells may be selected
  cell("cell", 7),

  /// simple crosshair
  crosshair("crosshair", 8),

  /// text may be selected
  text("text", 9),

  /// vertical text may be selected
  verticalText("vertical_text", 10),

  /// drag-and-drop: alias of/shortcut to something is to be created
  alias("alias", 11),

  /// drag-and-drop: something is to be copied
  copy("copy", 12),

  /// drag-and-drop: something is to be moved
  move("move", 13),

  /// drag-and-drop: the dragged item cannot be dropped at the current cursor location
  noDrop("no_drop", 14),

  /// drag-and-drop: the requested action will not be carried out
  notAllowed("not_allowed", 15),

  /// drag-and-drop: something can be grabbed
  grab("grab", 16),

  /// drag-and-drop: something is being grabbed
  grabbing("grabbing", 17),

  /// resizing: the east border is to be moved
  eResize("e_resize", 18),

  /// resizing: the north border is to be moved
  nResize("n_resize", 19),

  /// resizing: the north-east corner is to be moved
  neResize("ne_resize", 20),

  /// resizing: the north-west corner is to be moved
  nwResize("nw_resize", 21),

  /// resizing: the south border is to be moved
  sResize("s_resize", 22),

  /// resizing: the south-east corner is to be moved
  seResize("se_resize", 23),

  /// resizing: the south-west corner is to be moved
  swResize("sw_resize", 24),

  /// resizing: the west border is to be moved
  wResize("w_resize", 25),

  /// resizing: the east and west borders are to be moved
  ewResize("ew_resize", 26),

  /// resizing: the north and south borders are to be moved
  nsResize("ns_resize", 27),

  /// resizing: the north-east and south-west corners are to be moved
  neswResize("nesw_resize", 28),

  /// resizing: the north-west and south-east corners are to be moved
  nwseResize("nwse_resize", 29),

  /// resizing: that the item/column can be resized horizontally
  colResize("col_resize", 30),

  /// resizing: that the item/row can be resized vertically
  rowResize("row_resize", 31),

  /// something can be scrolled in any direction
  allScroll("all_scroll", 32),

  /// something can be zoomed in
  zoomIn("zoom_in", 33),

  /// something can be zoomed out
  zoomOut("zoom_out", 34);

  const WpCursorShapeDeviceV1Shape(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpCursorShapeDeviceV1Shape {name: $enumName, value: $enumValue}";
  }
}

///
///

enum WpCursorShapeDeviceV1Error {
  /// the specified shape value is invalid
  invalidShape("invalid_shape", 1);

  const WpCursorShapeDeviceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpCursorShapeDeviceV1Error {name: $enumName, value: $enumValue}";
  }
}
