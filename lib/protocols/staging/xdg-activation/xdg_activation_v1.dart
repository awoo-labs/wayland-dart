// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/xdg-activation/xdg-activation-v1.xml
//
// xdg_activation_v1 Protocol Copyright: 
/// 
/// Copyright © 2020 Aleix Pol Gonzalez <aleixpol@kde.org>
/// Copyright © 2020 Carlos Garnacho <carlosg@gnome.org>
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:result_dart/result_dart.dart';


/// interface for activating surfaces
/// 
/// A global interface used for informing the compositor about applications
/// being activated or started, or for applications to request to be
/// activated.
/// 
class XdgActivationV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  XdgActivationV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "XdgActivationV1 {name: 'xdg_activation_v1', id: '$objectId', version: '1',}";
}

/// destroy the xdg_activation object
/// 
/// Notify the compositor that the xdg_activation object will no longer be
/// used.
/// 
/// The child objects created via this interface are unaffected and should
/// be destroyed separately.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("XdgActivationV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// requests a token
/// 
/// Creates an xdg_activation_token_v1 object that will provide
/// the initiating client with a unique token for this activation. This
/// token should be offered to the clients to be activated.
/// 
/// [id]:
  Result<XdgActivationTokenV1,Object> getActivationToken() {
  var id =  XdgActivationTokenV1(innerContext);
    logLn("XdgActivationV1::getActivationToken  id: $id");
var arguments = [id];var argTypes = <WaylandType>[WaylandType.newId];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationV1::getActivationToken: $e");
   return Failure(e);
    }
    return Success(id);
  }

/// notify new interaction being available
/// 
/// Requests surface activation. It's up to the compositor to display
/// this information as desired, for example by placing the surface above
/// the rest.
/// 
/// The compositor may know who requested this by checking the activation
/// token and might decide not to follow through with the activation if it's
/// considered unwanted.
/// 
/// Compositors can ignore unknown activation tokens when an invalid
/// token is passed.
/// 
/// [token]: the activation token of the initiating client
/// [surface]: the wl_surface to activate
  Result<void,Object> activate(String token, Surface surface) {
    logLn("XdgActivationV1::activate  token: $token surface: $surface");
var arguments = [token, surface];var argTypes = <WaylandType>[WaylandType.string, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 2]).buffer.asUint8List());
    final tokenBytes = utf8.encode(token);
    bytesBuilder.add(Uint32List.fromList([tokenBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(tokenBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) { bytesBuilder.add([0]); } // Padding
    bytesBuilder.add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationV1::activate: $e");
   return Failure(e);
    }
    return Success(Object());
  }

}


/// the exported activation token
/// 
/// The 'done' event contains the unique token of this activation request
/// and notifies that the provider is done.
/// 
class XdgActivationTokenV1DoneEvent {
/// the exported activation token
  final String token;

  XdgActivationTokenV1DoneEvent(
this.token,

);

@override
toString(){
return "XdgActivationTokenV1DoneEvent (token: $token)";
}
}

typedef XdgActivationTokenV1DoneEventHandler = void Function(XdgActivationTokenV1DoneEvent);


/// an exported activation handle
/// 
/// An object for setting up a token and receiving a token handle that can
/// be passed as an activation token to another client.
/// 
/// The object is created using the xdg_activation_v1.get_activation_token
/// request. This object should then be populated with the app_id, surface
/// and serial information and committed. The compositor shall then issue a
/// done event with the token. In case the request's parameters are invalid,
/// the compositor will provide an invalid token.
/// 
class XdgActivationTokenV1 extends Proxy implements Dispatcher{
  final Context innerContext;
  final version = 1;

  XdgActivationTokenV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "XdgActivationTokenV1 {name: 'xdg_activation_token_v1', id: '$objectId', version: '1',}";
}

/// specifies the seat and serial of the activating event
/// 
/// Provides information about the seat and serial event that requested the
/// token.
/// 
/// The serial can come from an input or focus event. For instance, if a
/// click triggers the launch of a third-party client, the launcher client
/// should send a set_serial request with the serial and seat from the
/// wl_pointer.button event.
/// 
/// Some compositors might refuse to activate toplevels when the token
/// doesn't have a valid and recent enough event serial.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [serial]: the serial of the event that triggered the activation
/// [seat]: the wl_seat of the event
  Result<void,Object> setSerial(int serial, Seat seat) {
    logLn("XdgActivationTokenV1::setSerial  serial: $serial seat: $seat");
var arguments = [serial, seat];var argTypes = <WaylandType>[WaylandType.uint, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationTokenV1::setSerial: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// specifies the application being activated
/// 
/// The requesting client can specify an app_id to associate the token
/// being created with it.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [app_id]: the application id of the client being activated.
  Result<void,Object> setAppId(String appId) {
    logLn("XdgActivationTokenV1::setAppId  appId: $appId");
var arguments = [appId];var argTypes = <WaylandType>[WaylandType.string];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    final appIdBytes = utf8.encode(appId);
    bytesBuilder.add(Uint32List.fromList([appIdBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(appIdBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) { bytesBuilder.add([0]); } // Padding
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationTokenV1::setAppId: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// specifies the surface requesting activation
/// 
/// This request sets the surface requesting the activation. Note, this is
/// different from the surface that will be activated.
/// 
/// Some compositors might refuse to activate toplevels when the token
/// doesn't have a requesting surface.
/// 
/// Must be sent before commit. This information is optional.
/// 
/// [surface]: the requesting surface
  Result<void,Object> setSurface(Surface surface) {
    logLn("XdgActivationTokenV1::setSurface  surface: $surface");
var arguments = [surface];var argTypes = <WaylandType>[WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 2]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationTokenV1::setSurface: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// issues the token request
/// 
/// Requests an activation token based on the different parameters that
/// have been offered through set_serial, set_surface and set_app_id.
/// 
  Result<void,Object> commit() {
    logLn("XdgActivationTokenV1::commit ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 3]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationTokenV1::commit: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// destroy the xdg_activation_token_v1 object
/// 
/// Notify the compositor that the xdg_activation_token_v1 object will no
/// longer be used. The received token stays valid.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("XdgActivationTokenV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 4]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in XdgActivationTokenV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// the exported activation token
/// 
/// The 'done' event contains the unique token of this activation request
/// and notifies that the provider is done.
/// 
/// Event handler for Done
/// - [token]: the exported activation token
 void onDone(XdgActivationTokenV1DoneEventHandler handler) {
   _doneHandler = handler;
 }

 XdgActivationTokenV1DoneEventHandler? _doneHandler;

 @override
 void dispatch(int opcode, int fd, Uint8List data) {
logLn("XdgActivationTokenV1.dispatch($opcode, $fd, $data)");
   switch (opcode) {     case 0:

       if (_doneHandler != null) {
var offset = 0;
final tokenLength = ByteData.view(data.buffer).getUint32(offset, Endian.little);
offset += 4;
final token = utf8.decode(data.sublist(offset, offset + tokenLength - 1));
offset += tokenLength; // Skip the string bytes and null terminator
while (offset % 4 != 0) { offset++; } // Padding
var event = XdgActivationTokenV1DoneEvent(
token,
        );
         _doneHandler!(event);
       }
       break;
   }
 }
}

/// 
/// 

enum XdgActivationTokenV1Error {
/// The token has already been used previously
  alreadyUsed("already_used", 0);
const XdgActivationTokenV1Error(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "XdgActivationTokenV1Error {name: $enumName, value: $enumValue}";
}
}

