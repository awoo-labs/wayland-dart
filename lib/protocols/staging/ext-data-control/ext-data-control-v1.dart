// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/ext-data-control/ext-data-control-v1.xml
//
// ext_data_control_v1 Protocol Copyright:
///
/// Copyright © 2018 Simon Ser
/// Copyright © 2019 Ivan Molodetskikh
/// Copyright © 2024 Neal Gompa
///
/// Permission to use, copy, modify, distribute, and sell this
/// software and its documentation for any purpose is hereby granted
/// without fee, provided that the above copyright notice appear in
/// all copies and that both that copyright notice and this permission
/// notice appear in supporting documentation, and that the name of
/// the copyright holders not be used in advertising or publicity
/// pertaining to distribution of the software without specific,
/// written prior permission.  The copyright holders make no
/// representations about the suitability of this software for any
/// purpose.  It is provided "as is" without express or implied
/// warranty.
///
/// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
/// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
/// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
/// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
/// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
/// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
/// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
/// THIS SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// manager to control data devices
///
/// This interface is a manager that allows creating per-seat data device
/// controls.
///
class ExtDataControlManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ExtDataControlManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtDataControlManagerV1 {name: 'ext_data_control_manager_v1', id: '$objectId', version: '1',}";
  }

  /// create a new data source
  ///
  /// Create a new data source.
  ///
  /// [id]: data source to create
  Result<ExtDataControlSourceV1, Object> createDataSource() {
    var id = ExtDataControlSourceV1(innerContext);
    logLn("ExtDataControlManagerV1::createDataSource  id: $id");
    var arguments = [id];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlManagerV1::createDataSource: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// get a data device for a seat
  ///
  /// Create a data device that can be used to manage a seat's selection.
  ///
  /// [id]:
  /// [seat]:
  Result<ExtDataControlDeviceV1, Object> getDataDevice(Seat seat) {
    var id = ExtDataControlDeviceV1(innerContext);
    logLn("ExtDataControlManagerV1::getDataDevice  id: $id seat: $seat");
    var arguments = [id, seat];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([seat.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlManagerV1::getDataDevice: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// destroy the manager
  ///
  /// All objects created by the manager will still remain valid, until their
  /// appropriate destroy request has been called.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtDataControlManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// introduce a new ext_data_control_offer
///
/// The data_offer event introduces a new ext_data_control_offer object,
/// which will subsequently be used in either the
/// ext_data_control_device.selection event (for the regular clipboard
/// selections) or the ext_data_control_device.primary_selection event (for
/// the primary clipboard selections). Immediately following the
/// ext_data_control_device.data_offer event, the new data_offer object
/// will send out ext_data_control_offer.offer events to describe the MIME
/// types it offers.
///
class ExtDataControlDeviceV1DataOfferEvent {
  ///
  final int id;

  ExtDataControlDeviceV1DataOfferEvent(
    this.id,
  );

  @override
  toString() {
    return "ExtDataControlDeviceV1DataOfferEvent (id: $id)";
  }
}

typedef ExtDataControlDeviceV1DataOfferEventHandler = void Function(
    ExtDataControlDeviceV1DataOfferEvent);

/// advertise new selection
///
/// The selection event is sent out to notify the client of a new
/// ext_data_control_offer for the selection for this device. The
/// ext_data_control_device.data_offer and the ext_data_control_offer.offer
/// events are sent out immediately before this event to introduce the data
/// offer object. The selection event is sent to a client when a new
/// selection is set. The ext_data_control_offer is valid until a new
/// ext_data_control_offer or NULL is received. The client must destroy the
/// previous selection ext_data_control_offer, if any, upon receiving this
/// event. Regardless, the previous selection will be ignored once a new
/// selection ext_data_control_offer is received.
///
/// The first selection event is sent upon binding the
/// ext_data_control_device object.
///
class ExtDataControlDeviceV1SelectionEvent {
  ///
  final int id;

  ExtDataControlDeviceV1SelectionEvent(
    this.id,
  );

  @override
  toString() {
    return "ExtDataControlDeviceV1SelectionEvent (id: $id)";
  }
}

typedef ExtDataControlDeviceV1SelectionEventHandler = void Function(
    ExtDataControlDeviceV1SelectionEvent);

/// this data control is no longer valid
///
/// This data control object is no longer valid and should be destroyed by
/// the client.
///
class ExtDataControlDeviceV1FinishedEvent {
  ExtDataControlDeviceV1FinishedEvent();

  @override
  toString() {
    return "ExtDataControlDeviceV1FinishedEvent ()";
  }
}

typedef ExtDataControlDeviceV1FinishedEventHandler = void Function(
    ExtDataControlDeviceV1FinishedEvent);

/// advertise new primary selection
///
/// The primary_selection event is sent out to notify the client of a new
/// ext_data_control_offer for the primary selection for this device. The
/// ext_data_control_device.data_offer and the ext_data_control_offer.offer
/// events are sent out immediately before this event to introduce the data
/// offer object. The primary_selection event is sent to a client when a
/// new primary selection is set. The ext_data_control_offer is valid until
/// a new ext_data_control_offer or NULL is received. The client must
/// destroy the previous primary selection ext_data_control_offer, if any,
/// upon receiving this event. Regardless, the previous primary selection
/// will be ignored once a new primary selection ext_data_control_offer is
/// received.
///
/// If the compositor supports primary selection, the first
/// primary_selection event is sent upon binding the
/// ext_data_control_device object.
///
class ExtDataControlDeviceV1PrimarySelectionEvent {
  ///
  final int id;

  ExtDataControlDeviceV1PrimarySelectionEvent(
    this.id,
  );

  @override
  toString() {
    return "ExtDataControlDeviceV1PrimarySelectionEvent (id: $id)";
  }
}

typedef ExtDataControlDeviceV1PrimarySelectionEventHandler = void Function(
    ExtDataControlDeviceV1PrimarySelectionEvent);

/// manage a data device for a seat
///
/// This interface allows a client to manage a seat's selection.
///
/// When the seat is destroyed, this object becomes inert.
///
class ExtDataControlDeviceV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtDataControlDeviceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtDataControlDeviceV1 {name: 'ext_data_control_device_v1', id: '$objectId', version: '1',}";
  }

  /// copy data to the selection
  ///
  /// This request asks the compositor to set the selection to the data from
  /// the source on behalf of the client.
  ///
  /// The given source may not be used in any further set_selection or
  /// set_primary_selection requests. Attempting to use a previously used
  /// source triggers the used_source protocol error.
  ///
  /// To unset the selection, set the source to NULL.
  ///
  /// [source]:
  Result<void, Object> setSelection(ExtDataControlSourceV1 source) {
    logLn("ExtDataControlDeviceV1::setSelection  source: $source");
    var arguments = [source];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([source.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlDeviceV1::setSelection: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy this data device
  ///
  /// Destroys the data device object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtDataControlDeviceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlDeviceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// copy data to the primary selection
  ///
  /// This request asks the compositor to set the primary selection to the
  /// data from the source on behalf of the client.
  ///
  /// The given source may not be used in any further set_selection or
  /// set_primary_selection requests. Attempting to use a previously used
  /// source triggers the used_source protocol error.
  ///
  /// To unset the primary selection, set the source to NULL.
  ///
  /// The compositor will ignore this request if it does not support primary
  /// selection.
  ///
  /// [source]:
  Result<void, Object> setPrimarySelection(ExtDataControlSourceV1 source) {
    logLn("ExtDataControlDeviceV1::setPrimarySelection  source: $source");
    var arguments = [source];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([source.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlDeviceV1::setPrimarySelection: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// introduce a new ext_data_control_offer
  ///
  /// The data_offer event introduces a new ext_data_control_offer object,
  /// which will subsequently be used in either the
  /// ext_data_control_device.selection event (for the regular clipboard
  /// selections) or the ext_data_control_device.primary_selection event (for
  /// the primary clipboard selections). Immediately following the
  /// ext_data_control_device.data_offer event, the new data_offer object
  /// will send out ext_data_control_offer.offer events to describe the MIME
  /// types it offers.
  ///
  /// Event handler for DataOffer
  /// - [id]:
  void onDataOffer(ExtDataControlDeviceV1DataOfferEventHandler handler) {
    _dataOfferHandler = handler;
  }

  ExtDataControlDeviceV1DataOfferEventHandler? _dataOfferHandler;

  /// advertise new selection
  ///
  /// The selection event is sent out to notify the client of a new
  /// ext_data_control_offer for the selection for this device. The
  /// ext_data_control_device.data_offer and the ext_data_control_offer.offer
  /// events are sent out immediately before this event to introduce the data
  /// offer object. The selection event is sent to a client when a new
  /// selection is set. The ext_data_control_offer is valid until a new
  /// ext_data_control_offer or NULL is received. The client must destroy the
  /// previous selection ext_data_control_offer, if any, upon receiving this
  /// event. Regardless, the previous selection will be ignored once a new
  /// selection ext_data_control_offer is received.
  ///
  /// The first selection event is sent upon binding the
  /// ext_data_control_device object.
  ///
  /// Event handler for Selection
  /// - [id]:
  void onSelection(ExtDataControlDeviceV1SelectionEventHandler handler) {
    _selectionHandler = handler;
  }

  ExtDataControlDeviceV1SelectionEventHandler? _selectionHandler;

  /// this data control is no longer valid
  ///
  /// This data control object is no longer valid and should be destroyed by
  /// the client.
  ///
  /// Event handler for Finished
  void onFinished(ExtDataControlDeviceV1FinishedEventHandler handler) {
    _finishedHandler = handler;
  }

  ExtDataControlDeviceV1FinishedEventHandler? _finishedHandler;

  /// advertise new primary selection
  ///
  /// The primary_selection event is sent out to notify the client of a new
  /// ext_data_control_offer for the primary selection for this device. The
  /// ext_data_control_device.data_offer and the ext_data_control_offer.offer
  /// events are sent out immediately before this event to introduce the data
  /// offer object. The primary_selection event is sent to a client when a
  /// new primary selection is set. The ext_data_control_offer is valid until
  /// a new ext_data_control_offer or NULL is received. The client must
  /// destroy the previous primary selection ext_data_control_offer, if any,
  /// upon receiving this event. Regardless, the previous primary selection
  /// will be ignored once a new primary selection ext_data_control_offer is
  /// received.
  ///
  /// If the compositor supports primary selection, the first
  /// primary_selection event is sent upon binding the
  /// ext_data_control_device object.
  ///
  /// Event handler for PrimarySelection
  /// - [id]:
  void onPrimarySelection(
      ExtDataControlDeviceV1PrimarySelectionEventHandler handler) {
    _primarySelectionHandler = handler;
  }

  ExtDataControlDeviceV1PrimarySelectionEventHandler? _primarySelectionHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtDataControlDeviceV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_dataOfferHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtDataControlDeviceV1DataOfferEvent(
            id,
          );
          _dataOfferHandler!(event);
        }
        break;
      case 1:
        if (_selectionHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtDataControlDeviceV1SelectionEvent(
            id,
          );
          _selectionHandler!(event);
        }
        break;
      case 2:
        if (_finishedHandler != null) {
          _finishedHandler!(ExtDataControlDeviceV1FinishedEvent());
        }
        break;
      case 3:
        if (_primarySelectionHandler != null) {
          var offset = 0;
          final id = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtDataControlDeviceV1PrimarySelectionEvent(
            id,
          );
          _primarySelectionHandler!(event);
        }
        break;
    }
  }
}

///
///

enum ExtDataControlDeviceV1Error {
  /// source given to set_selection or set_primary_selection was already used before
  usedSource("used_source", 1);

  const ExtDataControlDeviceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtDataControlDeviceV1Error {name: $enumName, value: $enumValue}";
  }
}

/// send the data
///
/// Request for data from the client. Send the data as the specified MIME
/// type over the passed file descriptor, then close it.
///
class ExtDataControlSourceV1SendEvent {
  /// MIME type for the data
  final String mimeType;

  /// file descriptor for the data
  final int fd;

  ExtDataControlSourceV1SendEvent(
    this.mimeType,
    this.fd,
  );

  @override
  toString() {
    return "ExtDataControlSourceV1SendEvent (mimeType: $mimeType, fd: $fd)";
  }
}

typedef ExtDataControlSourceV1SendEventHandler = void Function(
    ExtDataControlSourceV1SendEvent);

/// selection was cancelled
///
/// This data source is no longer valid. The data source has been replaced
/// by another data source.
///
/// The client should clean up and destroy this data source.
///
class ExtDataControlSourceV1CancelledEvent {
  ExtDataControlSourceV1CancelledEvent();

  @override
  toString() {
    return "ExtDataControlSourceV1CancelledEvent ()";
  }
}

typedef ExtDataControlSourceV1CancelledEventHandler = void Function(
    ExtDataControlSourceV1CancelledEvent);

/// offer to transfer data
///
/// The ext_data_control_source object is the source side of a
/// ext_data_control_offer. It is created by the source client in a data
/// transfer and provides a way to describe the offered data and a way to
/// respond to requests to transfer the data.
///
class ExtDataControlSourceV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtDataControlSourceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtDataControlSourceV1 {name: 'ext_data_control_source_v1', id: '$objectId', version: '1',}";
  }

  /// add an offered MIME type
  ///
  /// This request adds a MIME type to the set of MIME types advertised to
  /// targets. Can be called several times to offer multiple types.
  ///
  /// Calling this after ext_data_control_device.set_selection is a protocol
  /// error.
  ///
  /// [mime_type]: MIME type offered by the data source
  Result<void, Object> offer(String mimeType) {
    logLn("ExtDataControlSourceV1::offer  mimeType: $mimeType");
    var arguments = [mimeType];
    var argTypes = <WaylandType>[WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    final mimeTypeBytes = utf8.encode(mimeType);
    bytesBuilder.add(
        Uint32List.fromList([mimeTypeBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(mimeTypeBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlSourceV1::offer: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy this source
  ///
  /// Destroys the data source object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtDataControlSourceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlSourceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// send the data
  ///
  /// Request for data from the client. Send the data as the specified MIME
  /// type over the passed file descriptor, then close it.
  ///
  /// Event handler for Send
  /// - [mime_type]: MIME type for the data
  /// - [fd]: file descriptor for the data
  void onSend(ExtDataControlSourceV1SendEventHandler handler) {
    _sendHandler = handler;
  }

  ExtDataControlSourceV1SendEventHandler? _sendHandler;

  /// selection was cancelled
  ///
  /// This data source is no longer valid. The data source has been replaced
  /// by another data source.
  ///
  /// The client should clean up and destroy this data source.
  ///
  /// Event handler for Cancelled
  void onCancelled(ExtDataControlSourceV1CancelledEventHandler handler) {
    _cancelledHandler = handler;
  }

  ExtDataControlSourceV1CancelledEventHandler? _cancelledHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtDataControlSourceV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (fd != -1) {}
        if (_sendHandler != null) {
          var offset = 0;
          final mimeTypeLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final mimeType =
              utf8.decode(data.sublist(offset, offset + mimeTypeLength - 1));
          offset += mimeTypeLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          final fd2 = fd;
          var event = ExtDataControlSourceV1SendEvent(
            mimeType,
            fd2,
          );
          _sendHandler!(event);
        }
        break;
      case 1:
        if (_cancelledHandler != null) {
          _cancelledHandler!(ExtDataControlSourceV1CancelledEvent());
        }
        break;
    }
  }
}

///
///

enum ExtDataControlSourceV1Error {
  /// offer sent after ext_data_control_device.set_selection
  invalidOffer("invalid_offer", 1);

  const ExtDataControlSourceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtDataControlSourceV1Error {name: $enumName, value: $enumValue}";
  }
}

/// advertise offered MIME type
///
/// Sent immediately after creating the ext_data_control_offer object.
/// One event per offered MIME type.
///
class ExtDataControlOfferV1OfferEvent {
  /// offered MIME type
  final String mimeType;

  ExtDataControlOfferV1OfferEvent(
    this.mimeType,
  );

  @override
  toString() {
    return "ExtDataControlOfferV1OfferEvent (mimeType: $mimeType)";
  }
}

typedef ExtDataControlOfferV1OfferEventHandler = void Function(
    ExtDataControlOfferV1OfferEvent);

/// offer to transfer data
///
/// A ext_data_control_offer represents a piece of data offered for transfer
/// by another client (the source client). The offer describes the different
/// MIME types that the data can be converted to and provides the mechanism
/// for transferring the data directly from the source client.
///
class ExtDataControlOfferV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtDataControlOfferV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtDataControlOfferV1 {name: 'ext_data_control_offer_v1', id: '$objectId', version: '1',}";
  }

  /// request that the data is transferred
  ///
  /// To transfer the offered data, the client issues this request and
  /// indicates the MIME type it wants to receive. The transfer happens
  /// through the passed file descriptor (typically created with the pipe
  /// system call). The source client writes the data in the MIME type
  /// representation requested and then closes the file descriptor.
  ///
  /// The receiving client reads from the read end of the pipe until EOF and
  /// then closes its end, at which point the transfer is complete.
  ///
  /// This request may happen multiple times for different MIME types.
  ///
  /// [mime_type]: MIME type desired by receiver
  /// [fd]: file descriptor for data transfer
  Result<void, Object> receive(String mimeType, int fd) {
    logLn("ExtDataControlOfferV1::receive  mimeType: $mimeType fd: $fd");
    var arguments = [mimeType];
    var argTypes = <WaylandType>[WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    final mimeTypeBytes = utf8.encode(mimeType);
    bytesBuilder.add(
        Uint32List.fromList([mimeTypeBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(mimeTypeBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    try {
      innerContext.sendMessage(bytesBuilder.toBytes(), fd);
    } catch (e) {
      logLn("Exception in ExtDataControlOfferV1::receive: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy this offer
  ///
  /// Destroys the data offer object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtDataControlOfferV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtDataControlOfferV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// advertise offered MIME type
  ///
  /// Sent immediately after creating the ext_data_control_offer object.
  /// One event per offered MIME type.
  ///
  /// Event handler for Offer
  /// - [mime_type]: offered MIME type
  void onOffer(ExtDataControlOfferV1OfferEventHandler handler) {
    _offerHandler = handler;
  }

  ExtDataControlOfferV1OfferEventHandler? _offerHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtDataControlOfferV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_offerHandler != null) {
          var offset = 0;
          final mimeTypeLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final mimeType =
              utf8.decode(data.sublist(offset, offset + mimeTypeLength - 1));
          offset += mimeTypeLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtDataControlOfferV1OfferEvent(
            mimeType,
          );
          _offerHandler!(event);
        }
        break;
    }
  }
}
