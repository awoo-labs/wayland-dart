// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/ext-image-copy-capture/ext-image-copy-capture-v1.xml
//
// ext_image_copy_capture_v1 Protocol Copyright:
///
/// Copyright © 2021-2023 Andri Yngvason
/// Copyright © 2024 Simon Ser
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:typed_data';
import 'package:wayland/protocols/staging/ext-image-capture-source/ext-image-capture-source-v1.dart';


/// manager to inform clients and begin capturing
///
/// This object is a manager which offers requests to start capturing from a
/// source.
///
class ExtImageCopyCaptureManagerV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  ExtImageCopyCaptureManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtImageCopyCaptureManagerV1 {name: 'ext_image_copy_capture_manager_v1', id: '$objectId', version: '1',}";
  }

  /// capture an image capture source
  ///
  /// Create a capturing session for an image capture source.
  ///
  /// If the paint_cursors option is set, cursors shall be composited onto
  /// the captured frame. The cursor must not be composited onto the frame
  /// if this flag is not set.
  ///
  /// If the options bitfield is invalid, the invalid_option protocol error
  /// is sent.
  ///
  /// [session]:
  /// [source]:
  /// [options]:
  Result<ExtImageCopyCaptureSessionV1, Object> createSession(
      ExtImageCaptureSourceV1 source, int options) {
    var session = ExtImageCopyCaptureSessionV1(innerContext);
    logLn(
        "ExtImageCopyCaptureManagerV1::createSession  session: $session source: $source options: $options");
    var arguments = [session, source, options];
    var argTypes = <WaylandType>[
      WaylandType.newId,
      WaylandType.object,
      WaylandType.uint
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([session.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([source.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([options]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureManagerV1::createSession: $e");
      return Failure(e);
    }
    return Success(session);
  }

  /// capture the pointer cursor of an image capture source
  ///
  /// Create a cursor capturing session for the pointer of an image capture
  /// source.
  ///
  /// [session]:
  /// [source]:
  /// [pointer]:
  Result<ExtImageCopyCaptureCursorSessionV1, Object> createPointerCursorSession(
      ExtImageCaptureSourceV1 source, Pointer pointer) {
    var session = ExtImageCopyCaptureCursorSessionV1(innerContext);
    logLn(
        "ExtImageCopyCaptureManagerV1::createPointerCursorSession  session: $session source: $source pointer: $pointer");
    var arguments = [session, source, pointer];
    var argTypes = <WaylandType>[
      WaylandType.newId,
      WaylandType.object,
      WaylandType.object
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([session.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([source.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([pointer.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in ExtImageCopyCaptureManagerV1::createPointerCursorSession: $e");
      return Failure(e);
    }
    return Success(session);
  }

  /// destroy the manager
  ///
  /// Destroy the manager object.
  ///
  /// Other objects created via this interface are unaffected.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtImageCopyCaptureManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

///
///

enum ExtImageCopyCaptureManagerV1Error {
  /// invalid option flag
  invalidOption("invalid_option", 1);

  const ExtImageCopyCaptureManagerV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureManagerV1Error {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ExtImageCopyCaptureManagerV1Options {
  /// paint cursors onto captured frames
  paintCursors("paint_cursors", 1);

  const ExtImageCopyCaptureManagerV1Options(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureManagerV1Options {name: $enumName, value: $enumValue}";
  }
}

/// image capture source dimensions
///
/// Provides the dimensions of the source image in buffer pixel coordinates.
///
/// The client must attach buffers that match this size.
///
class ExtImageCopyCaptureSessionV1BufferSizeEvent {
  /// buffer width
  final int width;

  /// buffer height
  final int height;

  ExtImageCopyCaptureSessionV1BufferSizeEvent(
    this.width,
    this.height,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1BufferSizeEvent (width: $width, height: $height)";
  }
}

typedef ExtImageCopyCaptureSessionV1BufferSizeEventHandler = void Function(
    ExtImageCopyCaptureSessionV1BufferSizeEvent);

/// shm buffer format
///
/// Provides the format that must be used for shared-memory buffers.
///
/// This event may be emitted multiple times, in which case the client may
/// choose any given format.
///
class ExtImageCopyCaptureSessionV1ShmFormatEvent {
  /// shm format
  final int format;

  ExtImageCopyCaptureSessionV1ShmFormatEvent(
    this.format,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1ShmFormatEvent (format: $format)";
  }
}

typedef ExtImageCopyCaptureSessionV1ShmFormatEventHandler = void Function(
    ExtImageCopyCaptureSessionV1ShmFormatEvent);

/// dma-buf device
///
/// This event advertises the device buffers must be allocated on for
/// dma-buf buffers.
///
/// In general the device is a DRM node. The DRM node type (primary vs.
/// render) is unspecified. Clients must not rely on the compositor sending
/// a particular node type. Clients cannot check two devices for equality
/// by comparing the dev_t value.
///
class ExtImageCopyCaptureSessionV1DmabufDeviceEvent {
  /// device dev_t value
  final List<int> device;

  ExtImageCopyCaptureSessionV1DmabufDeviceEvent(
    this.device,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1DmabufDeviceEvent (device: $device)";
  }
}

typedef ExtImageCopyCaptureSessionV1DmabufDeviceEventHandler = void Function(
    ExtImageCopyCaptureSessionV1DmabufDeviceEvent);

/// dma-buf format
///
/// Provides the format that must be used for dma-buf buffers.
///
/// The client may choose any of the modifiers advertised in the array of
/// 64-bit unsigned integers.
///
/// This event may be emitted multiple times, in which case the client may
/// choose any given format.
///
class ExtImageCopyCaptureSessionV1DmabufFormatEvent {
  /// drm format code
  final int format;

  /// drm format modifiers
  final List<int> modifiers;

  ExtImageCopyCaptureSessionV1DmabufFormatEvent(
    this.format,
    this.modifiers,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1DmabufFormatEvent (format: $format, modifiers: $modifiers)";
  }
}

typedef ExtImageCopyCaptureSessionV1DmabufFormatEventHandler = void Function(
    ExtImageCopyCaptureSessionV1DmabufFormatEvent);

/// all constraints have been sent
///
/// This event is sent once when all buffer constraint events have been
/// sent.
///
/// The compositor must always end a batch of buffer constraint events with
/// this event, regardless of whether it sends the initial constraints or
/// an update.
///
class ExtImageCopyCaptureSessionV1DoneEvent {
  ExtImageCopyCaptureSessionV1DoneEvent();

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1DoneEvent ()";
  }
}

typedef ExtImageCopyCaptureSessionV1DoneEventHandler = void Function(
    ExtImageCopyCaptureSessionV1DoneEvent);

/// session is no longer available
///
/// This event indicates that the capture session has stopped and is no
/// longer available. This can happen in a number of cases, e.g. when the
/// underlying source is destroyed, if the user decides to end the image
/// capture, or if an unrecoverable runtime error has occurred.
///
/// The client should destroy the session after receiving this event.
///
class ExtImageCopyCaptureSessionV1StoppedEvent {
  ExtImageCopyCaptureSessionV1StoppedEvent();

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1StoppedEvent ()";
  }
}

typedef ExtImageCopyCaptureSessionV1StoppedEventHandler = void Function(
    ExtImageCopyCaptureSessionV1StoppedEvent);

/// image copy capture session
///
/// This object represents an active image copy capture session.
///
/// After a capture session is created, buffer constraint events will be
/// emitted from the compositor to tell the client which buffer types and
/// formats are supported for reading from the session. The compositor may
/// re-send buffer constraint events whenever they change.
///
/// To advertise buffer constraints, the compositor must send in no
/// particular order: zero or more shm_format and dmabuf_format events, zero
/// or one dmabuf_device event, and exactly one buffer_size event. Then the
/// compositor must send a done event.
///
/// When the client has received all the buffer constraints, it can create a
/// buffer accordingly, attach it to the capture session using the
/// attach_buffer request, set the buffer damage using the damage_buffer
/// request and then send the capture request.
///
class ExtImageCopyCaptureSessionV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtImageCopyCaptureSessionV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1 {name: 'ext_image_copy_capture_session_v1', id: '$objectId', version: '1',}";
  }

  /// create a frame
  ///
  /// Create a capture frame for this session.
  ///
  /// At most one frame object can exist for a given session at any time. If
  /// a client sends a create_frame request before a previous frame object
  /// has been destroyed, the duplicate_frame protocol error is raised.
  ///
  /// [frame]:
  Result<ExtImageCopyCaptureFrameV1, Object> createFrame() {
    var frame = ExtImageCopyCaptureFrameV1(innerContext);
    logLn("ExtImageCopyCaptureSessionV1::createFrame  frame: $frame");
    var arguments = [frame];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([frame.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureSessionV1::createFrame: $e");
      return Failure(e);
    }
    return Success(frame);
  }

  /// delete this object
  ///
  /// Destroys the session. This request can be sent at any time by the
  /// client.
  ///
  /// This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
  /// this object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtImageCopyCaptureSessionV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureSessionV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// image capture source dimensions
  ///
  /// Provides the dimensions of the source image in buffer pixel coordinates.
  ///
  /// The client must attach buffers that match this size.
  ///
  /// Event handler for BufferSize
  /// - [width]: buffer width
  /// - [height]: buffer height
  void onBufferSize(
      ExtImageCopyCaptureSessionV1BufferSizeEventHandler handler) {
    _bufferSizeHandler = handler;
  }

  ExtImageCopyCaptureSessionV1BufferSizeEventHandler? _bufferSizeHandler;

  /// shm buffer format
  ///
  /// Provides the format that must be used for shared-memory buffers.
  ///
  /// This event may be emitted multiple times, in which case the client may
  /// choose any given format.
  ///
  /// Event handler for ShmFormat
  /// - [format]: shm format
  void onShmFormat(ExtImageCopyCaptureSessionV1ShmFormatEventHandler handler) {
    _shmFormatHandler = handler;
  }

  ExtImageCopyCaptureSessionV1ShmFormatEventHandler? _shmFormatHandler;

  /// dma-buf device
  ///
  /// This event advertises the device buffers must be allocated on for
  /// dma-buf buffers.
  ///
  /// In general the device is a DRM node. The DRM node type (primary vs.
  /// render) is unspecified. Clients must not rely on the compositor sending
  /// a particular node type. Clients cannot check two devices for equality
  /// by comparing the dev_t value.
  ///
  /// Event handler for DmabufDevice
  /// - [device]: device dev_t value
  void onDmabufDevice(
      ExtImageCopyCaptureSessionV1DmabufDeviceEventHandler handler) {
    _dmabufDeviceHandler = handler;
  }

  ExtImageCopyCaptureSessionV1DmabufDeviceEventHandler? _dmabufDeviceHandler;

  /// dma-buf format
  ///
  /// Provides the format that must be used for dma-buf buffers.
  ///
  /// The client may choose any of the modifiers advertised in the array of
  /// 64-bit unsigned integers.
  ///
  /// This event may be emitted multiple times, in which case the client may
  /// choose any given format.
  ///
  /// Event handler for DmabufFormat
  /// - [format]: drm format code
  /// - [modifiers]: drm format modifiers
  void onDmabufFormat(
      ExtImageCopyCaptureSessionV1DmabufFormatEventHandler handler) {
    _dmabufFormatHandler = handler;
  }

  ExtImageCopyCaptureSessionV1DmabufFormatEventHandler? _dmabufFormatHandler;

  /// all constraints have been sent
  ///
  /// This event is sent once when all buffer constraint events have been
  /// sent.
  ///
  /// The compositor must always end a batch of buffer constraint events with
  /// this event, regardless of whether it sends the initial constraints or
  /// an update.
  ///
  /// Event handler for Done
  void onDone(ExtImageCopyCaptureSessionV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ExtImageCopyCaptureSessionV1DoneEventHandler? _doneHandler;

  /// session is no longer available
  ///
  /// This event indicates that the capture session has stopped and is no
  /// longer available. This can happen in a number of cases, e.g. when the
  /// underlying source is destroyed, if the user decides to end the image
  /// capture, or if an unrecoverable runtime error has occurred.
  ///
  /// The client should destroy the session after receiving this event.
  ///
  /// Event handler for Stopped
  void onStopped(ExtImageCopyCaptureSessionV1StoppedEventHandler handler) {
    _stoppedHandler = handler;
  }

  ExtImageCopyCaptureSessionV1StoppedEventHandler? _stoppedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtImageCopyCaptureSessionV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_bufferSizeHandler != null) {
          var offset = 0;
          final width =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final height =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureSessionV1BufferSizeEvent(
            width,
            height,
          );
          _bufferSizeHandler!(event);
        }
        break;
      case 1:
        if (_shmFormatHandler != null) {
          var offset = 0;
          final format =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureSessionV1ShmFormatEvent(
            format,
          );
          _shmFormatHandler!(event);
        }
        break;
      case 2:
        if (_dmabufDeviceHandler != null) {
          var offset = 0;
          final device = getArray(data, offset);
          var arrayLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4 + arrayLength;
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtImageCopyCaptureSessionV1DmabufDeviceEvent(
            device,
          );
          _dmabufDeviceHandler!(event);
        }
        break;
      case 3:
        if (_dmabufFormatHandler != null) {
          var offset = 0;
          final format =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final modifiers = getArray(data, offset);
          var arrayLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4 + arrayLength;
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtImageCopyCaptureSessionV1DmabufFormatEvent(
            format,
            modifiers,
          );
          _dmabufFormatHandler!(event);
        }
        break;
      case 4:
        if (_doneHandler != null) {
          _doneHandler!(ExtImageCopyCaptureSessionV1DoneEvent());
        }
        break;
      case 5:
        if (_stoppedHandler != null) {
          _stoppedHandler!(ExtImageCopyCaptureSessionV1StoppedEvent());
        }
        break;
    }
  }
}

///
///

enum ExtImageCopyCaptureSessionV1Error {
  /// create_frame sent before destroying previous frame
  duplicateFrame("duplicate_frame", 1);

  const ExtImageCopyCaptureSessionV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureSessionV1Error {name: $enumName, value: $enumValue}";
  }
}

/// buffer transform
///
/// This event is sent before the ready event and holds the transform that
/// the compositor has applied to the buffer contents.
///
class ExtImageCopyCaptureFrameV1TransformEvent {
  ///
  final int transform;

  ExtImageCopyCaptureFrameV1TransformEvent(
    this.transform,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1TransformEvent (transform: $transform)";
  }
}

typedef ExtImageCopyCaptureFrameV1TransformEventHandler = void Function(
    ExtImageCopyCaptureFrameV1TransformEvent);

/// buffer damaged region
///
/// This event is sent before the ready event. It may be generated multiple
/// times to describe a region.
///
/// The first captured frame in a session will always carry full damage.
/// Subsequent frames' damaged regions describe which parts of the buffer
/// have changed since the last ready event.
///
/// These coordinates originate in the upper left corner of the buffer.
///
class ExtImageCopyCaptureFrameV1DamageEvent {
  /// damage x coordinate
  final int x;

  /// damage y coordinate
  final int y;

  /// damage width
  final int width;

  /// damage height
  final int height;

  ExtImageCopyCaptureFrameV1DamageEvent(
    this.x,
    this.y,
    this.width,
    this.height,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1DamageEvent (x: $x, y: $y, width: $width, height: $height)";
  }
}

typedef ExtImageCopyCaptureFrameV1DamageEventHandler = void Function(
    ExtImageCopyCaptureFrameV1DamageEvent);

/// presentation time of the frame
///
/// This event indicates the time at which the frame is presented to the
/// output in system monotonic time. This event is sent before the ready
/// event.
///
/// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
/// each component being an unsigned 32-bit value. Whole seconds are in
/// tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
/// and the additional fractional part in tv_nsec as nanoseconds. Hence,
/// for valid timestamps tv_nsec must be in [0, 999999999].
///
class ExtImageCopyCaptureFrameV1PresentationTimeEvent {
  /// high 32 bits of the seconds part of the timestamp
  final int tvSecHi;

  /// low 32 bits of the seconds part of the timestamp
  final int tvSecLo;

  /// nanoseconds part of the timestamp
  final int tvNsec;

  ExtImageCopyCaptureFrameV1PresentationTimeEvent(
    this.tvSecHi,
    this.tvSecLo,
    this.tvNsec,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1PresentationTimeEvent (tvSecHi: $tvSecHi, tvSecLo: $tvSecLo, tvNsec: $tvNsec)";
  }
}

typedef ExtImageCopyCaptureFrameV1PresentationTimeEventHandler = void Function(
    ExtImageCopyCaptureFrameV1PresentationTimeEvent);

/// frame is available for reading
///
/// Called as soon as the frame is copied, indicating it is available
/// for reading.
///
/// The buffer may be re-used by the client after this event.
///
/// After receiving this event, the client must destroy the object.
///
class ExtImageCopyCaptureFrameV1ReadyEvent {
  ExtImageCopyCaptureFrameV1ReadyEvent();

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1ReadyEvent ()";
  }
}

typedef ExtImageCopyCaptureFrameV1ReadyEventHandler = void Function(
    ExtImageCopyCaptureFrameV1ReadyEvent);

/// capture failed
///
/// This event indicates that the attempted frame copy has failed.
///
/// After receiving this event, the client must destroy the object.
///
class ExtImageCopyCaptureFrameV1FailedEvent {
  ///
  final int reason;

  ExtImageCopyCaptureFrameV1FailedEvent(
    this.reason,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1FailedEvent (reason: $reason)";
  }
}

typedef ExtImageCopyCaptureFrameV1FailedEventHandler = void Function(
    ExtImageCopyCaptureFrameV1FailedEvent);

/// image capture frame
///
/// This object represents an image capture frame.
///
/// The client should attach a buffer, damage the buffer, and then send a
/// capture request.
///
/// If the capture is successful, the compositor must send the frame metadata
/// (transform, damage, presentation_time in any order) followed by the ready
/// event.
///
/// If the capture fails, the compositor must send the failed event.
///
class ExtImageCopyCaptureFrameV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtImageCopyCaptureFrameV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1 {name: 'ext_image_copy_capture_frame_v1', id: '$objectId', version: '1',}";
  }

  /// destroy this object
  ///
  /// Destroys the frame. This request can be sent at any time by the
  /// client.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtImageCopyCaptureFrameV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureFrameV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// attach buffer to session
  ///
  /// Attach a buffer to the session.
  ///
  /// The wl_buffer.release request is unused.
  ///
  /// The new buffer replaces any previously attached buffer.
  ///
  /// This request must not be sent after capture, or else the
  /// already_captured protocol error is raised.
  ///
  /// [buffer]:
  Result<void, Object> attachBuffer(Buffer buffer) {
    logLn("ExtImageCopyCaptureFrameV1::attachBuffer  buffer: $buffer");
    var arguments = [buffer];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([buffer.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureFrameV1::attachBuffer: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// damage buffer
  ///
  /// Apply damage to the buffer which is to be captured next. This request
  /// may be sent multiple times to describe a region.
  ///
  /// The client indicates the accumulated damage since this wl_buffer was
  /// last captured. During capture, the compositor will update the buffer
  /// with at least the union of the region passed by the client and the
  /// region advertised by ext_image_copy_capture_frame_v1.damage.
  ///
  /// When a wl_buffer is captured for the first time, or when the client
  /// doesn't track damage, the client must damage the whole buffer.
  ///
  /// This is for optimisation purposes. The compositor may use this
  /// information to reduce copying.
  ///
  /// These coordinates originate from the upper left corner of the buffer.
  ///
  /// If x or y are strictly negative, or if width or height are negative or
  /// zero, the invalid_buffer_damage protocol error is raised.
  ///
  /// This request must not be sent after capture, or else the
  /// already_captured protocol error is raised.
  ///
  /// [x]: region x coordinate
  /// [y]: region y coordinate
  /// [width]: region width
  /// [height]: region height
  Result<void, Object> damageBuffer(int x, int y, int width, int height) {
    logLn(
        "ExtImageCopyCaptureFrameV1::damageBuffer  x: $x y: $y width: $width height: $height");
    var arguments = [x, y, width, height];
    var argTypes = <WaylandType>[
      WaylandType.int,
      WaylandType.int,
      WaylandType.int,
      WaylandType.int
    ];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Int32List.fromList([x]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([y]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([width]).buffer.asUint8List());
    bytesBuilder.add(Int32List.fromList([height]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureFrameV1::damageBuffer: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// capture a frame
  ///
  /// Capture a frame.
  ///
  /// Unless this is the first successful captured frame performed in this
  /// session, the compositor may wait an indefinite amount of time for the
  /// source content to change before performing the copy.
  ///
  /// This request may only be sent once, or else the already_captured
  /// protocol error is raised. A buffer must be attached before this request
  /// is sent, or else the no_buffer protocol error is raised.
  ///
  Result<void, Object> capture() {
    logLn("ExtImageCopyCaptureFrameV1::capture ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureFrameV1::capture: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// buffer transform
  ///
  /// This event is sent before the ready event and holds the transform that
  /// the compositor has applied to the buffer contents.
  ///
  /// Event handler for Transform
  /// - [transform]:
  void onTransform(ExtImageCopyCaptureFrameV1TransformEventHandler handler) {
    _transformHandler = handler;
  }

  ExtImageCopyCaptureFrameV1TransformEventHandler? _transformHandler;

  /// buffer damaged region
  ///
  /// This event is sent before the ready event. It may be generated multiple
  /// times to describe a region.
  ///
  /// The first captured frame in a session will always carry full damage.
  /// Subsequent frames' damaged regions describe which parts of the buffer
  /// have changed since the last ready event.
  ///
  /// These coordinates originate in the upper left corner of the buffer.
  ///
  /// Event handler for Damage
  /// - [x]: damage x coordinate
  /// - [y]: damage y coordinate
  /// - [width]: damage width
  /// - [height]: damage height
  void onDamage(ExtImageCopyCaptureFrameV1DamageEventHandler handler) {
    _damageHandler = handler;
  }

  ExtImageCopyCaptureFrameV1DamageEventHandler? _damageHandler;

  /// presentation time of the frame
  ///
  /// This event indicates the time at which the frame is presented to the
  /// output in system monotonic time. This event is sent before the ready
  /// event.
  ///
  /// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
  /// each component being an unsigned 32-bit value. Whole seconds are in
  /// tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
  /// and the additional fractional part in tv_nsec as nanoseconds. Hence,
  /// for valid timestamps tv_nsec must be in [0, 999999999].
  ///
  /// Event handler for PresentationTime
  /// - [tv_sec_hi]: high 32 bits of the seconds part of the timestamp
  /// - [tv_sec_lo]: low 32 bits of the seconds part of the timestamp
  /// - [tv_nsec]: nanoseconds part of the timestamp
  void onPresentationTime(
      ExtImageCopyCaptureFrameV1PresentationTimeEventHandler handler) {
    _presentationTimeHandler = handler;
  }

  ExtImageCopyCaptureFrameV1PresentationTimeEventHandler?
      _presentationTimeHandler;

  /// frame is available for reading
  ///
  /// Called as soon as the frame is copied, indicating it is available
  /// for reading.
  ///
  /// The buffer may be re-used by the client after this event.
  ///
  /// After receiving this event, the client must destroy the object.
  ///
  /// Event handler for Ready
  void onReady(ExtImageCopyCaptureFrameV1ReadyEventHandler handler) {
    _readyHandler = handler;
  }

  ExtImageCopyCaptureFrameV1ReadyEventHandler? _readyHandler;

  /// capture failed
  ///
  /// This event indicates that the attempted frame copy has failed.
  ///
  /// After receiving this event, the client must destroy the object.
  ///
  /// Event handler for Failed
  /// - [reason]:
  void onFailed(ExtImageCopyCaptureFrameV1FailedEventHandler handler) {
    _failedHandler = handler;
  }

  ExtImageCopyCaptureFrameV1FailedEventHandler? _failedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtImageCopyCaptureFrameV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_transformHandler != null) {
          var offset = 0;
          final transform =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureFrameV1TransformEvent(
            transform,
          );
          _transformHandler!(event);
        }
        break;
      case 1:
        if (_damageHandler != null) {
          var offset = 0;
          final x = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final y = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final width =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final height =
              ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureFrameV1DamageEvent(
            x,
            y,
            width,
            height,
          );
          _damageHandler!(event);
        }
        break;
      case 2:
        if (_presentationTimeHandler != null) {
          var offset = 0;
          final tvSecHi =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final tvSecLo =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final tvNsec =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureFrameV1PresentationTimeEvent(
            tvSecHi,
            tvSecLo,
            tvNsec,
          );
          _presentationTimeHandler!(event);
        }
        break;
      case 3:
        if (_readyHandler != null) {
          _readyHandler!(ExtImageCopyCaptureFrameV1ReadyEvent());
        }
        break;
      case 4:
        if (_failedHandler != null) {
          var offset = 0;
          final reason =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureFrameV1FailedEvent(
            reason,
          );
          _failedHandler!(event);
        }
        break;
    }
  }
}

///
///

enum ExtImageCopyCaptureFrameV1Error {
  /// capture sent without attach_buffer
  noBuffer("no_buffer", 1),

  /// invalid buffer damage
  invalidBufferDamage("invalid_buffer_damage", 2),

  /// capture request has been sent
  alreadyCaptured("already_captured", 3);

  const ExtImageCopyCaptureFrameV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1Error {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ExtImageCopyCaptureFrameV1FailureReason {
  ///
  unknown("unknown", 0),

  ///
  bufferConstraints("buffer_constraints", 1),

  ///
  stopped("stopped", 2);

  const ExtImageCopyCaptureFrameV1FailureReason(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureFrameV1FailureReason {name: $enumName, value: $enumValue}";
  }
}

/// cursor entered captured area
///
/// Sent when a cursor enters the captured area. It shall be generated
/// before the "position" and "hotspot" events when and only when a cursor
/// enters the area.
///
/// The cursor enters the captured area when the cursor image intersects
/// with the captured area. Note, this is different from e.g.
/// wl_pointer.enter.
///
class ExtImageCopyCaptureCursorSessionV1EnterEvent {
  ExtImageCopyCaptureCursorSessionV1EnterEvent();

  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1EnterEvent ()";
  }
}

typedef ExtImageCopyCaptureCursorSessionV1EnterEventHandler = void Function(
    ExtImageCopyCaptureCursorSessionV1EnterEvent);

/// cursor left captured area
///
/// Sent when a cursor leaves the captured area. No "position" or "hotspot"
/// event is generated for the cursor until the cursor enters the captured
/// area again.
///
class ExtImageCopyCaptureCursorSessionV1LeaveEvent {
  ExtImageCopyCaptureCursorSessionV1LeaveEvent();

  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1LeaveEvent ()";
  }
}

typedef ExtImageCopyCaptureCursorSessionV1LeaveEventHandler = void Function(
    ExtImageCopyCaptureCursorSessionV1LeaveEvent);

/// position changed
///
/// Cursors outside the image capture source do not get captured and no
/// event will be generated for them.
///
/// The given position is the position of the cursor's hotspot and it is
/// relative to the main buffer's top left corner in transformed buffer
/// pixel coordinates. The coordinates may be negative or greater than the
/// main buffer size.
///
class ExtImageCopyCaptureCursorSessionV1PositionEvent {
  /// position x coordinates
  final int x;

  /// position y coordinates
  final int y;

  ExtImageCopyCaptureCursorSessionV1PositionEvent(
    this.x,
    this.y,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1PositionEvent (x: $x, y: $y)";
  }
}

typedef ExtImageCopyCaptureCursorSessionV1PositionEventHandler = void Function(
    ExtImageCopyCaptureCursorSessionV1PositionEvent);

/// hotspot changed
///
/// The hotspot describes the offset between the cursor image and the
/// position of the input device.
///
/// The given coordinates are the hotspot's offset from the origin in
/// buffer coordinates.
///
/// Clients should not apply the hotspot immediately: the hotspot becomes
/// effective when the next ext_image_copy_capture_frame_v1.ready event is received.
///
/// Compositors may delay this event until the client captures a new frame.
///
class ExtImageCopyCaptureCursorSessionV1HotspotEvent {
  /// hotspot x coordinates
  final int x;

  /// hotspot y coordinates
  final int y;

  ExtImageCopyCaptureCursorSessionV1HotspotEvent(
    this.x,
    this.y,
  );

  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1HotspotEvent (x: $x, y: $y)";
  }
}

typedef ExtImageCopyCaptureCursorSessionV1HotspotEventHandler = void Function(
    ExtImageCopyCaptureCursorSessionV1HotspotEvent);

/// cursor capture session
///
/// This object represents a cursor capture session. It extends the base
/// capture session with cursor-specific metadata.
///
class ExtImageCopyCaptureCursorSessionV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtImageCopyCaptureCursorSessionV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1 {name: 'ext_image_copy_capture_cursor_session_v1', id: '$objectId', version: '1',}";
  }

  /// delete this object
  ///
  /// Destroys the session. This request can be sent at any time by the
  /// client.
  ///
  /// This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
  /// this object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtImageCopyCaptureCursorSessionV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtImageCopyCaptureCursorSessionV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// get image copy capturer session
  ///
  /// Gets the image copy capture session for this cursor session.
  ///
  /// The session will produce frames of the cursor image. The compositor may
  /// pause the session when the cursor leaves the captured area.
  ///
  /// This request must not be sent more than once, or else the
  /// duplicate_session protocol error is raised.
  ///
  /// [session]:
  Result<ExtImageCopyCaptureSessionV1, Object> getCaptureSession() {
    var session = ExtImageCopyCaptureSessionV1(innerContext);
    logLn(
        "ExtImageCopyCaptureCursorSessionV1::getCaptureSession  session: $session");
    var arguments = [session];
    var argTypes = <WaylandType>[WaylandType.newId];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([session.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in ExtImageCopyCaptureCursorSessionV1::getCaptureSession: $e");
      return Failure(e);
    }
    return Success(session);
  }

  /// cursor entered captured area
  ///
  /// Sent when a cursor enters the captured area. It shall be generated
  /// before the "position" and "hotspot" events when and only when a cursor
  /// enters the area.
  ///
  /// The cursor enters the captured area when the cursor image intersects
  /// with the captured area. Note, this is different from e.g.
  /// wl_pointer.enter.
  ///
  /// Event handler for Enter
  void onEnter(ExtImageCopyCaptureCursorSessionV1EnterEventHandler handler) {
    _enterHandler = handler;
  }

  ExtImageCopyCaptureCursorSessionV1EnterEventHandler? _enterHandler;

  /// cursor left captured area
  ///
  /// Sent when a cursor leaves the captured area. No "position" or "hotspot"
  /// event is generated for the cursor until the cursor enters the captured
  /// area again.
  ///
  /// Event handler for Leave
  void onLeave(ExtImageCopyCaptureCursorSessionV1LeaveEventHandler handler) {
    _leaveHandler = handler;
  }

  ExtImageCopyCaptureCursorSessionV1LeaveEventHandler? _leaveHandler;

  /// position changed
  ///
  /// Cursors outside the image capture source do not get captured and no
  /// event will be generated for them.
  ///
  /// The given position is the position of the cursor's hotspot and it is
  /// relative to the main buffer's top left corner in transformed buffer
  /// pixel coordinates. The coordinates may be negative or greater than the
  /// main buffer size.
  ///
  /// Event handler for Position
  /// - [x]: position x coordinates
  /// - [y]: position y coordinates
  void onPosition(
      ExtImageCopyCaptureCursorSessionV1PositionEventHandler handler) {
    _positionHandler = handler;
  }

  ExtImageCopyCaptureCursorSessionV1PositionEventHandler? _positionHandler;

  /// hotspot changed
  ///
  /// The hotspot describes the offset between the cursor image and the
  /// position of the input device.
  ///
  /// The given coordinates are the hotspot's offset from the origin in
  /// buffer coordinates.
  ///
  /// Clients should not apply the hotspot immediately: the hotspot becomes
  /// effective when the next ext_image_copy_capture_frame_v1.ready event is received.
  ///
  /// Compositors may delay this event until the client captures a new frame.
  ///
  /// Event handler for Hotspot
  /// - [x]: hotspot x coordinates
  /// - [y]: hotspot y coordinates
  void onHotspot(
      ExtImageCopyCaptureCursorSessionV1HotspotEventHandler handler) {
    _hotspotHandler = handler;
  }

  ExtImageCopyCaptureCursorSessionV1HotspotEventHandler? _hotspotHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtImageCopyCaptureCursorSessionV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_enterHandler != null) {
          _enterHandler!(ExtImageCopyCaptureCursorSessionV1EnterEvent());
        }
        break;
      case 1:
        if (_leaveHandler != null) {
          _leaveHandler!(ExtImageCopyCaptureCursorSessionV1LeaveEvent());
        }
        break;
      case 2:
        if (_positionHandler != null) {
          var offset = 0;
          final x = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final y = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureCursorSessionV1PositionEvent(
            x,
            y,
          );
          _positionHandler!(event);
        }
        break;
      case 3:
        if (_hotspotHandler != null) {
          var offset = 0;
          final x = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          final y = ByteData.view(data.buffer).getInt32(offset, Endian.little);
          offset += 4;
          var event = ExtImageCopyCaptureCursorSessionV1HotspotEvent(
            x,
            y,
          );
          _hotspotHandler!(event);
        }
        break;
    }
  }
}

///
///

enum ExtImageCopyCaptureCursorSessionV1Error {
  /// get_capture_session sent twice
  duplicateSession("duplicate_session", 1);

  const ExtImageCopyCaptureCursorSessionV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtImageCopyCaptureCursorSessionV1Error {name: $enumName, value: $enumValue}";
  }
}
