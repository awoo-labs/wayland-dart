// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/color-representation/color-representation-v1.xml
//
// color_representation_v1 Protocol Copyright:
///
/// Copyright 2022 Simon Ser
/// Copyright 2022 Red Hat, Inc.
/// Copyright 2022 Collabora, Ltd.
/// Copyright 2022-2025 Red Hat, Inc.
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:typed_data';
// AWOO-MIXINS

/// supported alpha modes
///
/// When this object is created, it shall immediately send this event once
/// for each alpha mode the compositor supports.
///
/// For the definition of the supported values, see the
/// wp_color_representation_surface_v1::alpha_mode enum.
///
class WpColorRepresentationManagerV1SupportedAlphaModeEvent {
  /// supported alpha mode
  final int alphaMode;

  WpColorRepresentationManagerV1SupportedAlphaModeEvent(
    this.alphaMode,
  );

  @override
  toString() {
    return "WpColorRepresentationManagerV1SupportedAlphaModeEvent (alphaMode: $alphaMode)";
  }
}

typedef WpColorRepresentationManagerV1SupportedAlphaModeEventHandler = void
    Function(WpColorRepresentationManagerV1SupportedAlphaModeEvent);

/// supported matrix coefficients and ranges
///
/// When this object is created, it shall immediately send this event once
/// for each matrix coefficient and color range combination the compositor
/// supports.
///
/// For the definition of the supported values, see the
/// wp_color_representation_surface_v1::coefficients and
/// wp_color_representation_surface_v1::range enums.
///
class WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEvent {
  /// supported matrix coefficients
  final int coefficients;

  /// full range flag
  final int range;

  WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEvent(
    this.coefficients,
    this.range,
  );

  @override
  toString() {
    return "WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEvent (coefficients: $coefficients, range: $range)";
  }
}

typedef WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEventHandler
    = void Function(
        WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEvent);

/// all features have been sent
///
/// This event is sent when all supported features have been sent.
///
class WpColorRepresentationManagerV1DoneEvent {
  WpColorRepresentationManagerV1DoneEvent();

  @override
  toString() {
    return "WpColorRepresentationManagerV1DoneEvent ()";
  }
}

typedef WpColorRepresentationManagerV1DoneEventHandler = void Function(
    WpColorRepresentationManagerV1DoneEvent);

/// color representation manager singleton
///
/// A singleton global interface used for getting color representation
/// extensions for wl_surface. The extension interfaces allow setting the
/// color representation of surfaces.
///
/// Compositors should never remove this global.
///
class WpColorRepresentationManagerV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  WpColorRepresentationManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorRepresentationManagerV1 {name: 'wp_color_representation_manager_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the manager
  ///
  /// Destroy the wp_color_representation_manager_v1 object. This does not
  /// affect any other objects in any way.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorRepresentationManagerV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorRepresentationManagerV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// create a color representation interface for a wl_surface
  ///
  /// If a wp_color_representation_surface_v1 object already exists for the
  /// given wl_surface, the protocol error surface_exists is raised.
  ///
  /// This creates a new color wp_color_representation_surface_v1 object for
  /// the given wl_surface.
  ///
  /// See the wp_color_representation_surface_v1 interface for more details.
  ///
  /// [id]:
  /// [surface]:
  Result<WpColorRepresentationSurfaceV1, Object> getSurface(Surface surface) {
    var id = WpColorRepresentationSurfaceV1(innerContext);
    logLn(
        "WpColorRepresentationManagerV1::getSurface  id: $id surface: $surface");
    var arguments = [id, surface];
    var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorRepresentationManagerV1::getSurface: $e");
      return Failure(e);
    }
    return Success(id);
  }

  /// supported alpha modes
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each alpha mode the compositor supports.
  ///
  /// For the definition of the supported values, see the
  /// wp_color_representation_surface_v1::alpha_mode enum.
  ///
  /// Event handler for SupportedAlphaMode
  /// - [alpha_mode]: supported alpha mode
  void onSupportedAlphaMode(
      WpColorRepresentationManagerV1SupportedAlphaModeEventHandler handler) {
    _supportedAlphaModeHandler = handler;
  }

  WpColorRepresentationManagerV1SupportedAlphaModeEventHandler?
      _supportedAlphaModeHandler;

  /// supported matrix coefficients and ranges
  ///
  /// When this object is created, it shall immediately send this event once
  /// for each matrix coefficient and color range combination the compositor
  /// supports.
  ///
  /// For the definition of the supported values, see the
  /// wp_color_representation_surface_v1::coefficients and
  /// wp_color_representation_surface_v1::range enums.
  ///
  /// Event handler for SupportedCoefficientsAndRanges
  /// - [coefficients]: supported matrix coefficients
  /// - [range]: full range flag
  void onSupportedCoefficientsAndRanges(
      WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEventHandler
          handler) {
    _supportedCoefficientsAndRangesHandler = handler;
  }

  WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEventHandler?
      _supportedCoefficientsAndRangesHandler;

  /// all features have been sent
  ///
  /// This event is sent when all supported features have been sent.
  ///
  /// Event handler for Done
  void onDone(WpColorRepresentationManagerV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  WpColorRepresentationManagerV1DoneEventHandler? _doneHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("WpColorRepresentationManagerV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_supportedAlphaModeHandler != null) {
          var offset = 0;
          final alphaMode =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = WpColorRepresentationManagerV1SupportedAlphaModeEvent(
            alphaMode,
          );
          _supportedAlphaModeHandler!(event);
        }
        break;
      case 1:
        if (_supportedCoefficientsAndRangesHandler != null) {
          var offset = 0;
          final coefficients =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final range =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event =
              WpColorRepresentationManagerV1SupportedCoefficientsAndRangesEvent(
            coefficients,
            range,
          );
          _supportedCoefficientsAndRangesHandler!(event);
        }
        break;
      case 2:
        if (_doneHandler != null) {
          _doneHandler!(WpColorRepresentationManagerV1DoneEvent());
        }
        break;
    }
  }
}

/// protocol errors
///

enum WpColorRepresentationManagerV1Error {
  /// color representation surface exists already
  surfaceExists("surface_exists", 1);

  const WpColorRepresentationManagerV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationManagerV1Error {name: $enumName, value: $enumValue}";
  }
}

/// color representation extension to a surface
///
/// A wp_color_representation_surface_v1 allows the client to set the color
/// representation metadata of a surface.
///
/// By default, a surface does not have any color representation metadata set.
/// The reconstruction of R, G, B signals on such surfaces is compositor
/// implementation defined. The alpha mode is assumed to be
/// premultiplied_electrical when the alpha mode is unset.
///
/// If the wl_surface associated with the wp_color_representation_surface_v1
/// is destroyed, the wp_color_representation_surface_v1 object becomes inert.
///
class WpColorRepresentationSurfaceV1 extends Proxy {
  final Context innerContext;
  final version = 1;

  WpColorRepresentationSurfaceV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "WpColorRepresentationSurfaceV1 {name: 'wp_color_representation_surface_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the color representation
  ///
  /// Destroy the wp_color_representation_surface_v1 object.
  ///
  /// Destroying this object unsets all the color representation metadata from
  /// the surface. See the wp_color_representation_surface_v1 interface
  /// description for how a compositor handles a surface without color
  /// representation metadata. Unsetting is double-buffered state, see
  /// wl_surface.commit.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("WpColorRepresentationSurfaceV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorRepresentationSurfaceV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the surface alpha mode
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// Assuming an alpha channel exists, it is always linear. The alpha mode
  /// determines whether and how the color channels include pre-multiplied
  /// alpha. Using straight alpha might have performance benefits.
  ///
  /// Only alpha modes advertised by the compositor are allowed to be used as
  /// argument for this request. The "alpha_mode" protocol error is raised
  /// otherwise.
  ///
  /// Alpha mode is double buffered, see wl_surface.commit.
  ///
  /// [alpha_mode]: alpha mode
  Result<void, Object> setAlphaMode(int alphaMode) {
    logLn(
        "WpColorRepresentationSurfaceV1::setAlphaMode  alphaMode: $alphaMode");
    var arguments = [alphaMode];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([alphaMode]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in WpColorRepresentationSurfaceV1::setAlphaMode: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the matrix coefficients and range
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// Set the matrix coefficients and video range which defines the formula
  /// and the related constants used to derive red, green and blue signals.
  /// Usually coefficients correspond to MatrixCoefficients code points in
  /// H.273.
  ///
  /// Only combinations advertised by the compositor are allowed to be used as
  /// argument for this request. The "coefficients" protocol error is raised
  /// otherwise.
  ///
  /// A call to wl_surface.commit verifies that the pixel format and the
  /// coefficients-range combination in the committed surface contents are
  /// compatible, if contents exist. The "pixel_format" protocol error is
  /// raised otherwise.
  ///
  /// A pixel format is compatible with the coefficients-range combination if
  /// the related equations and conventions as defined in H.273 can produce
  /// the color channels (RGB or YCbCr) of the pixel format.
  ///
  /// For the definition of the supported combination, see the
  /// wp_color_representation_surface_v1::coefficients and
  /// wp_color_representation_surface_v1::range enums.
  ///
  /// The coefficients-range combination is double-buffered, see
  /// wl_surface.commit.
  ///
  /// [coefficients]: matrix coefficients
  /// [range]: range
  Result<void, Object> setCoefficientsAndRange(int coefficients, int range) {
    logLn(
        "WpColorRepresentationSurfaceV1::setCoefficientsAndRange  coefficients: $coefficients range: $range");
    var arguments = [coefficients, range];
    var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    bytesBuilder.add(Uint32List.fromList([coefficients]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([range]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpColorRepresentationSurfaceV1::setCoefficientsAndRange: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// set the chroma location
  ///
  /// If this protocol object is inert, the protocol error inert is raised.
  ///
  /// Set the chroma location type which defines the position of downsampled
  /// chroma samples, corresponding to Chroma420SampleLocType code points in
  /// H.273.
  ///
  /// A call to wl_surface.commit verifies that the pixel format and chroma
  /// location type in the committed surface contents are compatible, if
  /// contents exist. The "pixel_format" protocol error is raised otherwise.
  ///
  /// For the definition of the supported chroma location types, see the
  /// wp_color_representation_surface_v1::chroma_location enum.
  ///
  /// The chroma location type is double-buffered, see wl_surface.commit.
  ///
  /// [chroma_location]: chroma sample location
  Result<void, Object> setChromaLocation(int chromaLocation) {
    logLn(
        "WpColorRepresentationSurfaceV1::setChromaLocation  chromaLocation: $chromaLocation");
    var arguments = [chromaLocation];
    var argTypes = <WaylandType>[WaylandType.uint];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    bytesBuilder
        .add(Uint32List.fromList([chromaLocation]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn(
          "Exception in WpColorRepresentationSurfaceV1::setChromaLocation: $e");
      return Failure(e);
    }
    return Success(Object());
  }
}

/// protocol errors
///

enum WpColorRepresentationSurfaceV1Error {
  /// unsupported alpha mode
  alphaMode("alpha_mode", 1),

  /// unsupported coefficients
  coefficients("coefficients", 2),

  /// the pixel format and a set value are incompatible
  pixelFormat("pixel_format", 3),

  /// forbidden request on inert object
  inert("inert", 4);

  const WpColorRepresentationSurfaceV1Error(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationSurfaceV1Error {name: $enumName, value: $enumValue}";
  }
}

/// alpha mode
///
/// Specifies how the alpha channel affects the color channels.
///

enum WpColorRepresentationSurfaceV1AlphaMode {
  ///
  premultipliedElectrical("premultiplied_electrical", 0),

  ///
  premultipliedOptical("premultiplied_optical", 1),

  ///
  straight("straight", 2);

  const WpColorRepresentationSurfaceV1AlphaMode(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationSurfaceV1AlphaMode {name: $enumName, value: $enumValue}";
  }
}

/// named coefficients
///
/// Named matrix coefficients used to encode well-known sets of
/// coefficients. H.273 is the authority, when it comes to the exact values
/// of coefficients and authoritative specifications, where an equivalent
/// code point exists.
///
/// A value of 0 is invalid and will never be present in the list of enums.
///
/// Descriptions do list the specifications for convenience.
///

enum WpColorRepresentationSurfaceV1Coefficients {
  ///
  identity("identity", 1),

  ///
  bt709("bt709", 2),

  ///
  fcc("fcc", 3),

  ///
  bt601("bt601", 4),

  ///
  smpte240("smpte240", 5),

  ///
  bt2020("bt2020", 6),

  ///
  bt2020Cl("bt2020_cl", 7),

  ///
  ictcp("ictcp", 8);

  const WpColorRepresentationSurfaceV1Coefficients(
      this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationSurfaceV1Coefficients {name: $enumName, value: $enumValue}";
  }
}

/// Color range values
///
/// Possible color range values.
///
/// A value of 0 is invalid and will never be present in the list of enums.
///

enum WpColorRepresentationSurfaceV1Range {
  /// Full color range
  full("full", 1),

  /// Limited color range
  limited("limited", 2);

  const WpColorRepresentationSurfaceV1Range(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationSurfaceV1Range {name: $enumName, value: $enumValue}";
  }
}

/// Chroma sample location for 4:2:0 YCbCr
///
/// Chroma sample location as defined by H.273 Chroma420SampleLocType.
///
/// A value of 0 is invalid and will never be present in the list of enums.
///
/// The descriptions list the matching Vulkan VkChromaLocation combinations
/// for convenience.
///

enum WpColorRepresentationSurfaceV1ChromaLocation {
  ///
  type0("type_0", 1),

  ///
  type1("type_1", 2),

  ///
  type2("type_2", 3),

  ///
  type3("type_3", 4),

  ///
  type4("type_4", 5),

  ///
  type5("type_5", 6);

  const WpColorRepresentationSurfaceV1ChromaLocation(
      this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "WpColorRepresentationSurfaceV1ChromaLocation {name: $enumName, value: $enumValue}";
  }
}
