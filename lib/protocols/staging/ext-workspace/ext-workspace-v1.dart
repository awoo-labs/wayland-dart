// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/ext-workspace/ext-workspace-v1.xml
//
// ext_workspace_v1 Protocol Copyright:
///
/// Copyright © 2019 Christopher Billington
/// Copyright © 2020 Ilia Bozhinov
/// Copyright © 2022 Victoria Brekenfeld
///
/// Permission to use, copy, modify, distribute, and sell this
/// software and its documentation for any purpose is hereby granted
/// without fee, provided that the above copyright notice appear in
/// all copies and that both that copyright notice and this permission
/// notice appear in supporting documentation, and that the name of
/// the copyright holders not be used in advertising or publicity
/// pertaining to distribution of the software without specific,
/// written prior permission.  The copyright holders make no
/// representations about the suitability of this software for any
/// purpose.  It is provided "as is" without express or implied
/// warranty.
///
/// THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
/// SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
/// FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
/// SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
/// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
/// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
/// ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
/// THIS SOFTWARE.
///

library client;

import 'package:wayland/wayland.dart';
import 'dart:convert';
import 'dart:typed_data';
// AWOO-MIXINS

/// a workspace group has been created
///
/// This event is emitted whenever a new workspace group has been created.
///
/// All initial details of the workspace group (outputs) will be
/// sent immediately after this event via the corresponding events in
/// ext_workspace_group_handle_v1 and ext_workspace_handle_v1.
///
class ExtWorkspaceManagerV1WorkspaceGroupEvent {
  ///
  final int workspaceGroup;

  ExtWorkspaceManagerV1WorkspaceGroupEvent(
    this.workspaceGroup,
  );

  @override
  toString() {
    return "ExtWorkspaceManagerV1WorkspaceGroupEvent (workspaceGroup: $workspaceGroup)";
  }
}

typedef ExtWorkspaceManagerV1WorkspaceGroupEventHandler = void Function(
    ExtWorkspaceManagerV1WorkspaceGroupEvent);

/// workspace has been created
///
/// This event is emitted whenever a new workspace has been created.
///
/// All initial details of the workspace (name, coordinates, state) will
/// be sent immediately after this event via the corresponding events in
/// ext_workspace_handle_v1.
///
/// Workspaces start off unassigned to any workspace group.
///
class ExtWorkspaceManagerV1WorkspaceEvent {
  ///
  final int workspace;

  ExtWorkspaceManagerV1WorkspaceEvent(
    this.workspace,
  );

  @override
  toString() {
    return "ExtWorkspaceManagerV1WorkspaceEvent (workspace: $workspace)";
  }
}

typedef ExtWorkspaceManagerV1WorkspaceEventHandler = void Function(
    ExtWorkspaceManagerV1WorkspaceEvent);

/// all information about the workspaces and workspace groups has been sent
///
/// This event is sent after all changes in all workspaces and workspace groups have been
/// sent.
///
/// This allows changes to one or more ext_workspace_group_handle_v1
/// properties and ext_workspace_handle_v1 properties
/// to be seen as atomic, even if they happen via multiple events.
/// In particular, an output moving from one workspace group to
/// another sends an output_enter event and an output_leave event to the two
/// ext_workspace_group_handle_v1 objects in question. The compositor sends
/// the done event only after updating the output information in both
/// workspace groups.
///
class ExtWorkspaceManagerV1DoneEvent {
  ExtWorkspaceManagerV1DoneEvent();

  @override
  toString() {
    return "ExtWorkspaceManagerV1DoneEvent ()";
  }
}

typedef ExtWorkspaceManagerV1DoneEventHandler = void Function(
    ExtWorkspaceManagerV1DoneEvent);

/// the compositor has finished with the workspace_manager
///
/// This event indicates that the compositor is done sending events to the
/// ext_workspace_manager_v1. The server will destroy the object
/// immediately after sending this request.
///
class ExtWorkspaceManagerV1FinishedEvent {
  ExtWorkspaceManagerV1FinishedEvent();

  @override
  toString() {
    return "ExtWorkspaceManagerV1FinishedEvent ()";
  }
}

typedef ExtWorkspaceManagerV1FinishedEventHandler = void Function(
    ExtWorkspaceManagerV1FinishedEvent);

/// list and control workspaces
///
/// Workspaces, also called virtual desktops, are groups of surfaces. A
/// compositor with a concept of workspaces may only show some such groups of
/// surfaces (those of 'active' workspaces) at a time. 'Activating' a
/// workspace is a request for the compositor to display that workspace's
/// surfaces as normal, whereas the compositor may hide or otherwise
/// de-emphasise surfaces that are associated only with 'inactive' workspaces.
/// Workspaces are grouped by which sets of outputs they correspond to, and
/// may contain surfaces only from those outputs. In this way, it is possible
/// for each output to have its own set of workspaces, or for all outputs (or
/// any other arbitrary grouping) to share workspaces. Compositors may
/// optionally conceptually arrange each group of workspaces in an
/// N-dimensional grid.
///
/// The purpose of this protocol is to enable the creation of taskbars and
/// docks by providing them with a list of workspaces and their properties,
/// and allowing them to activate and deactivate workspaces.
///
/// After a client binds the ext_workspace_manager_v1, each workspace will be
/// sent via the workspace event.
///
class ExtWorkspaceManagerV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtWorkspaceManagerV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtWorkspaceManagerV1 {name: 'ext_workspace_manager_v1', id: '$objectId', version: '1',}";
  }

  /// all requests about the workspaces have been sent
  ///
  /// The client must send this request after it has finished sending other
  /// requests. The compositor must process a series of requests preceding a
  /// commit request atomically.
  ///
  /// This allows changes to the workspace properties to be seen as atomic,
  /// even if they happen via multiple events, and even if they involve
  /// multiple ext_workspace_handle_v1 objects, for example, deactivating one
  /// workspace and activating another.
  ///
  Result<void, Object> commit() {
    logLn("ExtWorkspaceManagerV1::commit ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceManagerV1::commit: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// stop sending events
  ///
  /// Indicates the client no longer wishes to receive events for new
  /// workspace groups. However the compositor may emit further workspace
  /// events, until the finished event is emitted. The compositor is expected
  /// to send the finished event eventually once the stop request has been processed.
  ///
  /// The client must not send any requests after this one, doing so will raise a wl_display
  /// invalid_object error.
  ///
  Result<void, Object> stop() {
    logLn("ExtWorkspaceManagerV1::stop ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceManagerV1::stop: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// a workspace group has been created
  ///
  /// This event is emitted whenever a new workspace group has been created.
  ///
  /// All initial details of the workspace group (outputs) will be
  /// sent immediately after this event via the corresponding events in
  /// ext_workspace_group_handle_v1 and ext_workspace_handle_v1.
  ///
  /// Event handler for WorkspaceGroup
  /// - [workspace_group]:
  void onWorkspaceGroup(
      ExtWorkspaceManagerV1WorkspaceGroupEventHandler handler) {
    _workspaceGroupHandler = handler;
  }

  ExtWorkspaceManagerV1WorkspaceGroupEventHandler? _workspaceGroupHandler;

  /// workspace has been created
  ///
  /// This event is emitted whenever a new workspace has been created.
  ///
  /// All initial details of the workspace (name, coordinates, state) will
  /// be sent immediately after this event via the corresponding events in
  /// ext_workspace_handle_v1.
  ///
  /// Workspaces start off unassigned to any workspace group.
  ///
  /// Event handler for Workspace
  /// - [workspace]:
  void onWorkspace(ExtWorkspaceManagerV1WorkspaceEventHandler handler) {
    _workspaceHandler = handler;
  }

  ExtWorkspaceManagerV1WorkspaceEventHandler? _workspaceHandler;

  /// all information about the workspaces and workspace groups has been sent
  ///
  /// This event is sent after all changes in all workspaces and workspace groups have been
  /// sent.
  ///
  /// This allows changes to one or more ext_workspace_group_handle_v1
  /// properties and ext_workspace_handle_v1 properties
  /// to be seen as atomic, even if they happen via multiple events.
  /// In particular, an output moving from one workspace group to
  /// another sends an output_enter event and an output_leave event to the two
  /// ext_workspace_group_handle_v1 objects in question. The compositor sends
  /// the done event only after updating the output information in both
  /// workspace groups.
  ///
  /// Event handler for Done
  void onDone(ExtWorkspaceManagerV1DoneEventHandler handler) {
    _doneHandler = handler;
  }

  ExtWorkspaceManagerV1DoneEventHandler? _doneHandler;

  /// the compositor has finished with the workspace_manager
  ///
  /// This event indicates that the compositor is done sending events to the
  /// ext_workspace_manager_v1. The server will destroy the object
  /// immediately after sending this request.
  ///
  /// Event handler for Finished
  void onFinished(ExtWorkspaceManagerV1FinishedEventHandler handler) {
    _finishedHandler = handler;
  }

  ExtWorkspaceManagerV1FinishedEventHandler? _finishedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtWorkspaceManagerV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_workspaceGroupHandler != null) {
          var offset = 0;
          final workspaceGroup = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceManagerV1WorkspaceGroupEvent(
            workspaceGroup,
          );
          _workspaceGroupHandler!(event);
        }
        break;
      case 1:
        if (_workspaceHandler != null) {
          var offset = 0;
          final workspace = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceManagerV1WorkspaceEvent(
            workspace,
          );
          _workspaceHandler!(event);
        }
        break;
      case 2:
        if (_doneHandler != null) {
          _doneHandler!(ExtWorkspaceManagerV1DoneEvent());
        }
        break;
      case 3:
        if (_finishedHandler != null) {
          _finishedHandler!(ExtWorkspaceManagerV1FinishedEvent());
        }
        break;
    }
  }
}

/// compositor capabilities
///
/// This event advertises the capabilities supported by the compositor. If
/// a capability isn't supported, clients should hide or disable the UI
/// elements that expose this functionality. For instance, if the
/// compositor doesn't advertise support for creating workspaces, a button
/// triggering the create_workspace request should not be displayed.
///
/// The compositor will ignore requests it doesn't support. For instance,
/// a compositor which doesn't advertise support for creating workspaces will ignore
/// create_workspace requests.
///
/// Compositors must send this event once after creation of an
/// ext_workspace_group_handle_v1. When the capabilities change, compositors
/// must send this event again.
///
class ExtWorkspaceGroupHandleV1CapabilitiesEvent {
  /// capabilities
  final int capabilities;

  ExtWorkspaceGroupHandleV1CapabilitiesEvent(
    this.capabilities,
  );

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1CapabilitiesEvent (capabilities: $capabilities)";
  }
}

typedef ExtWorkspaceGroupHandleV1CapabilitiesEventHandler = void Function(
    ExtWorkspaceGroupHandleV1CapabilitiesEvent);

/// output assigned to workspace group
///
/// This event is emitted whenever an output is assigned to the workspace
/// group or a new `wl_output` object is bound by the client, which was already
/// assigned to this workspace_group.
///
class ExtWorkspaceGroupHandleV1OutputEnterEvent {
  ///
  final int output;

  ExtWorkspaceGroupHandleV1OutputEnterEvent(
    this.output,
  );

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1OutputEnterEvent (output: $output)";
  }
}

typedef ExtWorkspaceGroupHandleV1OutputEnterEventHandler = void Function(
    ExtWorkspaceGroupHandleV1OutputEnterEvent);

/// output removed from workspace group
///
/// This event is emitted whenever an output is removed from the workspace
/// group.
///
class ExtWorkspaceGroupHandleV1OutputLeaveEvent {
  ///
  final int output;

  ExtWorkspaceGroupHandleV1OutputLeaveEvent(
    this.output,
  );

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1OutputLeaveEvent (output: $output)";
  }
}

typedef ExtWorkspaceGroupHandleV1OutputLeaveEventHandler = void Function(
    ExtWorkspaceGroupHandleV1OutputLeaveEvent);

/// workspace added to workspace group
///
/// This event is emitted whenever a workspace is assigned to this group.
/// A workspace may only ever be assigned to a single group at a single point
/// in time, but can be re-assigned during it's lifetime.
///
class ExtWorkspaceGroupHandleV1WorkspaceEnterEvent {
  ///
  final int workspace;

  ExtWorkspaceGroupHandleV1WorkspaceEnterEvent(
    this.workspace,
  );

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1WorkspaceEnterEvent (workspace: $workspace)";
  }
}

typedef ExtWorkspaceGroupHandleV1WorkspaceEnterEventHandler = void Function(
    ExtWorkspaceGroupHandleV1WorkspaceEnterEvent);

/// workspace removed from workspace group
///
/// This event is emitted whenever a workspace is removed from this group.
///
class ExtWorkspaceGroupHandleV1WorkspaceLeaveEvent {
  ///
  final int workspace;

  ExtWorkspaceGroupHandleV1WorkspaceLeaveEvent(
    this.workspace,
  );

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1WorkspaceLeaveEvent (workspace: $workspace)";
  }
}

typedef ExtWorkspaceGroupHandleV1WorkspaceLeaveEventHandler = void Function(
    ExtWorkspaceGroupHandleV1WorkspaceLeaveEvent);

/// this workspace group has been removed
///
/// This event is send when the group associated with the ext_workspace_group_handle_v1
/// has been removed. After sending this request the compositor will immediately consider
/// the object inert. Any requests will be ignored except the destroy request.
/// It is guaranteed there won't be any more events referencing this
/// ext_workspace_group_handle_v1.
///
/// The compositor must remove all workspaces belonging to a workspace group
/// via a workspace_leave event before removing the workspace group.
///
class ExtWorkspaceGroupHandleV1RemovedEvent {
  ExtWorkspaceGroupHandleV1RemovedEvent();

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1RemovedEvent ()";
  }
}

typedef ExtWorkspaceGroupHandleV1RemovedEventHandler = void Function(
    ExtWorkspaceGroupHandleV1RemovedEvent);

/// a workspace group assigned to a set of outputs
///
/// A ext_workspace_group_handle_v1 object represents a workspace group
/// that is assigned a set of outputs and contains a number of workspaces.
///
/// The set of outputs assigned to the workspace group is conveyed to the client via
/// output_enter and output_leave events, and its workspaces are conveyed with
/// workspace events.
///
/// For example, a compositor which has a set of workspaces for each output may
/// advertise a workspace group (and its workspaces) per output, whereas a compositor
/// where a workspace spans all outputs may advertise a single workspace group for all
/// outputs.
///
class ExtWorkspaceGroupHandleV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtWorkspaceGroupHandleV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1 {name: 'ext_workspace_group_handle_v1', id: '$objectId', version: '1',}";
  }

  /// create a new workspace
  ///
  /// Request that the compositor create a new workspace with the given name
  /// and assign it to this group.
  ///
  /// There is no guarantee that the compositor will create a new workspace,
  /// or that the created workspace will have the provided name.
  ///
  /// [workspace]:
  Result<void, Object> createWorkspace(String workspace) {
    logLn("ExtWorkspaceGroupHandleV1::createWorkspace  workspace: $workspace");
    var arguments = [workspace];
    var argTypes = <WaylandType>[WaylandType.string];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    final workspaceBytes = utf8.encode(workspace);
    bytesBuilder.add(
        Uint32List.fromList([workspaceBytes.length + 1]).buffer.asUint8List());
    bytesBuilder.add(workspaceBytes);
    bytesBuilder.add([0]); // Null terminator
    while (bytesBuilder.length % 4 != 0) {
      bytesBuilder.add([0]);
    } // Padding
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceGroupHandleV1::createWorkspace: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// destroy the ext_workspace_group_handle_v1 object
  ///
  /// Destroys the ext_workspace_group_handle_v1 object.
  ///
  /// This request should be send either when the client does not want to
  /// use the workspace group object any more or after the removed event to finalize
  /// the destruction of the object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtWorkspaceGroupHandleV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceGroupHandleV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// compositor capabilities
  ///
  /// This event advertises the capabilities supported by the compositor. If
  /// a capability isn't supported, clients should hide or disable the UI
  /// elements that expose this functionality. For instance, if the
  /// compositor doesn't advertise support for creating workspaces, a button
  /// triggering the create_workspace request should not be displayed.
  ///
  /// The compositor will ignore requests it doesn't support. For instance,
  /// a compositor which doesn't advertise support for creating workspaces will ignore
  /// create_workspace requests.
  ///
  /// Compositors must send this event once after creation of an
  /// ext_workspace_group_handle_v1. When the capabilities change, compositors
  /// must send this event again.
  ///
  /// Event handler for Capabilities
  /// - [capabilities]: capabilities
  void onCapabilities(
      ExtWorkspaceGroupHandleV1CapabilitiesEventHandler handler) {
    _capabilitiesHandler = handler;
  }

  ExtWorkspaceGroupHandleV1CapabilitiesEventHandler? _capabilitiesHandler;

  /// output assigned to workspace group
  ///
  /// This event is emitted whenever an output is assigned to the workspace
  /// group or a new `wl_output` object is bound by the client, which was already
  /// assigned to this workspace_group.
  ///
  /// Event handler for OutputEnter
  /// - [output]:
  void onOutputEnter(ExtWorkspaceGroupHandleV1OutputEnterEventHandler handler) {
    _outputEnterHandler = handler;
  }

  ExtWorkspaceGroupHandleV1OutputEnterEventHandler? _outputEnterHandler;

  /// output removed from workspace group
  ///
  /// This event is emitted whenever an output is removed from the workspace
  /// group.
  ///
  /// Event handler for OutputLeave
  /// - [output]:
  void onOutputLeave(ExtWorkspaceGroupHandleV1OutputLeaveEventHandler handler) {
    _outputLeaveHandler = handler;
  }

  ExtWorkspaceGroupHandleV1OutputLeaveEventHandler? _outputLeaveHandler;

  /// workspace added to workspace group
  ///
  /// This event is emitted whenever a workspace is assigned to this group.
  /// A workspace may only ever be assigned to a single group at a single point
  /// in time, but can be re-assigned during it's lifetime.
  ///
  /// Event handler for WorkspaceEnter
  /// - [workspace]:
  void onWorkspaceEnter(
      ExtWorkspaceGroupHandleV1WorkspaceEnterEventHandler handler) {
    _workspaceEnterHandler = handler;
  }

  ExtWorkspaceGroupHandleV1WorkspaceEnterEventHandler? _workspaceEnterHandler;

  /// workspace removed from workspace group
  ///
  /// This event is emitted whenever a workspace is removed from this group.
  ///
  /// Event handler for WorkspaceLeave
  /// - [workspace]:
  void onWorkspaceLeave(
      ExtWorkspaceGroupHandleV1WorkspaceLeaveEventHandler handler) {
    _workspaceLeaveHandler = handler;
  }

  ExtWorkspaceGroupHandleV1WorkspaceLeaveEventHandler? _workspaceLeaveHandler;

  /// this workspace group has been removed
  ///
  /// This event is send when the group associated with the ext_workspace_group_handle_v1
  /// has been removed. After sending this request the compositor will immediately consider
  /// the object inert. Any requests will be ignored except the destroy request.
  /// It is guaranteed there won't be any more events referencing this
  /// ext_workspace_group_handle_v1.
  ///
  /// The compositor must remove all workspaces belonging to a workspace group
  /// via a workspace_leave event before removing the workspace group.
  ///
  /// Event handler for Removed
  void onRemoved(ExtWorkspaceGroupHandleV1RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ExtWorkspaceGroupHandleV1RemovedEventHandler? _removedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtWorkspaceGroupHandleV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_capabilitiesHandler != null) {
          var offset = 0;
          final capabilities =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtWorkspaceGroupHandleV1CapabilitiesEvent(
            capabilities,
          );
          _capabilitiesHandler!(event);
        }
        break;
      case 1:
        if (_outputEnterHandler != null) {
          var offset = 0;
          final output = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceGroupHandleV1OutputEnterEvent(
            output,
          );
          _outputEnterHandler!(event);
        }
        break;
      case 2:
        if (_outputLeaveHandler != null) {
          var offset = 0;
          final output = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceGroupHandleV1OutputLeaveEvent(
            output,
          );
          _outputLeaveHandler!(event);
        }
        break;
      case 3:
        if (_workspaceEnterHandler != null) {
          var offset = 0;
          final workspace = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceGroupHandleV1WorkspaceEnterEvent(
            workspace,
          );
          _workspaceEnterHandler!(event);
        }
        break;
      case 4:
        if (_workspaceLeaveHandler != null) {
          var offset = 0;
          final workspace = innerContext
              .getProxy(
                  ByteData.view(data.buffer).getUint32(offset, Endian.little))
              .objectId;
          offset += 4;
          var event = ExtWorkspaceGroupHandleV1WorkspaceLeaveEvent(
            workspace,
          );
          _workspaceLeaveHandler!(event);
        }
        break;
      case 5:
        if (_removedHandler != null) {
          _removedHandler!(ExtWorkspaceGroupHandleV1RemovedEvent());
        }
        break;
    }
  }
}

///
///

enum ExtWorkspaceGroupHandleV1GroupCapabilities {
  /// create_workspace request is available
  createWorkspace("create_workspace", 1);

  const ExtWorkspaceGroupHandleV1GroupCapabilities(
      this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtWorkspaceGroupHandleV1GroupCapabilities {name: $enumName, value: $enumValue}";
  }
}

/// workspace id
///
/// If this event is emitted, it will be send immediately after the
/// ext_workspace_handle_v1 is created or when an id is assigned to
/// a workspace (at most once during it's lifetime).
///
/// An id will never change during the lifetime of the `ext_workspace_handle_v1`
/// and is guaranteed to be unique during it's lifetime.
///
/// Ids are not human-readable and shouldn't be displayed, use `name` for that purpose.
///
/// Compositors are expected to only send ids for workspaces likely stable across multiple
/// sessions and can be used by clients to store preferences for workspaces. Workspaces without
/// ids should be considered temporary and any data associated with them should be deleted once
/// the respective object is lost.
///
class ExtWorkspaceHandleV1IdEvent {
  ///
  final String id;

  ExtWorkspaceHandleV1IdEvent(
    this.id,
  );

  @override
  toString() {
    return "ExtWorkspaceHandleV1IdEvent (id: $id)";
  }
}

typedef ExtWorkspaceHandleV1IdEventHandler = void Function(
    ExtWorkspaceHandleV1IdEvent);

/// workspace name changed
///
/// This event is emitted immediately after the ext_workspace_handle_v1 is
/// created and whenever the name of the workspace changes.
///
/// A name is meant to be human-readable and can be displayed to a user.
/// Unlike the id it is neither stable nor unique.
///
class ExtWorkspaceHandleV1NameEvent {
  ///
  final String name;

  ExtWorkspaceHandleV1NameEvent(
    this.name,
  );

  @override
  toString() {
    return "ExtWorkspaceHandleV1NameEvent (name: $name)";
  }
}

typedef ExtWorkspaceHandleV1NameEventHandler = void Function(
    ExtWorkspaceHandleV1NameEvent);

/// workspace coordinates changed
///
/// This event is used to organize workspaces into an N-dimensional grid
/// within a workspace group, and if supported, is emitted immediately after
/// the ext_workspace_handle_v1 is created and whenever the coordinates of
/// the workspace change. Compositors may not send this event if they do not
/// conceptually arrange workspaces in this way. If compositors simply
/// number workspaces, without any geometric interpretation, they may send
/// 1D coordinates, which clients should not interpret as implying any
/// geometry. Sending an empty array means that the compositor no longer
/// orders the workspace geometrically.
///
/// Coordinates have an arbitrary number of dimensions N with an uint32
/// position along each dimension. By convention if N > 1, the first
/// dimension is X, the second Y, the third Z, and so on. The compositor may
/// chose to utilize these events for a more novel workspace layout
/// convention, however. No guarantee is made about the grid being filled or
/// bounded; there may be a workspace at coordinate 1 and another at
/// coordinate 1000 and none in between. Within a workspace group, however,
/// workspaces must have unique coordinates of equal dimensionality.
///
class ExtWorkspaceHandleV1CoordinatesEvent {
  ///
  final List<int> coordinates;

  ExtWorkspaceHandleV1CoordinatesEvent(
    this.coordinates,
  );

  @override
  toString() {
    return "ExtWorkspaceHandleV1CoordinatesEvent (coordinates: $coordinates)";
  }
}

typedef ExtWorkspaceHandleV1CoordinatesEventHandler = void Function(
    ExtWorkspaceHandleV1CoordinatesEvent);

/// the state of the workspace changed
///
/// This event is emitted immediately after the ext_workspace_handle_v1 is
/// created and each time the workspace state changes, either because of a
/// compositor action or because of a request in this protocol.
///
/// Missing states convey the opposite meaning, e.g. an unset active bit
/// means the workspace is currently inactive.
///
class ExtWorkspaceHandleV1StateEvent {
  ///
  final int state;

  ExtWorkspaceHandleV1StateEvent(
    this.state,
  );

  @override
  toString() {
    return "ExtWorkspaceHandleV1StateEvent (state: $state)";
  }
}

typedef ExtWorkspaceHandleV1StateEventHandler = void Function(
    ExtWorkspaceHandleV1StateEvent);

/// compositor capabilities
///
/// This event advertises the capabilities supported by the compositor. If
/// a capability isn't supported, clients should hide or disable the UI
/// elements that expose this functionality. For instance, if the
/// compositor doesn't advertise support for removing workspaces, a button
/// triggering the remove request should not be displayed.
///
/// The compositor will ignore requests it doesn't support. For instance,
/// a compositor which doesn't advertise support for remove will ignore
/// remove requests.
///
/// Compositors must send this event once after creation of an
/// ext_workspace_handle_v1 . When the capabilities change, compositors
/// must send this event again.
///
class ExtWorkspaceHandleV1CapabilitiesEvent {
  /// capabilities
  final int capabilities;

  ExtWorkspaceHandleV1CapabilitiesEvent(
    this.capabilities,
  );

  @override
  toString() {
    return "ExtWorkspaceHandleV1CapabilitiesEvent (capabilities: $capabilities)";
  }
}

typedef ExtWorkspaceHandleV1CapabilitiesEventHandler = void Function(
    ExtWorkspaceHandleV1CapabilitiesEvent);

/// this workspace has been removed
///
/// This event is send when the workspace associated with the ext_workspace_handle_v1
/// has been removed. After sending this request, the compositor will immediately consider
/// the object inert. Any requests will be ignored except the destroy request.
///
/// It is guaranteed there won't be any more events referencing this
/// ext_workspace_handle_v1.
///
/// The compositor must only remove a workspaces not currently belonging to any
/// workspace_group.
///
class ExtWorkspaceHandleV1RemovedEvent {
  ExtWorkspaceHandleV1RemovedEvent();

  @override
  toString() {
    return "ExtWorkspaceHandleV1RemovedEvent ()";
  }
}

typedef ExtWorkspaceHandleV1RemovedEventHandler = void Function(
    ExtWorkspaceHandleV1RemovedEvent);

/// a workspace handing a group of surfaces
///
/// A ext_workspace_handle_v1 object represents a workspace that handles a
/// group of surfaces.
///
/// Each workspace has:
/// - a name, conveyed to the client with the name event
/// - potentially an id conveyed with the id event
/// - a list of states, conveyed to the client with the state event
/// - and optionally a set of coordinates, conveyed to the client with the
/// coordinates event
///
/// The client may request that the compositor activate or deactivate the workspace.
///
/// Each workspace can belong to only a single workspace group.
/// Depepending on the compositor policy, there might be workspaces with
/// the same name in different workspace groups, but these workspaces are still
/// separate (e.g. one of them might be active while the other is not).
///
class ExtWorkspaceHandleV1 extends Proxy implements Dispatcher {
  final Context innerContext;
  final version = 1;

  ExtWorkspaceHandleV1(this.innerContext)
      : super(innerContext.allocateClientId()) {
    innerContext.register(this);
  }

  @override
  toString() {
    return "ExtWorkspaceHandleV1 {name: 'ext_workspace_handle_v1', id: '$objectId', version: '1',}";
  }

  /// destroy the ext_workspace_handle_v1 object
  ///
  /// Destroys the ext_workspace_handle_v1 object.
  ///
  /// This request should be made either when the client does not want to
  /// use the workspace object any more or after the remove event to finalize
  /// the destruction of the object.
  ///
  Result<void, Object> destroy() {
    innerContext.unRegister(this);
    logLn("ExtWorkspaceHandleV1::destroy ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 0])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceHandleV1::destroy: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// activate the workspace
  ///
  /// Request that this workspace be activated.
  ///
  /// There is no guarantee the workspace will be actually activated, and
  /// behaviour may be compositor-dependent. For example, activating a
  /// workspace may or may not deactivate all other workspaces in the same
  /// group.
  ///
  Result<void, Object> activate() {
    logLn("ExtWorkspaceHandleV1::activate ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 1])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceHandleV1::activate: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// deactivate the workspace
  ///
  /// Request that this workspace be deactivated.
  ///
  /// There is no guarantee the workspace will be actually deactivated.
  ///
  Result<void, Object> deactivate() {
    logLn("ExtWorkspaceHandleV1::deactivate ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 2])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceHandleV1::deactivate: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// assign workspace to group
  ///
  /// Requests that this workspace is assigned to the given workspace group.
  ///
  /// There is no guarantee the workspace will be assigned.
  ///
  /// [workspace_group]:
  Result<void, Object> assign(ExtWorkspaceGroupHandleV1 workspaceGroup) {
    logLn("ExtWorkspaceHandleV1::assign  workspaceGroup: $workspaceGroup");
    var arguments = [workspaceGroup];
    var argTypes = <WaylandType>[WaylandType.object];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 3])
            .buffer
            .asUint8List());
    bytesBuilder.add(
        Uint32List.fromList([workspaceGroup.objectId]).buffer.asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceHandleV1::assign: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// remove the workspace
  ///
  /// Request that this workspace be removed.
  ///
  /// There is no guarantee the workspace will be actually removed.
  ///
  Result<void, Object> remove() {
    logLn("ExtWorkspaceHandleV1::remove ");
    var arguments = [];
    var argTypes = <WaylandType>[];
    var calclulatedSize = calculateSize(argTypes, arguments);
    final bytesBuilder = BytesBuilder();
    bytesBuilder.add(
        Uint32List.fromList([objectId, (calclulatedSize << 16) | 4])
            .buffer
            .asUint8List());
    try {
      innerContext.sendMessage(
        bytesBuilder.toBytes(),
      );
    } catch (e) {
      logLn("Exception in ExtWorkspaceHandleV1::remove: $e");
      return Failure(e);
    }
    return Success(Object());
  }

  /// workspace id
  ///
  /// If this event is emitted, it will be send immediately after the
  /// ext_workspace_handle_v1 is created or when an id is assigned to
  /// a workspace (at most once during it's lifetime).
  ///
  /// An id will never change during the lifetime of the `ext_workspace_handle_v1`
  /// and is guaranteed to be unique during it's lifetime.
  ///
  /// Ids are not human-readable and shouldn't be displayed, use `name` for that purpose.
  ///
  /// Compositors are expected to only send ids for workspaces likely stable across multiple
  /// sessions and can be used by clients to store preferences for workspaces. Workspaces without
  /// ids should be considered temporary and any data associated with them should be deleted once
  /// the respective object is lost.
  ///
  /// Event handler for Id
  /// - [id]:
  void onId(ExtWorkspaceHandleV1IdEventHandler handler) {
    _idHandler = handler;
  }

  ExtWorkspaceHandleV1IdEventHandler? _idHandler;

  /// workspace name changed
  ///
  /// This event is emitted immediately after the ext_workspace_handle_v1 is
  /// created and whenever the name of the workspace changes.
  ///
  /// A name is meant to be human-readable and can be displayed to a user.
  /// Unlike the id it is neither stable nor unique.
  ///
  /// Event handler for Name
  /// - [name]:
  void onName(ExtWorkspaceHandleV1NameEventHandler handler) {
    _nameHandler = handler;
  }

  ExtWorkspaceHandleV1NameEventHandler? _nameHandler;

  /// workspace coordinates changed
  ///
  /// This event is used to organize workspaces into an N-dimensional grid
  /// within a workspace group, and if supported, is emitted immediately after
  /// the ext_workspace_handle_v1 is created and whenever the coordinates of
  /// the workspace change. Compositors may not send this event if they do not
  /// conceptually arrange workspaces in this way. If compositors simply
  /// number workspaces, without any geometric interpretation, they may send
  /// 1D coordinates, which clients should not interpret as implying any
  /// geometry. Sending an empty array means that the compositor no longer
  /// orders the workspace geometrically.
  ///
  /// Coordinates have an arbitrary number of dimensions N with an uint32
  /// position along each dimension. By convention if N > 1, the first
  /// dimension is X, the second Y, the third Z, and so on. The compositor may
  /// chose to utilize these events for a more novel workspace layout
  /// convention, however. No guarantee is made about the grid being filled or
  /// bounded; there may be a workspace at coordinate 1 and another at
  /// coordinate 1000 and none in between. Within a workspace group, however,
  /// workspaces must have unique coordinates of equal dimensionality.
  ///
  /// Event handler for Coordinates
  /// - [coordinates]:
  void onCoordinates(ExtWorkspaceHandleV1CoordinatesEventHandler handler) {
    _coordinatesHandler = handler;
  }

  ExtWorkspaceHandleV1CoordinatesEventHandler? _coordinatesHandler;

  /// the state of the workspace changed
  ///
  /// This event is emitted immediately after the ext_workspace_handle_v1 is
  /// created and each time the workspace state changes, either because of a
  /// compositor action or because of a request in this protocol.
  ///
  /// Missing states convey the opposite meaning, e.g. an unset active bit
  /// means the workspace is currently inactive.
  ///
  /// Event handler for State
  /// - [state]:
  void onState(ExtWorkspaceHandleV1StateEventHandler handler) {
    _stateHandler = handler;
  }

  ExtWorkspaceHandleV1StateEventHandler? _stateHandler;

  /// compositor capabilities
  ///
  /// This event advertises the capabilities supported by the compositor. If
  /// a capability isn't supported, clients should hide or disable the UI
  /// elements that expose this functionality. For instance, if the
  /// compositor doesn't advertise support for removing workspaces, a button
  /// triggering the remove request should not be displayed.
  ///
  /// The compositor will ignore requests it doesn't support. For instance,
  /// a compositor which doesn't advertise support for remove will ignore
  /// remove requests.
  ///
  /// Compositors must send this event once after creation of an
  /// ext_workspace_handle_v1 . When the capabilities change, compositors
  /// must send this event again.
  ///
  /// Event handler for Capabilities
  /// - [capabilities]: capabilities
  void onCapabilities(ExtWorkspaceHandleV1CapabilitiesEventHandler handler) {
    _capabilitiesHandler = handler;
  }

  ExtWorkspaceHandleV1CapabilitiesEventHandler? _capabilitiesHandler;

  /// this workspace has been removed
  ///
  /// This event is send when the workspace associated with the ext_workspace_handle_v1
  /// has been removed. After sending this request, the compositor will immediately consider
  /// the object inert. Any requests will be ignored except the destroy request.
  ///
  /// It is guaranteed there won't be any more events referencing this
  /// ext_workspace_handle_v1.
  ///
  /// The compositor must only remove a workspaces not currently belonging to any
  /// workspace_group.
  ///
  /// Event handler for Removed
  void onRemoved(ExtWorkspaceHandleV1RemovedEventHandler handler) {
    _removedHandler = handler;
  }

  ExtWorkspaceHandleV1RemovedEventHandler? _removedHandler;

  @override
  void dispatch(int opcode, int fd, Uint8List data) {
    logLn("ExtWorkspaceHandleV1.dispatch($opcode, $fd, $data)");
    switch (opcode) {
      case 0:
        if (_idHandler != null) {
          var offset = 0;
          final idLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final id = utf8.decode(data.sublist(offset, offset + idLength - 1));
          offset += idLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtWorkspaceHandleV1IdEvent(
            id,
          );
          _idHandler!(event);
        }
        break;
      case 1:
        if (_nameHandler != null) {
          var offset = 0;
          final nameLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          final name =
              utf8.decode(data.sublist(offset, offset + nameLength - 1));
          offset += nameLength; // Skip the string bytes and null terminator
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtWorkspaceHandleV1NameEvent(
            name,
          );
          _nameHandler!(event);
        }
        break;
      case 2:
        if (_coordinatesHandler != null) {
          var offset = 0;
          final coordinates = getArray(data, offset);
          var arrayLength =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4 + arrayLength;
          while (offset % 4 != 0) {
            offset++;
          } // Padding
          var event = ExtWorkspaceHandleV1CoordinatesEvent(
            coordinates,
          );
          _coordinatesHandler!(event);
        }
        break;
      case 3:
        if (_stateHandler != null) {
          var offset = 0;
          final state =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtWorkspaceHandleV1StateEvent(
            state,
          );
          _stateHandler!(event);
        }
        break;
      case 4:
        if (_capabilitiesHandler != null) {
          var offset = 0;
          final capabilities =
              ByteData.view(data.buffer).getUint32(offset, Endian.little);
          offset += 4;
          var event = ExtWorkspaceHandleV1CapabilitiesEvent(
            capabilities,
          );
          _capabilitiesHandler!(event);
        }
        break;
      case 5:
        if (_removedHandler != null) {
          _removedHandler!(ExtWorkspaceHandleV1RemovedEvent());
        }
        break;
    }
  }
}

/// types of states on the workspace
///
/// The different states that a workspace can have.
///

enum ExtWorkspaceHandleV1State {
  /// the workspace is active
  active("active", 1),

  /// the workspace requests attention
  urgent("urgent", 2),

  ///
  hidden("hidden", 4);

  const ExtWorkspaceHandleV1State(this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtWorkspaceHandleV1State {name: $enumName, value: $enumValue}";
  }
}

///
///

enum ExtWorkspaceHandleV1WorkspaceCapabilities {
  /// activate request is available
  activate("activate", 1),

  /// deactivate request is available
  deactivate("deactivate", 2),

  /// remove request is available
  remove("remove", 4),

  /// assign request is available
  assign("assign", 8);

  const ExtWorkspaceHandleV1WorkspaceCapabilities(
      this.enumName, this.enumValue);
  final int enumValue;
  final String enumName;
  @override
  toString() {
    return "ExtWorkspaceHandleV1WorkspaceCapabilities {name: $enumName, value: $enumValue}";
  }
}
