import 'dart:io';

import 'package:http/http.dart' as http;
import 'package:path/path.dart';
import 'package:wayland/protocol/log.dart';
import 'package:wayland/protocol/strings.dart';
import 'package:wayland/protocol/type.dart';
import 'package:wayland/scanner/types.dart';
import 'package:xml/xml.dart';

class Generator {
  final String inputFile;
  final String outputFile;
  final String packageName;
  final String prefix;
  final String suffix;
  final String cacheDir;
  final List<String> imports;
  late Protocol protocol;

  final bool format;

  Generator(
      {this.inputFile = '',
      this.outputFile = '',
      this.packageName = '',
      this.prefix = '',
      this.suffix = '',
      this.imports = const [],
      this.format = false,
      this.cacheDir = '.wayland-protocol-cache'});

  Directory getCacheDir() {
    if (Directory.current.path.endsWith('bin')) {
      return Directory(joinAll([Directory.current.parent.path, cacheDir]));
    }

    final cachePath = Directory(cacheDir);
    if (!cachePath.existsSync()) {
      cachePath.createSync();
    }
    return cachePath;
  }

  Future<void> run() async {
    if (inputFile.isEmpty || outputFile.isEmpty) {
      throw Exception('inbut file or output file is empty');
    }

    final xmlContent = await getInputFile(inputFile);
    final document = XmlDocument.parse(xmlContent);
    protocol = Protocol.fromXml(document.rootElement);

    final output = StringBuffer();

    // Header
    output.writeln('// Generated by dart-wayland-scanner');
    output.writeln('// https://github.com/your-repo/dart-wayland-scanner');
    output.writeln('// XML file : $inputFile');
    output.writeln('//');
    output.writeln('// ${protocol.name} Protocol Copyright: ');
    output.writeln(protocol.copyright.comments());
    output.writeln();

    output.writeln('library $packageName;');
    output.writeln();

    // Imports
    // if (protocol.name != 'wayland') {
    output.writeln("import 'package:wayland/wayland.dart';");

    if (protocol.name != 'wayland') {
      output.writeln("import 'package:wayland/generated/wayland.dart';");
    }

    for (final imp in imports) {
      output.writeln("import 'package:wayland/generated/$imp';");
    }

    output.writeln("import 'dart:async';");
    output.writeln("import 'dart:convert';");
    output.writeln("import 'dart:typed_data';");
    // output.writeln("import 'package:wayland/src/wayland_client.dart';");
    // }

    // Interfaces
    for (final interface in protocol.interfaces) {
      writeInterface(output, interface);
    }

    var outFile = File(outputFile);

    if (!outFile.existsSync()) {
      outFile.createSync(recursive: true);
    }

    await outFile.writeAsString(output.toString());
    if (format) await tryFmt(outFile.absolute.path);
    logLn('Generated Dart code written to $outputFile');
  }

  Future tryFmt(String path) async {
    var dart = await findDartExecutable();

    if (dart == null) {
      logLn('Could not find dart executable');
      return;
    }
    await Process.run(dart, ['format',"--fix", path]);
  }

  Future<String?> findDartExecutable() async {
    try {
      var result = await Process.run('which', ['dart']);
      if (result.exitCode == 0) {
        return result.stdout.toString().trim();
      } else {
        logLn(
            'Could not find dart executable: ${result.stderr.toString().trim()}');
        return null;
      }
    } catch (e) {
      logLn('Could not find dart executable');
    }
    return null;
  }

  Future<String> getInputFile(String file) async {
    String cacheDir = getCacheDir().path;

    if (file.startsWith('http')) {
      file = file.replaceFirst('http://', 'https://');

      final cacheFile = File(join(cacheDir, basename(file)));

      if (cacheFile.existsSync()) {
        return await cacheFile.readAsString();
      }

      final response = await http.get(Uri.parse(file));
      var content = response.body;

      cacheFile.writeAsString(content);

      return content;
    } else {
      return await File(file).readAsString();
    }
  }

  String fixName(String name) {
    final illegalArgs = <String, String>{
      'class': 'clazz',
      'class_': 'clazz',
      'default': 'defaulted',
      'enum': 'enumm',
    };
    if (illegalArgs.containsKey(name)) {
      return illegalArgs[name]!;
    }
    return name;
  }

  void writeEnum(StringBuffer output, String ifaceName, Enum enum_) {
    final enumName = toLowerCamel(enum_.name, prefix: prefix, suffix: suffix);

    output.writeln(comment(' ${enum_.description.summary}'));
    output.writeln(comment(enum_.description.text));
    output.writeln();
    output.writeln('enum $ifaceName$enumName {');

    for (final entry in enum_.entries) {
      var entryName =
          toLowerCamel(fixName(entry.name), prefix: prefix, suffix: suffix);

      // Check if the result is a number and prefix with 'W' if it is
      if (int.tryParse(entryName) != null) {
        entryName = 'w$entryName';
      }
      output.writeln(comment('   ${entry.summary}'));
      output.writeln('  $entryName,');
    }

    output.writeln('}');
    output.writeln();
  }

  String getDartType(String type, String interface) {
    switch (type) {
      case 'int':
      case 'uint':
        return 'int';
      case 'fixed':
        return 'double';
      case 'string':
        return 'String';
      case 'object':
      case 'new_id':
        return 'int';
      case 'array':
        return 'List<int>';
      case 'fd':
        return 'int';
      default:
        return 'dynamic';
    }
  }

  void writeEventClasses(StringBuffer output, Interface interface) {
    final ifaceName = toUpper(
      interface.name,
      prefix: prefix,
      suffix: suffix,
    );
    for (final event in interface.events) {
      if (event.description.summary.isNotEmpty) {
        output.writeln(comment(event.description.summary));
      }
      if (event.description.text.isNotEmpty) {
        output.writeln(comment(event.description.text));
      }

      output.writeln('class $ifaceName${toUpper(event.name)}Event {');
      for (final arg in event.args) {
        output.writeln(comment(arg.summary));
        output.writeln(
            '  final ${getDartType(arg.type, ifaceName)} ${toLowerCamel(fixName(arg.name))};');
        output.writeln();
      }
      output.writeln('  $ifaceName${toUpper(event.name)}Event(');
      for (final arg in event.args) {
        output.writeln('this.${toLowerCamel(fixName(arg.name))},');
        output.writeln();
      }
      output.writeln(');');
      output.writeln();
      output.writeln('@override');
      output.writeln('String toString(){');
      output.writeln('  return """$ifaceName${toUpper(event.name)}Event: {');
      for (final arg in event.args) {
        output.writeln(
            '    ${toLowerCamel(fixName(arg.name))}: \$${toLowerCamel(fixName(arg.name))},');
      }
      output.writeln('  }""";');
      output.writeln('}');
      output.writeln();
      output.writeln('}');

      output.writeln();

      output.writeln(
          'typedef $ifaceName${toUpper(event.name)}EventHandler = void Function($ifaceName${toUpper(event.name)}Event);');
      output.writeln();
    }
  }

  void writeInterface(StringBuffer output, Interface interface) {
    final ifaceName = toUpper(
      interface.name,
      prefix: prefix,
      suffix: suffix,
    );
    output.writeln();

    writeEventClasses(output, interface);
    output.writeln();

    output.writeln(comment(interface.description.summary));
    output.writeln(comment(interface.description.text));

    output.write('class $ifaceName extends Proxy');

    if (interface.events.isNotEmpty) {
      output.write(' implements Dispatcher');
    }
    output.write('{');
    output.writeln('');
    output.writeln('  final Context innerContext;');
    output.writeln('  final version = ${interface.version};');
    output.writeln();
    output.writeln(
        '  $ifaceName(this.innerContext) : super(innerContext.allocateClientId()){');
    output.writeln('    innerContext.register(this);');
    output.writeln('  }');
    output.writeln();

    output.writeln();
    output.writeln('@override');
    output.writeln('String toString(){');
    output.write('  return """$ifaceName: [');
    output.write(' name: "${interface.name}",');
    output.write(' id: "\$objectId",');
    output.write(
        ' version: ${toLowerCamel(fixName(interface.version.toString()))},');
    output.writeln(' ]""";');

    output.writeln('}');
    output.writeln();

    // Implement requests
    for (var i = 0; i < interface.requests.length; i++) {
      final request = interface.requests[i];
      writeRequestImpl(output, ifaceName, i, request);
    }

    // Events
    for (final event in interface.events) {
      writeEvent(output, ifaceName, event);
    }

    writeEventDispatcher(output, ifaceName, interface);

    output.writeln('}');
    output.writeln();

    // Enums
    for (final enum_ in interface.enums) {
      writeEnum(output, ifaceName, enum_);
    }
  }

  void writeRequestImpl(
      StringBuffer output, String ifaceName, int opcode, Request request) {
    final requestName = toCamel(request.name, prefix: prefix, suffix: suffix);

    String returnType = 'void';
    String returnVal = '';

    final params = <String>[];
    final args = <String>[];
    final argTypes = <String>[];

    for (final arg in request.args) {
      final argName =
          fixName(toLowerCamel(arg.name, prefix: prefix, suffix: suffix));
      var argType = getDartType(arg.type, arg.interface);

      if (arg.type == 'new_id' && arg.interface.isNotEmpty) {
        returnType = toUpper(arg.interface, prefix: prefix, suffix: suffix);
        returnVal = argName;
        continue;
      }

      if (arg.type == 'object') {
        if (arg.interface.isNotEmpty) {
          argType = toUpper(arg.interface, prefix: prefix, suffix: suffix);
        } else {
          argType = toUpper(argName, prefix: prefix, suffix: suffix);
        }
      }

      if (arg.type == 'new_id' && arg.interface.isEmpty) {
        params.add('int version');
        params.add('String interface');
      }
      params.add('$argType $argName');
    }

    output.writeln(comment('  ${request.description.summary}'));
    output.writeln(comment(request.description.text));

    for (final arg in request.args) {
      output.writeln(comment('  [${arg.name}]: ${arg.summary}'));
    }

    // Generate the request method implementation
    output.write(
        '  Future<$returnType> $requestName(${params.join(', ')}) async {');
    output.writeln();

    for (final arg in request.args) {
      final argName =
          fixName(toLowerCamel(arg.name, prefix: prefix, suffix: suffix));

      if (arg.type == 'new_id' && arg.interface.isNotEmpty) {
        output.writeln(
            '  var $argName =  ${toUpper(arg.interface, prefix: prefix, suffix: suffix)}(innerContext);');
        args.add(argName);
        argTypes.add(WaylandType.newId.toString());
      } else if (arg.type == 'new_id' && arg.interface.isEmpty) {
        // Handle the case where the interface name and version need to be specified
        args.add('interface');
        args.add('version');
        args.add(argName);
        argTypes.add(WaylandType.string.toString());
        argTypes.add(WaylandType.uint.toString());
        argTypes.add(WaylandType.newId.toString());
      } else {
        args.add(argName);
        argTypes.add(waylandStringToType(arg.type).toString());
      }
    }

    output.write('    logLn("$ifaceName::$requestName start');
    for (final arg in args) {
      output.write(' $arg: \$$arg');
    }
    output.writeln('");');

    output.writeln('    final message = WaylandMessage(');
    output.writeln('      objectId,');
    output.writeln('      $opcode,');
    output.writeln('      [');
    for (final arg in args) {
      final argName =
          toLowerCamel(fixName(arg), prefix: prefix, suffix: suffix);
      output.writeln('        $argName,');
    }
    output.writeln('      ],');
    output.writeln('      [');
    for (final arg in request.args) {
      if (arg.type == 'new_id' && arg.interface.isEmpty) {
        output.writeln('        WaylandType.string,');
        output.writeln('        WaylandType.uint,');
        output.writeln('        WaylandType.newId,');
      } else {
        output.writeln('        ${waylandStringToType(arg.type).toString()},');
      }
    }
    output.writeln('      ],');
    output.writeln('    );');
    output.writeln('    await innerContext.sendMessage(message);');
    // output.write('    logLn("$ifaceName::$requestName end");');

    if (returnVal.isNotEmpty) {
      output.writeln('    return $returnVal;');
    }
    output.writeln('  }');
    output.writeln();
  }

  void writeEvent(StringBuffer output, String ifaceName, Event event) {
    var eventName = toUpper(event.name, prefix: prefix, suffix: suffix);

    output.writeln(comment(' ${event.description.summary}'));
    output.writeln(comment(event.description.text));

    output.writeln(comment('  Event handler for $eventName'));

    for (final arg in event.args) {
      output.writeln(comment(' - [${arg.name}]: ${arg.summary}'));
    }

    final params = <String>[];
    for (final arg in event.args) {
      final argName = toLowerCamel(arg.name, prefix: prefix, suffix: suffix);
      final argType = getDartType(arg.type, arg.interface);
      params.add('$argType $argName');
    }

    // // Generate the event handler method signature
    output.writeln(
        ' void on$eventName($ifaceName${toUpper(event.name)}EventHandler handler) {');

    output.writeln(
      '   _${toCamel(eventName, prefix: prefix, suffix: suffix)}Handler = handler;',
    );
    output.writeln(' }');
    output.writeln();

    // Generate the private handler field
    output.writeln(
        ' $ifaceName${toUpper(event.name)}EventHandler? _${toCamel(eventName)}Handler;');
    output.writeln();
  }

  void writeEventDispatcher(
      StringBuffer output, String ifaceName, Interface iface) {
    if (iface.events.isEmpty) return;

    output.writeln(' @override');
    output.writeln(' void dispatch(int opcode, int fd, Uint8List data) {');
    output.writeln('logLn("$ifaceName.dispatch(opcode, fd, data)");');
    output.writeln('   switch (opcode) {');

    for (var i = 0; i < iface.events.length; i++) {
      final event = iface.events[i];
      final eventName = toCamel(event.name, prefix: prefix, suffix: suffix);

      output.writeln('     case $i:');
      output.writeln(
          '       if (_${toLowerCamel(eventName, prefix: prefix, suffix: suffix)}Handler != null) {');

      if (event.args.isNotEmpty) {
        output.writeln('var offset = 0;');
        for (final arg in event.args) {
          var argName = toLowerCamel(arg.name, prefix: prefix, suffix: suffix);
          var lengthVarName = '${argName}Length';

          // Ensure the variable name does not conflict with the dispatch parameters
          if (argName == 'opcode' || argName == 'fd' || argName == 'data') {
            argName = '${argName}2';
          }

          // Ensure the length variable name does not conflict with the argument name
          if (argName == lengthVarName) {
            lengthVarName = '${argName}Len';
          }

          switch (arg.type) {
            case 'int':
              output.writeln(
                  '           final $argName = ByteData.view(data.buffer).getInt32(offset, Endian.little);');
              output.writeln('           offset += 4;');
              break;
            case 'uint':
              output.writeln(
                  '           final $argName = ByteData.view(data.buffer).getUint32(offset, Endian.little);');
              output.writeln('           offset += 4;');
              break;
            case 'fixed':
              output.writeln(
                  '           final $argName = fixedToDouble(ByteData.view(data.buffer).getInt32(offset, Endian.little));');
              output.writeln('           offset += 4;');
              break;
            case 'string':
              output.writeln(
                  '           final ${argName}Length = ByteData.view(data.buffer).getUint32(offset, Endian.little);');
              output.writeln('           offset += 4;');
              output.writeln(
                  '           final $argName = utf8.decode(data.sublist(offset, offset + ${argName}Length - 1));');
              output.writeln(
                  '           offset += ${argName}Length; // Skip the string bytes and null terminator');
              output.writeln(
                  '           while (offset % 4 != 0) { offset++; } // Padding');
              break;
            case 'object':
            case 'new_id':
              output.writeln(
                  '           final $argName = innerContext.getProxy(ByteData.view(data.buffer).getUint32(offset, Endian.little)).objectId;');
              output.writeln('           offset += 4;');
              break;
            case 'array':
              output.writeln(
                  '           final $argName = getArray(data, offset);');
              output.writeln(
                  '           var arrayLength = ByteData.view(data.buffer).getUint32(offset, Endian.little);');
              output.writeln('           offset += 4 + arrayLength;');
              output.writeln(
                  '           while (offset % 4 != 0) { offset++; } // Padding');
              break;
            case 'fd':
              output.writeln('           final $argName = fd;');
              break;
            default:
              output.writeln('           // Unhandled type: ${arg.type}');
          }
        }

        output.writeln('var event = $ifaceName${toUpper(event.name)}Event(');
        for (final arg in event.args) {
          var argName = toLowerCamel(arg.name, prefix: prefix, suffix: suffix);
          if (argName == 'opcode' || argName == 'fd' || argName == 'data') {
            argName = '${argName}2';
          }
          output.writeln('           $argName,');
        }
        output.writeln('        );');

        output.writeln(
            '         _${toLowerCamel(eventName, prefix: prefix, suffix: suffix)}Handler!(event);');
      } else {
        output.writeln(
            '         _${toLowerCamel(eventName, prefix: prefix, suffix: suffix)}Handler!(${ifaceName}${toUpper(event.name)}Event());');
      }

      output.writeln('       }');
      output.writeln('       break;');
    }

    output.writeln('   }');
    output.writeln(' }');
  }
}
